 welcome back everybody so today a lot of you taking the midterm good luck if you're taking a midterm today in class we're gonna continue our discussion of objects so on Monday I introduced it to the syntax that you can use to declare a new type in Java so this limitation that we were operating under up till this point where there were only eight types of data that we can work with has been removed and now you can design your own types to model and to fit whatever data you want to work with in your program and hopefully then the class today if we have a little time well do an exercise where we think about let's come up with something in the world it's on piece of real world data that we might want to work with and figure out how to model it in our program all right so just a little review from last time so this is Java syntax that allows you programmer to declare a new type a new type of variable we refer to these types of variables as objects in your program and so it's C on line one I'm saying class that's sort of I was thinking about this last night I mean there's sort of it these sort of deep ontological concerns here right a class represents a type of thing in the world right so in this case I'm using this the name that I'm giving it person follows the class definition that probably hits that I'm gonna use this to model information about people and then I can have two things in my class definition I can have variables that are associated with the each instance of the class each object that I created this type so every person in my program is going to have a name and an age I can also do initialization in the Declaration of the class so this is valid so I can say the age is declared to be zero we'll look at another better way to do that in a few slides so part of the object state what is the information that I'm storing here and so again up until this point there was no way to couple together a string and it but now if I have a piece of data like a person where I want to use both of those types of information to store to model them or to store data about them I can do that I can also declare that a particular type of Java object provides certain functionality it can do certain things and I do that by declaring methods as part of my class declaration so down at the bottom here from line simontann I'm declaring two methods the first one is called print name doesn't return anything takes no arguments and simply prints the name of that person object the second one is called birthday and that's a function that increments the age of the person you'll see here that I don't have to use the this keyword so both line 9 and line 12 are valid we'll talk in a minute about how Java resolves names when it's executing or compiling functions that are included as part of a class declaration okay if I want to be explicit about what I'm referring to I can use this special keyword called this this is another reserved word in the language whenever I'm running to function that's part of a class this refers to the instance of the class that's running that function so I can use that to refer to my instance variables so in this case I have my dimensions class from last time that has width and height and my area function is returning the area of this particular dimensions of width times the height this always refers to the instance of the class the particular object that's executing that because this method is associated with an instance of this class so whenever I call area I always have an instance of the class I can't call that function until I've created an object of that type so this also works like I just said I don't need to use this okay so and this is sometimes this version without this is sometimes clearer and cleaner so how does Java run this code right so this is weird right this is strange it's different than the function the functions that we've looked at before because you might wonder you know if your job on you're running this code you're trying to compile this code you start compiling this area function it takes no arguments and there's no local variables that have been declared as part of this function so how can I refer to a width and a height where do those variables come from well when the Java compiler compiles this code remember that's the first stage before I execute it it comes to this variable and it says okay this is interesting there's there's the this function is using a variable called width and it says is there a local variable in this function called width that's been defined inside the function body the answer is no is there a parameter to the function called width maybe one of the maybe the function has parameters and you've decided to call one of them with no the next place it looks is on the class definition so now it says okay while there's no parameters to this function there's no local variables that have been declared let me look in the dimensions class where this method is defined and see if I can find something called width and sure enough the dimensions class has a width very one thing I want to explain and this is gonna be something that you're gonna see more often on the rest for the rest of the semester in Java everything is part of a class every function that you write in Java has to be part of a class every variable that you declare has to be either inside a function as a local variable or declared to be part of a class now you may be wondering any code that you write has to be inside a function which itself has to be defined on a class so you might be wondering how have we been doing these examples on the slides like the one that we started like the one that's on the cover slide for today's lecture so let's go back and look at this oh actually no one no one's on a good one to show you I don't think I have a good one to show you so we've been playing games we've been performing some trickery with the code that you've been running in our playground up until this point it's been allowing you to do that but I just want to make sure this is clear because it can be confusing once we start to use these new examples in Java it is not valid Java to just declare a function I can't declare a function outside of a class it's not valid Java to just have some code that's going to run I can't declare what's called loose code outside of a function and I can't declare a function outside of a class why have we been hiding this from you at this point because it's confusing because I don't want you coming in here on day 1 and looking at a class declaration in a method declaration and then it's like system dot out dot print line HelloWorld like that's frightening so we've been playing games with this to allow you to work in a little bit of a simplified environment but Java has very strict rules of moments I can't have a function outside of the class if you try to compile that in IntelliJ or Android studio it won't work all right we're only getting away with it because we've been playing some games so from this point forward our examples are going to look a little bit different so up until this point we've been letting you write loose code outside of a class declaration so up until this point something like this would work okay so I was able to put a print line statement up here oh come on friend let's do this well anyway whenever this gets finished running this is no longer going to work okay all the code you write has to be inside class declaration I'm frightened that this isn't running let me try reloading it see what happens there it is okay let me put it outside and just make sure it still breaks Oh something's wrong with my five runner okay it's that later all right so that that's clearly not going to work anymore it should produce an error message but we'll go back and fix that later but right so going forward this is true from this day forward all the playground examples we do in class are going to have this format we're gonna start showing you how to build class declarations now there's a little still a little bit of magic here that you won't understand for like one more class but here's what's gonna happen whenever you run code in our playground now execution is gonna start in the main method of the example class from that point you can do whatever else you want you can call it the methods you can write code in there you can do whatever you want but that's where things are going to start we're not going to run loose code that's outside of it okay now the nice thing about this is we can still put multiple classes inside we can still put multiple classes inside the same playground right so if I wanted to declare dimensions class that's still going to work and we're going to use that to our advantage as we start to do some new panels ok so here's here's an example in this new format this is similar to what we did last time but I just want to show you how it looks a little bit different so up at the top I'm declaring my dimensions class width the width and height and an area method that returns the area of that particular dimensions object down here I'm creating a new dimensions object so this is good review on line 11 I'm creating I'm declaring a new variable of type dimensions remember I can create my own types now so this is my type I'm calling it example and on the right side I have this syntax that we've been using where I use a new keyword the name of the class and that's something that looks a lot like a function call right I've got to I've got to curly brace parentheses here there's nothing inside of it that sort of looks like a method call and it is a method call and we're gonna explain what's happening here in a minute but here I'm studying the width and height of that dimensions object and then I'm calling the area method and expecting to get the result that I want make sure this works good okay so let's talk about that special method okay so this thing right here when I call new the syntax of creating an object in Java is the new keyword that says I want to create a new object use the name of the class and then I have two parentheses that is in fact a method call it looks like one and it is this special method that's being called is something called a constructor and it does what the name implies it constructs a new instance of that type of object that type of class a new instance of that class now the constructor is responsible and can do any initial setup that needs to be done to create the object and initialize it properly so here's an example now constructors as methods that are part of a class have a special syntax okay so whoo so that's a this is a this is a valid constructor who can tell me something weird about it yeah it is no return type aha that's correct constructors do not declare a return type the reason is they always return a new instance of that object that's the only thing they can do so you don't even and I don't have to call return anywhere inside my constructor that happens automatically so there's no return type and then there's something else about this constructor yeah yeah it shares the same name as the class exactly so my class is called course and the instructor has to should the constructor has to share the exact same name and that means this is the one case in Java where you can start a method with an uppercase letter in typically will because your classes are going to start with uppercase letters that's our naming convention that's how we know that it's an object instead of a primitive type and so your constructor needs to be named after the class and there could so the constructor is also going to start with a capital letter constructors again are responsible for doing any initial setup that has to be done in order to create a new instance of that class a new object of that has the type of that class in this case what am i doing well I'm saying if you want to create an instance of type course that course has to have a name because when you call the constructor you're gonna have to now pass a parameter right you can constructors are like other methods you can overload them you can create as many as you want with different type signatures the other special thing about constructors that's not obvious from their declaration is they can only be run once I can never call the constructor again they're only run when the object is created so I can never call them again it's not like another method on the class so they could call it multiple times the constructor gets called once when the object is created and cannot be called again later now the constructor itself can call other methods that are part of the class which you could then call again later but I can't call the constructor again so just to reiterate what we just pointed out the constructor has to be named after the class it has to be declared to not return any anything and it always returns a new instance of that type of object you should create constructors as part of your classes to do any type of initialization that is required to create a valid instance of that class so a constructor is something that you create when you design your classes and this is an opportunity for you to make choices about things like what are the default settings for different fields our certain fields required for someone to create an instance of this object and things like that right okay so now I get and like other functions like I said a minute ago I can overload constructors so you'll typically find classes that have multiple different constructors with different method signatures so here I've got two different constructors so now what I'm saying is hey if you want to create a course object an instance of type course you can either create it and pass a name that I'll use to set the name of the course or if you want you don't know the name yet you can call an empty constructor and I'll set the name to an empty string so I've got two different constructors here that are called depending on how many arguments I pass you guys constructors couldn't so in a lot of cases I want to use one constructor to call another constructor I can do this using by using bits so this is not only a special variable that refers to an instance of that class but I can also use it like a minute so here I've simplified the example I used a minute ago so now I have one constructor that sets the name and then if I have an empty constructor that's sometimes what we call a constructor that takes no arguments that calls the constructor that takes an argument with an argument that's just an empty string so if I start if I call this constructor I get to set the name if I call this constructor with no arguments the name ends up as the empty string we're gonna do an example of this in a minute now so you might wonder we've been using objects up till this point we've had this dimension object we were playing around with and stuff like that why didn't I have to provide a constructor so if you don't provide a constructor Java will simply not initialize any of the fields on your object so if you don't provide a constructor there's a default empty constructor and you can think of it as just this okay so this is the default constructor that is added by Java if you don't provide any other constructors now one thing to point out is as soon as you provide an empty constructing instructor you lose this empty constructor so the empty constructor is only provided if there's no other constructors typically you do not want to use the empty constructor it doesn't do anything useful okay so typically when you define a class and this is one of the things about Java that I would argue is kind of broken you should really be required to provide a constructor for your class the empty constructor is not helpful all right well me let me let me get to an example here I'll come back and do this insect okay so we'll come back and talk about this in a minute okay so now let's say I've got my person class here and let's say I'm gonna have you know I'm gonna use my usual fields here I'm gonna have it for each person's gonna have a name and then let's let's use a double as an age being multiple more precise so at this point I haven't provided a constructor so what do we think the value now this code will work does it not going to display anything yet what do you think the value of age is going to be anyone have a guess yeah zero yeah so the the uninitialized value of a double and all of the other numeric types is zero so remember the constructor didn't the empty constructor doesn't set any fields and so if I don't set and you can look this up online Java has a documentation page about this if I don't set the value of a double it defaults to zero so that's okay I guess I don't know I might be that seems like a reasonable default value what about the name though here's a problem well you think this is going to be yeah yeah let's find out indeed so the name is going to be null so any objects that are part of my class like if I create a new let's just create a new example up here public class dimensions and should accept let's be empty if I change this of course I wouldn't do this because well people have dimensions I guess that's also know yeah any object that's uninitialized that variable is set to null and that's a problem because you know what if I want to do something like set this back to a string say figure out what the length of your name is now I had this runtime error this is one of the reasons why it's so important to write constructors if you don't write one and use an empty constructor you end up with values for the fields that are not only not helpful but they may cause errors okay so let's provide a constructor for this class all right so we're gonna call it we have to call it person so by default this is gonna behave the same way so I can write an empty constructor for my class that does no initialization that was already there right but the kind of cool thing here is that as soon as I provide a constructor that takes an argument let's provide let's require that you set the age of the person when you create Oh something something is wrong here I apologize I think what's happening is errors aren't being shown properly which is sad so we will fix this after class I wish I had noticed this is more all right so if we could see it what's going to happen here is there's gonna be a compiler error the compiler is gonna it's going to tell me you can't call this empty constructor anymore because you've declared a constructor that has a feel okay so now if I want this to work I'm going to have to actually first get my Wi-Fi working again step one let me switch over to this other slot X this is fine I think all right all right I'm over here now okay good so now I'm gonna go back age here and then I'll I'll write a constructor that sets the age agency quota set age and now if I set this this just this report now let's print what happens okay again I apologize about the air with playground clearly we need to test this a little bit more but if I give it a valid age good right if I pass in something that's a you know this is just another method right if I pass in something that here it's a string or whatever I'm not going to get the right result so now let's imagine that I add another field let's put our name back every person should have a name and if I want to require you to set the name I can change my constructor so that it requires both fields and now this will work named Ling so now I can print the length of your name good okay any questions about this before we back up for a minute and then go on let's write a second constructor just for fun I just do this quickly and then I will take that question say let's say we want to have a case where I only set the name of the person he's the default value for the age I'm gonna call my primary constructor with the default argument and now I have two constructors I allow you to create an instance of the class with just a name or you can create an instance of the class with the name and any question over here yeah ah right okay so the question is why does my main method have a parameter called unused so this this was designed to match the way that the main method works when you run it in an actual Java program we taught we talked about this when we talked about main a couple of classes yeah yeah no sew one okay so what happens here what am I doing here so let's let's see what happens when this constructor gets called let's put a print line statement here okay and this is so angry with me today why fine here it's also going down just not good all right I give up this example let me go back here maybe by the time I'm done talking about this playground we'll have recovered all right so one of the things about constructors that's interesting a potentially problematic for you right now is that they have to return an instance of that class there's no way for them to fail you can't use a return statement inside a constructor it's just gonna run and I'm gonna get to the bottom it's gonna return a new instance of that object so any setup you do will get done and he said if you don't do won't get done there's no way to return and in particular I can't fail so the constructor is always going to return a new instance of that class let's say I pass bad arguments so what's an example of a bad argument that I could pass to set name 10 some people might have the name 10 that could be an okay name I don't judge yeah yeah what if I pass null - my name variable then essentially I'm the same thing is happening that I was trying to avoid I'm I feel pretty confident that a person should have a name maybe their name is null the string null that's okay again I don't judge but they shouldn't have an empty name so the problem here is that if I passed you know normally in a function when you guys write them for your homework problems and on the quizzes we tell you how to handle no it's a bad value and you're supposed to do something to respond to that the constructor doesn't really you guys don't yet have a good way to do this the constructor has to return a new instance of the object so if you don't set name names going to be null if you set it to null it's going to be no so those are your two options and they both achieved the same thing we will talk more about this when we come back and talk about static methods in a couple of classes and then later in the semester when we discuss exceptions because those are a couple of the strategies that you have for avoiding this problem okay Oh still going need questions about constructors before we go on and talk about visibility a little bit so you know guy I don't want to you know do you guys to feel like this is mysterious constructors are a method that you write that runs code it just happens to be a special method that gives us a chance to do specific initialization that you want to do every time a new instance of the object is great yeah what's that know yeah so a constructor can only be called once there's no way to even name the method later so the method the constructor gets called when the new keyword is used to create the instance of the object and there's no way to call it after that so you know go back to my sad stalled playground here I could so I could do something like this for example I could have a I could have a set up person method that takes a string set name and a double set age and then I could do this so that would work so now do you see the difference now I have a method that I've declared as part of my class that it can use later right so now if I had a person object and my playground didn't hate me I could do you dot setup person and I could pass whatever I wanted yeah so I can't call the constructor but there's nothing stopping you from creating a constructor that uses a field on that oh yeah no it doesn't make the way that Java compiler works is the method order within the classes well yeah is that I think Python has that problem with job it's yeah ah good question okay so do I need to set the constructor private or public I can use those keywords we're gonna talk about disability in just a sec the constructor oh man okay I'm gonna you see you can use private on a constructor definitely I feel like the constructor by default will be public but I'm not sure about that I'm gonna have to look that up but I can use those visibility hours on constructors you might wonder what I would I ever declare a constructor private and it turns out that there are valid arguments for doing it we'll come back and talk about that way talk about static okay other questions about constructors like I said you know this is the point in this semester where you know this is not tricky but objects and thinking about how we model data using them is more conceptually challenging and the stuff that we've done before even if the code is super simple right I mean all we're doing is setting fields on our objects all right so let's talk a little bit about visibility or what John refers to is access modifiers you guys have started to see these around and so again now that you know notice them and might have wondered about them a little bit let's talk a little bit about what they actually are so when you're designing your class one of the things that you might want to do you might want to control how that class is used you might want to control who can run certain methods you might want to control who can set certain fields so Java provides what are called access modifiers that you can use on both instance variables and instance methods so both on the data and on the algorithms that are part of your method so these are referred to as access modifiers there are actually two of them that we're gonna look at right now our public and private they're actually two more there's something called protected and there's something called packaged private which is essentially you you get by not including an access modifier which is confusing but but for now let's focus on public and private so public and private do sort of what you would think based on their name so when I mark a method or a instance variable as public that allows anybody who has an instance of that class to use it if it's variable they can modify it or retrieve it if it's a method they can call it so here I've got a public class person and what I've decided is that when I designed this class for whatever reason I want anybody to be able to modify the name so I've marked it explicitly as public but I only want my methods methods that are defined on this class to be able to change the age so private doesn't mean that the variable can never be modified that wouldn't make any sense instead private means that only methods that are part of that class are allowed to either retrieve or modify the value of that particular variable so my age variable now can only be set or retrieved by methods that I defined on this class okay so now if I ran the following code and I created a new person on line seven I can modify the name that's okay because I mark the name is public but if I go to try to retrieve the age that's gonna cause some compiler error so the compiler is gonna say the age here is marked as private and this code is not running inside the class okay so a public variable can be read or written by anyone a private variable can only be read or written by methods defined on that class Oh Lord let's see if this is gonna spring back to life or not nope bear with me for a second I'm nervous that the Wi-Fi in here has gone down so let me see if I can reconnect to this my access point is the website down for anybody else okay sweet it makes me happy all right I think at least for now we're back online that may happen again in like 30 seconds but let's see how far we can get okay so let's declare let's let's let's do this example so it's Eclair our our name let's declare our age to be again to be let's declare the name to be public age to be private and now let's set do you not name is equal to test make sure that this code still compiles which it does and let's print you not name good okay let's try setting your age hope that this probably isn't gonna crash yeah yeah I think it's I think it's me crashing my own own system so put this back here public string name private int age and now if you set the age we're gonna see that it's gonna hang I changed this to public however then I can set and retrieve the age I could until the second ago all right it's really not my day so I'm just gonna go on any questions about constructors or about oh wait okay we're doing Isis bonfire sorry yeah all right so we're just gonna have to stick with looking at these examples today once I modify this it's like back to the Dark Ages like two years ago when there was no playground so once I modify one side add the private access mod or to a variable then I can't change that variable anymore right from outside that that piece of code okay so public anybody can read or write that variable private the variable can only be read or written by methods to find on that class okay and you have to trust me that this works I can apply the same access modifiers to functions or to methods that I define on the class and the meaning is similar although with the function like there's no set or get it's just can I run the function or not if I mark the method it's public then anybody can execute it so here line 10 it's gonna work fine because print it has been marked as public line 12 on the other hand is going to fail this print you has been marked as private so public anybody can run it private can only be run by other methods on that class so for example print it can call print you but I can't call it from outside the class itself right again you have to believe me there are a couple of other access modifiers that exist in the Java world there are there is one called protected that you may see lying around and there's something called packaged private but neither one of those makes sense until we have a little bit more of a notion of what a packages right so we may come back to those later in the semester okay so let me show you a common pattern so I've been told this point when we've declared a class if we wanted to use the variables to find out in that class we declared them as public and then anybody could set or get those variables however that's not how it's typically done in Java and in fact if you try to do this the default check style rules that are a little different for our playground but the default checks our rules will complain they will say you can't you shouldn't create public instance variables which is weird right because then it's like how do I store information as part of my class so this is the pattern that the Java community arrived at and this is interesting because this was not something that was part of the original Java language specification but this became such a common pattern that if you look at the jvm languages that emerged like Kotlin and Scala and groovy they all follow this pattern ok so here's here's the design pattern again there's no rules about this this is a convention but it's a very strong convention if I want to store data on my class I do the following I create a private variable to store the data so on line this so this person it's gonna have an age but I just don't let anyone set it by marking it public instead I mark it private then I create two functions and these functions have very specific signatures we're gonna have we're gonna have you guys write some of these for later quizzes and homework problems and at some point all gonna tell you is right a getter for this variable and we expect you to do something that looks exactly like this okay so on line three I have something called a setter the name is set followed by the name of the variable it returns nothing it takes one argument the same type as the variable that it's used to change and all it does is modify that very so this is a function that I use to set the value of age okay great this is known as a setter on Line six so how do I retrieve the value it's private so I can change it but I can't get it so I write a separate function on line six that's called a getter the name is get followed by the name of the variable all that does is return the variable that I'm requesting and the type that it returns is the same type as whatever variable that is okay so again this is not this is something that is built in two languages that inherited from Java but it's not built into Java so this is the pattern that we follow okay private variable two functions these functions are boilerplate in fact you can get IntelliJ to generate these functions for you Android studio will do this there's a way to say you know generate the constructor for this variable and this is what it will produce the getters and setters sorry getters and setters for this verb right so you might wonder like why this seems weird I'd why not just mark it public okay so I before I had one piece of code here that marked it public and I was good now I have six lines of extra code that I've introduced into the problem we're gonna clear out here a little bit early today because the class coming in here has an exam so I'm gonna leave you with this cliffhanger of a question that's answered on the next slide and we will pick up here on Friday all right if you haven't taken the midterm yet good luck I have office hours today from 1 to 3 I will get the playground back up right after class and I hope you guys have a great Thursday I will see you on Friday  
﻿ all right everybody welcome back so today we have a lot to do I'm gonna get started we're gonna continue talking about Java objects today and we're gonna continue looking at how we can organize objects into hierarchies using this concept of inheritance that we started looking at on Monday and then we're gonna introduce one of the more interesting features of that goes along with these hierarchies which is the ability to work with an entire group of Java classes that shares similar features and that comes about because of how Java's inheritance system works so I can actually write code that works with an entire category of different types of Java objects without having to know exactly what kind of object each one is and this is taking advantage of a feature of Java's object model called polymorphism big word sounds a little scary not really we're gonna demystify it for you we're also going to connect it with some really beautiful theory in the programming languages area alright but let me just talk about what's gonna happen over the next couple dates so this is one of the points in this semester where I get a sense people a little tired a little grumpy you have midterms and other classes and stuff like that the projector is grumpy clearly all right so here's what we're gonna do on Friday today we're going to talk about polymorphism we're gonna do some look and review some stuff about inheritance which we introduced on Monday and then on Friday we're gonna take a break from class so no class on Friday I won't be here guy take class that much so bad thing you guys applaud for is like makes me feel a little bad about myself okay cool don't like the book you don't like class alright hopefully like me a little bit at least if I come to office hours and then you'll definitely not like me alright so yeah take the day off sleep in at 11:00 but I mean yeah sleep in till noon go to office hours get mp1 done you know I see a lot of people making good progress on that MP finish it up we are having class today it's not Friday okay on Monday we'll do kind of a little bit of a slow down session where we review Java objects mop up anything we might have missed today I'll do some examples from this week's homework problems show you how to work out some of those in cases where you might have been confused and then on Wednesday we'll keep talking about polymorphous alright this is an important topic and something that I want to make sure that we get clear before we go on okay so last time we talked about inheritance and we introduced the new keyword in Java that allows us to establish relationships between these new Java classes that we're creating it's all moving very fast right this is getting very exciting so first we broke open Java's type system and we got in there we can now build our own types in Java by declaring a class and showing Java how this particular type of object is supposed to behave so that's really cool we can also establish relationships between our classes and this is going to be something that it's gonna be we're going to talk about how to do it first and then it's going to take a little while for this to be come clear about why this is so useful but it will and in particular we're actually have a section of this semester's machine project where you're going to go back and you're going to kind of unify some of the code from the target mode that you worked on for mp0 and the area mode that you're working on now you might think well these share a lot of common features and it turns out they do and in one of the later checkpoints are going to go back and refactor that code to pull out the common pieces and you're going to utilize this concept of probably more we're talking about today so you know Jabba's object hierarchy Jonathas type system in general again it's about building programs that interface with the real world being able to work with entities in the world so very few real world entities can be described by a single value single integer value single double value you actually have to combine different types of data together to do a reasonable job of representing a person or representing you know a sports team or representing a particular item of clothing that you might be selling on a website or whatever you know the type of things we want to work with in our programs we need a way to represent that job as class system is about allowing to suit to do that and not only does that allow us to model real world data but javis class system also allows us to model relationships between data that we see in the world hierarchies families groups you know so and and this is something that and there's a power behind being able to organize things into categories and groups like this this is one of the reasons why for example zoologists have spent so much time centuries maintaining this tree that tries to organize all life on Earth and to and I am NOT a zoologist so I'm not gonna get the names right it's like families and some families and species and order and genera and like Latin words in there or whatever but the idea here is that you know there's some their relationships between organisms at the top you start out there these two you know two or three big categories I am displaying my ignorance here I think there's two you know big categories of different types of organisms and then as you go down you break them into smaller and smaller groups right so we're trying to identify common features of things so here's an example just you know something I pulled from online somewhere right so you know these these things that are below mammal are all mammals there's a lot of other mammals as well but these are examples of mammals and then for certain types of creature I can subdivide it further right so for example cat fee uh well what are sometimes known as Fela forms it's an entire category of creature that includes not only your domestic house cat but also you know lions and tigers and Panthers and stuff like by the way you know I was I was laughing today because I made that comment about KITT not it not being clear whether caps are actually a pet or not but when you have a cat this is what happens to you you wake up in the morning and you find something like this and you have no idea what happened right so I think I think something happened last night with me and the cat I don't remember what it was maybe she does but she left a mark all right so we could do the same thing in Java and the reason for this is because when we work with data in our programs it can be natural to want to express these kind of taxonomy and relationships that we actually find in real world data real world entities it also allows us and you're going to see this to organize our projects in ways that allow us to reuse code between multiple classes so when we have two classes that are starting to share a lot of common functionality a lot of times that's because they're really two different kinds of the same thing so we can do is we can create the thing that they're the same kind of and pull some of the functionality into that superclass a parent class and then just have the children you know implement whatever additional functionality they might be I'll show you an example of this that sounds very abstract but it's actually pretty pretty practical okay so here's Java's object tree and you could actually do this this is not the whole thing it would be way too small to see even on your laptop you can take any piece of java code you can take any java class and all the java classes you wanted to think about and you can organize them into this type of data structure this is something that is commonly known as a tree we will talk more about trees later in the class when we talk about data structures the trees are typically looked at upside down might want to actually think of them as sort of roots right so at the top is the parent class of everything in Java everything in Java if you follow it up the tree you eventually get to this special class called object that we'll talk about a minute and again this is just one tiny little piece of the entire Java class hierarchy but this is this is actually you know this this is something so there's you could imagine there's a character class okay character is one type of thing we might want to model in the world characters an entire class of entities I can further break down characters into two different types of character there are characters represent a numerical quantity that we sometimes refer to as digits or a part of our ability to represent numerical quantities digits and then there are letters I don't know enough about other languages to know if this separation exists another languages but maybe it does but maybe it's not so clear and you know the Latin alphabet we have certain characters that represent digits and then those characters aren't used as part of words unless you're like using lead speak or something like that right but and then so I can further divide character two digits and letters right and I could divide letters and again this is now very certain Latin alphabet English centre-right I have letters that I refer to as vowels and letters I refer to as consonants right depending on how they function in spoken language and again that that probably doesn't match up with other languages so if you did this type of taxonomy for another language you would need to do it differently okay but this is an example of a tree so let me just you know it's just maybe something that not all of you seen before so let me just make sure that it's clear what's happening here so every the this if I go from one of these nodes and go up I go to its parent so digits parent class is character carrots parent class characters parent classes object if I go down I'm finding the children of that particular class so digit would be declared to extend character letter would be declared to extend character vowel will be declared to extend letter any questions about this before we go on yeah yes that's a great question so the question is 270 relationship with the primitive type care it actually does so and and we'll come back and talk about this later in the class so for reasons that I'm not going to get into right now Java actually has for every primitive type it has something called an object wrapper so it has an object class that holds one value of that type so therefore inch there's something called capital integer for character for car did we decide how to pronounce it I can't remember for car its capital character I'll tease are sometimes known as boxing types I will come back and talk about the later in the class there is no need for them yet but it does have a relationship with car good way other questions that's higher okay so like I said every object in Java but one has a parent and it doesn't matter whether you just say that you're you you may think I don't want a parent I sprung from the head of a god I don't need a parent but it doesn't matter even if you don't declare that you extend another class in Java you extend object so these two class declarations are equivalent if you do not declare explicitly that you extend object you extend out there is no alternative there's only one class in Java that does sound of a parent that class is capital o object okay and I will try to be as clear as possible when we're talking about objects and Javas class system whether I'm talking about capital o object or an object but capital object is the parent class of everything in Java if you take every Java class and you go to its parent and its parents parent and its parents parent and sometimes there are very long relationships you go to see some really complicated mature projects IntelliJ for example I think is written in Java I said you wouldn't looked at the IntelliJ source code you might find classes where it might take you lots and lots and lots of parents to get to object but you will always get there you start at any class in Java you go to that classes parent that classes parent that classes parent you keep repeating that process until you get into you don't find a class that has a parent and you will get to object this is a design choice about Java other languages don't all have this feature so there are some other languages that allow you to establish your own trees that aren't rooted at the same place but in Java everything is rooted object okay so this is what results from that decision so remember last time one of the two two times ago when we started talking about well sorry not last time we talked about inheritance one of the ways that we started that conversation was posing this mystery about why Java classes have these methods that they didn't declare or provide an implementation for like to string I can take any Java object and I can call a two string method on it takes no arguments and returns the string why can I do that because that method is declared by capital o object so there's a small number of methods in Java I can remember exactly how many but it's like under 10 or maybe around 10 about 30 men it's certainly are not like string where there's like hundreds there's a small number of methods that are declared as part of the capital o object class and as a result every single Java object has these methods so that's kind of cool right you might wonder why is that useful because those methods may not do anything very many anything useful but we'll talk about that in a sec but if you have any so if I give you an object in Java as long as you know its son if I could give any variable as long as you know that it doesn't contain a primitive type you can call to strength it will always work right so here's an example I have the dog class the dog class is not declared to extend object but it implicitly extends object and because of that it has a two string method now I'll show you in a minute that two string method doesn't actually do something particularly useful at first but we can customize that behavior and make it more helpful okay this is one of them so this is another one of these organizing principles that is gonna see something that we're gonna see again and again throughout the rest of the semester are these common object methods okay they're gonna organize a little bit of our journey through the rest of Java's class and type system okay so here are the ones that I want you to care about you're welcome to go up and look there is Java doc for capital object that you can go and look at and you can see the Java doc declarations of all the methods that every Java object inherits from the object superclass but here are the ones that we care about all right one of them is called - strength - string returns a string this is name implies and the idea of a high - string is to take an object and return some kind of human readable representation of that object the main place where to string is used okay is during debugging this is not something that you typically use as part of code that a user is going to see when you do that you need to write more so for example imagine that you're trying to take you know your area mode and and display it on the screen right that you don't do that using - string you know you need to do a lot more work right to turn it into a useful graphical representation but when you're like let's say you're debugging and you're trying to print off an object and you want to know some stuff about it - Strings super helpful or it can be if you implement it correctly okay that's one of those methods there are two more that we care about - more maybe three more equals okay so this is interesting there's a notion in Java of object equality are two objects the same it turns out when you create a class in Java part of what you get to decide is what it means for two instances of your class to be the same and you do this by implementing this method okay so every object has an equality method I can compare it with any other object and then finally there's something called hash code and this is probably the one that makes the least sense to you right now it will come back later it is incredibly use when we tarts start building some more interesting data structures that are that we can use to store and work with different types of java objects okay for now you can think about it it returns an int and the idea is that this int is supposed to represent all like kind of combine together to hash does anyone ever had a hash for breakfast before really it's really good you should try it's like a hashes you know a bunch of stuff all combined together chopped up and I'll throw it in the same place so that's kind of what half tho supposed to do supposed to take all the objects contents and reduce it down to one int that is supposed to change if the object's contents change but not change if they don't and again we'll come back in a more partner okay so you might wonder you know why is it useful why are these object methods to find an object useful because you know think about it let me go back here let's look at a look a dog looks like a dog again okay so dog has slides yeah there we go better okay so dog has a name right but but you know the to string method is to find on its parents on the object class so the object to string method is not going to be able to print anything useful about this dog probably the thing I want to print if I print off a dog is its name it's the only piece of state it has right now that would be helpful during debugging I have a bunch of dogs figure out which you know there's a bug in my code it's caused by trying to do some operation on a particular instance of dog which dog is breaking my code you know pretty enough its name would be helpful maybe it's named axel oh they got set to null or something like that okay so what you will typically do is you will not use the methods that are defined by the object superclass they're not very helpful they don't know anything about your class instead you'll do something called override them what does that mean so overriding a method means replacing a method that you inherited from your parent or your parents parent or one of your ancestors with your own implementation okay so here what I'm doing is I have a dog class the dog has a name and I've decided it would be more useful during debugging to print the name and so instead now my dog class is going to have a two string method no matter whether I override it or not because I'm Harriton it from my parent which is capital object here because I didn't extend anything but if I want the name method the two string method to be more useful i over ride it i just returned the name of the dog now when i print this object it's going to print that name okay let me also stop and pause and give you a brief introduction to how when we know when you call a method on an object how does Java figure out which one to use so here's what it does it starts in the here it's gonna start in my dog class and it's gonna look for a method called to string that method has to take no arguments it has to match the type signature that's used in the call note that this is done by the compiler not at run time which is helpful because the compiler will catch these errors form so in this case the compiler finds a method called two string that takes no arguments and so that's the one that gets used if it doesn't find that it goes up and it looks an object and it finds as it looks in my parent class it finds the method there and it uses that one if it doesn't find the method there then there's no failure occurs so just to you know put up on a slide what I just said whenever I am looking for a variable or for a method to call or to modify I start in the class then came with and I say does it have up a variable with that name or a method with the right signature the name and the argument if so I use that if not look in the parent class but remember the parent class might define its own private methods and so I won't I can't inherit a private method so I only look at the parents class public and protected methods I can't use its private methods those were private to it and I basically continue this process until either I find the thing I'm looking for or I get to object if object has it I'm good if object doesn't then I thought the compiler fails and it will give me an error message all right so let's play around with this a little bit okay so I've created this arbitrary and convoluted class structure so I've got an animal class that's the parent here that extends object and I might as well I'll just you know what it doesn't matter usually you'll almost never see anyone extend object explicitly because you don't need all right so animal extends object pet expands animal dog extends pet old dog extends dog sweet old dog stands old dog I should really have a another super sub class here called itchy old dog is that sort of more what he is these days all right so I'm creating a sweet old dog object an instance of the class sweet old dog now let's see what happens when I call to strength there is no to string method defined on sweet old dog know it's mad at me about something Czech style there we go okay so what happened here let's talk about the process that Java went through when it looked for this method it started so it said okay I'm an instance of this class called sweet old dog the sweet old dog provide a method called to string that takes no arguments no so where do I look next sweet old dog doesn't provide that method what's the next class I look at ya old dog go to Sweden dogs parent this old dog provide that nothing oh where do I look next dog where do I look next but where do I look next animal where do I look next object now if you don't override to strength so if you don't provide your own implementation of this method this is what object provides for you okay you might wonder what is this okay so this is combining the only two pieces of information that object knows about your class the first one is its name and then there's an @ sign and then there's like random thing that looks you know the changes every time I run it again anyone want to make a wild guess about what that is yeah yeah it's I think it's the hash code for the object actually and I think it has something to do with words stored in memory but this is not useful like if you were trying to debug your program this is not useful okay so instead let's override the to string method so I'm going to provide a public method called to string okay and let's just return sweet old dog for now we're gonna make this better in a minute okay so now you see what happened I have and it's just a sweet old dog so I started looking there and I found the to string method right away so it's done now let's send it let's imagine that every pet so I'm gonna call let's let's just do this here for now let's met and let's imagine let's make every Street off this sweet old dog have a name and then let's provide a constructor that sets the name and now let's just return the name okay so the first thing it's gonna happen is I'm gonna get Pilar error because my constructor my empty constructor is gone because I provided a new one and now I have to provide a name and now I can provide the name during debugging if I create another sweet old dog now let's print pull his name there we go okay so now let's try something a little bit different let's say we have an old dog but one that's not sweet I would never do that to Chu Chu but let's make Balu an old dog who's pretty sweet too but okay now what's gonna happen okay so I've moved one level up from sweet old dog so what am I gonna get when I run this oh yeah it doesn't have a constructor that takes the name let's get rid of that now again I'm seeing the default object to string method that's printing the name of the type just old dog and memory so now let's see how this let's experiment with how this name resolution works so let's add a method up here okay do string let's put animal what's gonna happen now all right so now I've added a two string method and this seems like this can be useful because now this two three this is a slightly maybe a slightly more useful to string method than the one that I get from object and now this is gonna be a default to string method that pet can use and dog and use an old dog can use and so when I run this what I should see is you know animal oh okay so I have a problem here what's the problem yeah yeah so I need to make this public now it works there again let it I think you know let's pause here because really important to understand how this works how the Java compiler does this so choo-choos when I start looking for the two string method with choo-choo I start in the sweet old dog class which overrides to string okay and so that's the method I get I got the method declared on line 14 when I start looking for a two string method for an old dog I don't get the one defined in sweet old dog because I'm in sweet old dogs parent old dog doesn't override to string pet dog doesn't override to string pet doesn't override to string animal does so that's the one I get now again this can go wrong in a variety of different Ray's so for example let's make a public string to string and let's have it take an argument so ever return nothing again same thing so when I'm looking for the method to call it has to match the type signature exactly I'm looking for a method called to strain that takes no arguments not looking for a method called to string that takes an it I changed this from movie an argument now it'll print nothing or I could have it print whole talk questions about this yeah ah so the question is when do I use this if you guys seen this and it this annotation override on your code places I think IntelliJ will courage you to use this yeah so this I I was thinking about was enough to talk about this today and I just don't want to talk about annotations at all but the reason why that exists is that will help check to make sure that you're actually overriding a method right so if you put overrides on something and you're not overriding a method the compiler will say wait hold on you have told me that this is supposed to be this method is supposed to override something but it didn't override it right and so it's a good thing to do to avoid problems like this right whoops look the same me you know like yeah so this is essentially a debugging technique it's not mandatory yeah I mean I'm overriding the method right here and I don't have any of those okay so let's talk about a few more tricks that we can use when we start being able to establish and utilize inheritance relationships between Java class so we talked about constructors we said a class frequently wants to do some setup when it's created and when I'm creating so want me to think about it is when I create let's go back to our previous slide when I create a sweet old dog I'm also creating an old dog and a dog and a pet an animal and an object actually and so it's possible that old dog needs to do some work to set itself up and it's possible that dog needs to do some work to sell itself up and so the question is if I start if I call sweet old dog I'm gonna run the sweet old dog constructor well what if I also want to one run the dog constructor and so this is a place that I use something called super I know it sounds awesome right there's no magic powers unfortunately it doesn't like immediately cause you to get full credit on the MP instead what it does is it calls the parents construe super is only used in the in the constructor and it also has to be the first thing that you do the first thing you do when you're setting up a new instance of an object is call super to set up the parent then the child can do any additional work that the child has to do to finish the job okay so let's see an example of this so here's an example right I've got a pet my pet every pet as a type type would be dog cat ferret rabbit hamster snake lizard lion you know some pets are bad idea but yeah so the type is did is something that's a feet that's a that's a property of the pet then I have you know a subclass of the pet that inherits from it dog now when I create a dog I know what kind of pet this is it's a dog so the first thing the dog constructor does is it Paul's a superclass constructor on the pet class that's what super will do so when I start running my constructor the first thing I'll do is called super that calls this constructor right here it looks for a constructor in the parent it takes a single string argument there is one that constructor sets the type of the pet class that dog is inheriting from then the dog constructor and this is a common pattern this is why super is the first thing that's called so the first thing you do is you allow your parent class to do anything it needs to do to initialize itself and then you do any of the things that you need to do to finish initialize in your class and that typically involves for example initializing certain fields that your class has that your parent doesn't so not every pet has different breeds so dog has added a breed property to its parent so every dog will have a type which will always be dog and a breed which could vary when I create a dog I need to provide a breed so I called the superclass started to create the pet finish grading the pet object and then I set the breed to whatever was passed yeah yeah so the it's a great question so the question was what happens if I'm multiple well okay so what happens if I multiple parents what happens by multiple parents in Java I don't have multiple parents a job yeah so every java class will or can only have one pair right so were you talking about ancestors yeah okay yeah I just want to make sure we were clear about that yeah this is because there are other there are other languages where you can have multiple parents for a class and that creates a lot of problems Java decided to ignore that mess every class is one parent now what about ancestors okay so when I call super I run the constructor of my parent it's possible that my parent will do what my parents constructor the first thing it does might be to call super have its parent set up its parent might the first thing it might do might be Co super so I can run this all the way up at some point there's a class that might not need any setup and so I might not call super alright but that's how things work alright so that's how I would get so and we if I had a minute which I don't think I do we could go back here and you could add constructors to all of these and you could call super and you could see things flowing all the way up yeah so here let's say that sweet old dog the constructor called super that starts running the old dog constructed let's say that call super starts running the dog constructor let's say I call super so it's writing the pipe constructor and then one by one they're gonna finish and finally sweet old dogs gonna finish doing whatever it yeah that make sense yeah good question all right so let's make sure this works this works fine chuji type is and let's print choo-choo dot breed oh I have to make this make this public just for the sake of the example okay good right any questions here all right so now right before we take a break let me try to blow your minds a little bit here this is cool so jamás type system enables us to utilize this feature called polymorphism polymorphism is something that's a funny name there's a funny definition cool tie into theory a lot of practical applications but it's going to take you some time and some practice to get comfortable with it so just be patient with yourself it's ok you know particularly some of you that came in with some background this might be those one of those moments where you know the class actually gets hard for a couple of days just good right I hope you get something out of it along with everybody else right so the definition of polymorphism is this idea that the provision of a single interface to entities of different types polymorphism literally implies that a single Java object can behave like other Java objects depending on the context in which I'm using it right essentially as I sort of hinted at in the beginning of class polymorphism allows me to work with an entire class of Java objects that all share similar features ok so we're gonna talk about three different types of Java polymorphism and we're also going to talk about interfaces in a couple of weeks because interfaces are incredibly cool but for now let me identify two different types of Java polymorphism that we're going to think about and to continue to think about this this is the one this is the one that comes up sort of naturally now once we've been talking about inheritance this is something called subtype polymorphous okay so again poly morphus morph to change poly multiple so this implies again that every java object can actually kind of behave like more than one object and every java object that you work with typically can actually behave like at least two kinds of java objects the first one is whatever class you'd you created so in this case that's a dog right the second one is object there can be more depending on the inheritance relationships that you've created okay so here because dog extends pet I can pass a dog to any function that expects a pet and it will work I can also pass a dog to any function that extend the expected object and it will also work the capabilities that I can use are determined by the type of object that I consider the dog to be even as I'm saying this I'm thinking this is confusing okay it's gonna make more sense in a minute okay but here's the thing to think about so every pet is also an object because it extends object so every pet can either be considered as a pet or it can also be considered as an object because it extends up every dog actually can be treated as three different types of objects it can be treated as a dog that's what we created it as but it can also be treated as a pet it can also pretend to be a pet and it can also pretend or morph into an object because pet extends object so any of my ancestors I can morph into so a dog can essentially sneak into a function that expects an object and behave like an object in that function it never stops being a dog that can essentially disguise itself as an object for the purposes of running that particular function okay so here's how this works okay and here's an example of something that you know is again something that should mystify you a little bit so this code will work okay let's see what's going on here I have my example class I want to draw your attention to the method declared on line 14 it's called print anything it's static void just return anything public the argument it takes and you haven't seen this before but there's nothing can you know particularly special about it it takes a single argument called to print what's the type of that argument big o object the parent of everything in java or the ancestor of everything what it does is it calls the to string method on that variable and prints the result okay so again this is one of those places where you're looking at something that should not make sense to you because we've never seen this before there's a new feature at the language that's emerging in this example because what am I doing here in my main method I'm creating two different types of object I've created this little object hierarchy right here where I have a patent I have a dog that extends pet pet obviously extends object implicitly I created a dog on line 9 I created a pet on line 10 and what's weird about this we have never seen this before that's normal whatever I can create objects I'm good at that I'm comfortable with that but I'm doing something here that I have not seen before what is it what's wrong with this code I mean if I had showed you this and asked you to identify an error on a on a quiz or on a you know we were just talking in class what would you see about this that looks wrong you didn't understand some of these relationships something wrong with this coat something that doesn't make sense yeah yeah so okay so I agree it's a little confusing the print anything that's declared down here but that's actually okay the compilers gonna figure that out but you're on the right track there's something about print anything okay what's wrong with this coat yeah okay well pet doesn't define a two-string method but what what's going to happen if pet doesn't override to string what to string implementation am I gonna get object that's okay again something else here that's it there's something about this that does not make sense someone tell me yeah yeah so one print anything remember when Java looks for a function it looks at the type signature so what's the type of the argument that I'm supposed to pass to print anything what am i passing it on line 11 what kind of object is that that's a dog what am i passing down on line 12 why is this okay so again normally this would not be okay but here's the thing remember what I said just a slide ago every dog can also morph into an object because it extends object through pet every pet can also morph into an object because it extends dog sorry it extends object directly sorry but again this is this is weird okay and here's what's happening this is something that's called an upcoming two ancestors and it'll do this for you automatically you don't have to do anything special here so when I call print anything while print anything is running my dog has become an object that sounds terrible right dogs are not objects my cat my pet has become an object all right so again this will work you can run the code they'll do exactly what we've been doing throughout class but every as that code runs so here's the other thing that's weird okay so there's we we pointed out the one weird thing which is that somehow I can pass a dog to a function that expects an object somehow I can pass a pet to a function that extends an object that's sorry a little bit of head-scratcher but when this function runs it's clear that those objects still know what kind of object they are right because when I call to string on my dog object here on line 11 I get the two string method defined by dog I don't get the one defined by object when I call to string on the pet that didn't override to string I got the default object of limitation but it's clear that Java has not forgotten what kind of objects these actually are right right and I can do this like this as well come on oK we've talked about this next all right down casting I'm gonna leave for for next time when we come back and review polymorphism and actually I think instance of I should I should leave as well this I will come back and review next time let me just finish by connecting this quickly to a really nice piece of computer science theory this is not something we get to do very often but if I was really exciting when it actually happens so there's something called the list cough substitutability principle list a substitution principle so substitutability is an idea in computer science that says that if there's some desirable property if s is a subtype of T then any object of T can be replaced by s without violating without you know altering any of the desirable properties of T okay it's actually a really deep principle in computer programming languages whose the list off in list off Barbara Liskov Turing Award winner professor at MIT someone who did incredibly important someone to work on programming languages this principle was named after him what's the Turing award has anyone heard of the Turing award before ok well now you all have this is the Nobel Prize for computer science there is no Nobel Prize for computer science instead we have our own award named after Alan Turing one of the people who did incredibly important seminal work on computer science very early on there's an award given every year and this is something you should know right so you should know who won the Turing award last year the year before these are people to look at their people whose work you should review and try to appreciate some of it won't make sense to you a lot of it will actually because a lot of people that win this award have done things that affect the world of technology that you experience every day ok so I'll come back and do this next time because I've been a little a little slower than I thought today which is fine ok I have two quick announcements as you guys who are getting up ok this one's important I feel after some discussions of the core staff I feel like it's important to remind you about cheating policies in this class ok everything you submit for the MP is going to be automatically checked against everything else everybody else submitted ok we expect you to struggle in this class know some of you are frustrated this point of semester I get that that's ok frustration goes along with the work but you can't let that push you to the point where you're willing to do something wrong this is so we have a full cheating policy up on the website let me make this very easy for you ok here's the simple rule if you are talking in a human language about the problem you are fine I don't want to discourage you from sitting down in office hours and chatting about how you're solving the problem of the people that's ok you know oh I had to do this and they did this other thing ok fine once you start exchanging source code in any way if you sing it to somebody if you write it down as a poem and hand it to them on a piece of paper right if you send it in a snapchat message or on a group chat or over smoke signals or whatever it is that is wrong and we will catch you right so please keep this in mind as you work on mp1 again I don't want this have a chilling effect I want you guys to help each other collaborate but once we start seeing you know people sending little bits of source code around that that was passed what we're willing to accept all right enjoy we'll talk about frustration on Monday enjoy the weekend good luck finish up mp1 I will see you on Monday no class on Friday  
﻿ [Music] right back everyone okay so so today we're going to continue our discussion of Optimus we've introduced polymorphism over the last couple of classes and this is a concept that can be difficult to understand and it's also difficult to kind of work with in practice so what I thought I would do today is actually take a little bit of material out of sequence what we're gonna try this is something that we would normally would have talked about on Friday but I'm gonna try talking about it today and then on Friday what we're gonna do is we're gonna come back and we're gonna talk more about polymorphism with this new concept in our vocabulary because I think my hypothesis is this will actually help you understand how polymorphism works this is also something that's incredibly important to understand about how objects actually work in Java it's also a really powerful concept in computer science that you see used all over the place and this is the notion of a reference and again what we're gonna do so so that's kind of my plan for the next couple classes so today we're going to talk about object references and then know'm and a little bit related able see right this is another one of these object oriented concepts so for the next couple of weeks the conceptual you know challenges in the class are going to you know increase as we continue to talk about these different ways of working with objects and for some of you particularly people haven't seen object-oriented programming before I understand this is tough stuff in fact some of you that have seen object-oriented programming before haven't seen some of the things that we're gonna talk about or if you've seen them you haven't seen them explain very well and so they didn't make necessarily make sense at the time so today we're gonna do references which are incredibly cool they've been in front of us this whole time but we haven't really grappled with what they mean and the implications they have for programming using objects in Java and then at Friday we'll go back and we'll talk again more of polymorphous and we'll do some more examples and again I think once we talk about references polymorphism may make a little bit more sense it's the idea here and this is something I'll repeat on Friday I mean I'm not gonna come back to today is that when I have a particular type of Java object what I can actually do is I can get references to it of different types so we talked about how an object morphs into other kinds of objects and that doesn't make any sense like morphine is a is a Weezer word that I'm using to hide the truth from you but what really happens or what you can really do in job is once you have a particular type of object you're allowed to use reference variables to refer to that object of its type and any other super types so any of its you know ancestor classes so any object in java i can refer to with an object reference ok so again i need to tell you what references are that's the subject to today's class but let's start again is we have a couple times recently with a motivating example a place where something isn't working the way that we think it should so what have I done here so I've set up a class called person this is pretty common instead of writing centers or getters for name I just made it public you know you should really write setters and getters for it but I decided not to just to keep it you know a little shorter but I've got a two string method that prints the name so I overrode two string remember that's something I would have normally inherit it from my parent class was just object because they didn't explicitly extend the class now down here in my example code I'm doing two things so let's look at the top block of code first let's walk through this but this actually behaves pretty much how we would expect so I create two variables these are primitive types these variables store Java primitive types they're lowercase the two intz we got comfortable and familiar working with these in the first third of the class okay and here's what I'm doing and maybe this seems very dull but just bear with me for a minute now I create an int variable called first I set it to 0 I created an invariable called second eye and I miss that to the value of first and then I changed the value of second to eighth okay and when I print off these two variables what do I expect well first is zero never it never changed the value of first I've initialized second to be zero which was the value first and then I sent second to be eight so what I expect here is that first hold zero and second hold tape okay so that's our hypothesis about what's going to happen there let's try to apply the same logic to Java objects okay so down here on line 19 I create a new person object I initialized it with the name required by the one constructor I provided line 20 I'm doing something that again is a very analogous to line 14 so I set this example up intentionally with a lot of parallel structure between these two examples to try to trick you essentially so that we can see something that's not behaving the way that we expect which is gonna launch us into a new observation and a new understanding about how Java actually works again a very very powerful idea so I set up my new person variable called me I initialize it using the new keyword great okay so that looks a lot like line 13 line 20 looks a lot like line 14 I create a new person variable called you and I initialize that now here again I'm making this look a lot like the top so I initialized second using the value of first and initializing you using the value of me so far so good on line 21 I set you dot name to be student okay so I've changed something I've changed something very analogous to the way that I did here I set the value of second aitt here I've set the value of U dot name this public string field again I should have really made private and written setters and getters for it but I didn't because I'm lazy and so I changed it to student now if I follow the example from up top what do I expect to happen on line 22 well I've overridden 2 string which is why I can print these objects out directly but I can't do that with any Java object I'll just get the default object to string which isn't very good nice to look at so I've got me and I've got you when I created me the name was Jeff I set u equal to me and then I changed your name to student so what I expect to happen here well I think this is gonna print me my name is Jeff and then you your name is student okay just like it would at the first example so let's run this and see what happens okay huh this is weird so something again this is another one those places where something happened that we didn't expect something happened that is violating our intuition or the intuition that we might have developed as we worked with Javas primitive types okay so something weird is going on here it seems like let's try this again let's try changing U dot name to whatever okay huh so it seems like what's happening is somehow this change that I'm making on line 21 it's not just affecting you you dot name it's also somehow affecting me the me person variable in fact let's just print off me dot name here just to be really explicit about this the same thing okay so something something's up something is different let's try to figure out you know again this is a glitch in the matrix let's try to figure out what's going on we introduce you to the idea of a reference and again references are super powerful you see them all over the place in computer science a lot of what you use on a day to day basis a lot of the names they used for things website names handles on discourse whatever these are references ok so what is a reference a reverence is a value that allows the program to indirectly refer to something right to a particular datum this is very you know grammatically correct Wikipedia definition so two variables value or record in the computer's memory or some of the storage device right the reference is said to refer to the data in this case our dadums are objects ok so the reference refers to the object and accessing the object requires dereferencing the reference or sometimes following is the term that I'll use following a reference okay so all the variables that we've been using we've been we haven't really been precise about what's been happening when we've been working with objects in Java we've been doing things like you know line 14 where I've created a so what's actually happening here let's walk through this and use some of our new syntax to talk about what's going on so on line 6 what's actually happening is I'm creating a variable called me that's going to store a reference to a Java object now that variable can store a reference to a person and on Friday we'll see it can also store a reference to anything that inherits from person ok down here I'm doing the same thing on line 12 except I'm actually providing an initializer on the right side which I can do now we can also come back and talk a little bit more about what null is we wonder what is this null value so no is an empty reference it's the lack of a reference it's used to set a reference variable to refer to nothing right and this is why trying to access a reference variable that's no cost as a problem because when you use dot notation what you're doing is you're following a reference if you try to follow a reference that goes nowhere you end up in the land of pain and nullpointerexception these are actually the same thing if I create a reference variable in Java and I don't initialize it the value is no but I can also initialize it explicitly do not when I create so again we've been using this syntax you guys have been getting comfortable with it on the homework problems but starting today we want to be more precise about what's happening on line 14 what's happening on the right side I'm creating a new person so my constructor is gonna run and a new object it's going to be created what actually gets returned from that is a reference to that person object which I then save in a variable in the variable me and again the compiler will check this for me it will say can me store a variable of type person the answer is yes because I initialized me to store person references so I'm good okay now so I have two reference variables here so here's the here's the critical piece and we're gonna go through a diagram and stuff like that don't panic this is gonna make a lot of sense it actually it does make a lot of sense what happens on line 15 is the critical piece of this puzzle it's going to allow us to explain what happened on the previous playground fly this assignment in Java when you have objects does not create a new object so one of the things I'm going to remind you later in class it's a good you know little tip for dealing with this system is to remember that objects in Java are only created if you see new so when we get to line 15 how many objects have been created by this piece of code what I see new on line 14 I have two references I have two reference variables excuse me I have two reference variables I have one called me and I have another called you both of those can store a reference to a person object on line 14 I both created a person object and I saved its reference in the variable me line 15 does not create a new object what it does do is it copies the reference from me to the variable of you so now I have two references to the same object there's only one object in this system again there's no new objects unless you see new I've only called new once or I've only used the new keyword once I'm only call the constructor once at this point these two reference variables store the same value and that's why so if you actually remember one of the things we told you you know again this is one of those things that didn't make a lot of sense at the time and now I was going to make more sense don't compare Java objects using double equals if you have two variables that store Java objects don't compare them using double equals well hopefully this will make more sense now because when you use double equals on a reference variable what you're actually comparing are the references not the objects themselves now here on line 16 U is actually equal to me these two references refer to the same underlying object okay but I can change that so now on line 17 I'm creating a second object and I'm going to reassign my variable U that can store a reference to a person object I'm gonna reassign that to refer to this new person so now I've got two person objects and I've got two reference variables and at this point me refers to the first person object that was created on line 14 u refers to the second person object that was created on line 17 so now when I compare these reference variables using the double equals comparison operator in Java that's going to print false all right they're no longer the same reference okay so let's go through this okay so note again as as promised this works so let me go back and let's go through this example again and try to understand what's going on again I've got diagrams coming up that this is you know references you hear them does anyone know any other names for references they might have heard in other languages there's sort of like pointers in C++ and C they're not quite the same thing but you can think of them as pretty similar Python has references JavaScript I've suffered this pretty much every language you know every modern language has this idea and many of them work very very similarly okay so what so let's go through the bottom half and figure out what happened hey I created one person object with the name Jeff on line 19 then on line 20 I initialized a second reference variable called you that stores a reference of type person and I copied the reference from me into you so at this point me and you refer to the same object and so if I change meas name both me and you are going to see that change if I say if I change used both me and you are going to see that change I have two references to one object hey how can I make this work differently what so let's say I create a second person now I've got two person objects I have two different references to them so if I change u dot name I'm changing the object that I created on line 20 only that object I'm not creating the object that I I'm not changing the object that I created on line 19 but when I copy the references I only have one object and I change both questions about this before we go on and again let me let me do the reference equality thing too so you guys can see that so down here I'll print U is equal to me that's true they refer to the same object I change u to be another person they know questions about this again I suspect that this is this is gonna be tough to work with for a little bit yeah so the question is well that's okay well let's do this example let's just set you and me back to each other so but here's the question so the question was if I do this is there a way to change another object it was out your question there's no other object here right there's only one yeah there's only one person okay now here's what could happen let's try this and I'm not gonna fully explain this yet okay so let me let me do this so now what's happening now on line 19 I create a person reference variable on the Left called me and I initialize that to refer to a new person object that has the name Jeff on line 20 I create a variable called you that stores a reference to a person and I initialize it to store reference to a new person object that has the name you now at this point how many objects do I have - I see new here I see new here now I set u equal to me okay I can do this this work and now let's see what happens so that's gonna work fine what up okay so so here here's the problem what happens if I want that other person back that person on line 20 that I created with the name you what happened in them how can i I want to change their name how do I do that let's see here if I start right here yeah someone had an idea - the person you yeah so and we're gonna we're gonna use if we're gonna use some analogies about references in a minute so keep that in mind when we come back to that right but if you don't have a reference to a Java object anymore if you overwrite the reference so after line 20 executed you had a reference to this new person that I created with the name you but then on line 21 i over wrote that reference with the copy of the reference that i created to the person that was created with the name jump so there's no reference to the person with the name you anymore and if you don't have a reference to a java object it might as well not exist and in fact and we may talk about this you know at some point in the future when we want to you know understand java a little better if you don't have a reference to a java object it will actually stop existing at some point java is smart enough to realize once you get to line 22 that person that you created with the name you is no longer needed you can never refer to it how could you do anything to it how could you change its name how could you print it how could you do anything do you don't have a reference to it so it'll go away job will actually take care of that for you automatically all right so let's let's let's go through some this is gonna help a lot actually because references are one of the places where we actually have some good real-world analogs so let me give you an example a phone number so remember references are not the thing they refer to references allow you to refer to something but they're not the thing that they refer to so here's an example a phone number refers to a phone so I've got a phone over there I have a number I could write that number down and give it to you and then you have a reference to my phone which you can use to call it now again the phone number is not the phone if I create 10 more references if I write my phone number down 10 more times they give it to people here I don't have 10 phones that would be pretty cool actually if I could do that but I don't solve one phone the phone number is a reference the phone is the thing that's referred to so by giving you my number you can call the phone now imagine there's a phone in the world that nobody knows the number two does that phone really exist or not you are now in philosophy 101 it's a deep existential question here right does the phone exist right it's like when you lose something right does it stop existing who knows probably not so a phone number without a phone without a phone number isn't very useful right you know and at some point if somebody if literally nobody had a number to it then it's not gonna be very good at receiving calls now you guys do other things with your phones now so you might find that phone really useful actually but the point is that without a number not anyone being able to refer to it from the purposes of a bina phone I'm able to receive calls it might as well not exist so the other thing about references that makes them powerful is that you can control how that reference is used so let's continue with our phone example let's say I stopped paying my phone bill alright what's the phone company going to do to the number so the phone number is the one that controls how that dereferencing process occurs so when you guys call a phone number when you pick out your phone dial the number in there's this complicated process that goes on where the phone company looks up that number in their database and tries to figure out where the phone is and it has another identifier forward and then eventually this happens within a fraction of a second and my phone starts ringing but let's say I stopped paying my phone bill what could the phone company do couple months go by you know they've called me they sent me a bunch of angry emails at some point what are they going to do you're gonna call the number on what's gonna happen it's not going to work anymore the phone company controls the reference they controlled the process of dereferencing the number so if I stop paying my bill they're gonna say well we're gonna stop that number is not going to work anymore when someone calls it your phone's not going to ring instead what's going to happen is they're gonna get a message being like this number is no longer in service or whatever so here's an example of a reference another good one a street address right I this is similar to a phone right so if and and let's talk but let's also talk about how references work when we change things right so we'll go back to the example that we let off class with okay let's say and you guys might like this example let's say that for some reason I'm in some sort of fugue state and I give you a couple of you guys my home address not planning on doing this but let's say that one of you goes by and throws eggs at my house okay so my house now has eggs on it the next person who comes by what are they gonna see on my house eggs I only have one house if I make 10 references to it but one of you uses that reference to make a change to my house then those changes are visible by everybody who has the reference so again let's go back and look at that playground example quickly right so here let's do let's go back to the original version of this at this point I've got two Java references that both have I have two references to the same Java object either person who holds either reference can make a change that is visible to both holders of the reference so I can use you to change the name I can use me to change the name it doesn't matter I were either one of them will work because they both so again if the first frustrated student eggs my house it's got egg on right if the second frustrated student eggs my house still got egg on right doesn't matter which which reference gets used okay all right I think I have another one here ah yeah so like yeah there's all sorts of things that refer to you as a person we've tried to set up all of these reference systems social security numbers on campus you have an ID a university ID number that's a reference I can make lots of copies at that number I'm not making copies of you that reference refers to you it's controlled by the University so at some point you know the university may say ok well it's a person it's a student here anymore and I'm gonna take that University ID and I'm going to destroy it or I'm gonna give it to somebody else they probably don't do that they're probably keep that around from all right questions about this now that we have some physical analogue all right oh sorry ah good okay good question so the question is how do I copy an object in Java so let's say I actually want a copy of the object not just a copy of the reference all right so first of all let me just let's just review and reinforce the fact that copying an object copying a reference does not copy the object so again if I give one person to copy my phone number and you make ten copies of it I only have one phone it could be one copy of my street address and you make ten copies of it I only have one house you're copying a reference you're not copying the underlying object right okay just said these things so and you know again here's the example so I made a copy of the reference on line six but I still only have one person option right so let's actually walk through what's happening I promise some diagrams okay so let's actually walk through a kind of a visual depiction of what's going on all right me is a variable that stores a reference I'm gonna depict that with a arrow coming out of me pointing at the object that refers to right now when I've created me initially it's empty it does not store a reference what value do we use to refer to this in Java no okay and I should have I'll come back and reiterate this on Friday with the slide when you use dot notation what you're actually doing is following a reference so that's why if you take null and try to call to string on it you get a null pointer exception so right now here my person my person reference is null so let's try to call so they call to string on that guy and you're gonna see that oh it's it's mad at me okay let's initialize it to no because this will fool the compiler which is kind of dumb actually so yeah so here we go now we have our null pointer exception okay great so at this point I can't do anything but person it's empty once I set it to refer to a new person object so the new keyword is what created this object over here on the right so this is my visual depiction of an object I don't want you guys to get too addicted to these kind of diagrams there's some you know horses that largely rely on these type of visual aids to help you understand this stuff and here's the problem you have to develop your own internal mental models for figuring this out you know particularly for sort of doing some of these basic things when you go to you know a software development company or you go to some places doing really cutting-edge computer science you don't see this type of diagram all over the place because people have internalized this at the point that they can work with it without having to draw a lot of pictures that takes practice you guys will get it but here's one a place where I'm going to draw a picture okay so now my person my reference variable me has a reference it refers to this new person that I just created and the age is zero because that's the default initial value for an int all right so I created a new person I've got no constructor for this class and so in to set to zero by default remember that's you can look up those defaults in the Java documentation all right now okay so now things have gotten more complicated and this is an important picture to understand now I've created a second reference variable called you that also refers to the same object so both of these reference variables are set up to store a reference to a person me I an i sat to the reference that was returned when I created that person object and now I've copied the reference from me into you so what really matters here is the end point of this reference so these two you know it you know they're different places on the slide but they can't they store the same reference and so now if I change oh my diagram break Oh didn't like this okay this is hold on a sec let me just let me do something quickly because we need we need this diagram okay yeah I made the mistake of trying to change this right before class which was dumb so let me okay so these are from last these are from last last semester but it's the same a same example the the number is all different okay all right so I have the second reference now if I change age so here's what i'm doing i'm using my me reference to set the age of this person but there's only one person in the system okay so hopefully it's a little more clear from this that both me and you are going to see that change both me and you can make that change I could have used you here instead used you to set the age I used me okay now if and both me and you will see the change so both me and you can set the age of this one person object that I have in the system that I created online for and both that change will be visible to both me and you okay so again this this works as expected questions about this right so this is this is the you know the thing to start keeping in mind when we start working with references there's this separation the variable doesn't store the object the variable stores a reference to the object it allows you to make changes to you know call methods to change public instance variables but those changes are visible to anyone else who has a reference to the same object all right questions before we go on what's that ah let me come back and answer that a minute yeah so the question was when like why would I do this why would I need two references to the object yeah I'll come I'll come back that minute all right actually you know what let me see here I'm gonna go back to my other slides okay good all right I'll come back and do this one at the end ah so here's here's one of the reasons why so when I call a function or a method in Java and that method has a parameter or an argument that's a that's an object what I'm actually passing to that method is an object reference and in fact I'm passing a copy of the reference that I use to call the method right so here's an example on line 11 I've created a person with initial age of 39 and then I call this function called birthday that function takes a person as an argument and it increments the person's age and returns their new age so this code is going to operate on the person object that was created on line 11 again how many times do we see new in this code once there is only one person object that's being created as part of this example so on line 11 we're sorry it when I on line 12 when I call birthday what happens is birthdays initial argument to set is set to a copy of the reference variable meat that's passed as an argument what that means is that the function can change the object that you pass in so in this case it's modifying that person's age so here's an example so essentially while birthday is running I have two references to the same person object one that's being used by the birthday function and the second one that's being held by the caller of the function so this is one place where you would essentially have two references in same it's a good question and again this allows functions in Java to modify the objects that they are past right so if you make changes to an object inside a function those changes are visible to the caller of the function and again this should work better than they do let me go back to other slides there we go yeah so here's the diagram version of this I create a person with age 38 I call birthday when birthday is running the code the called birthday still has a reference to that person called me but birthday also has a reference to a call to set they refer to the same person so when birthday makes a change to the person that change is now visible to the caller once the method yeah so this is one place where I would do this a good question all right let me let me bring up one more thing I'm gonna get into the end here so when I create an array of Java objects what's actually in that array just like variables in Java store a reference to an object not an object itself arrays of objects store references to those objects not the objects themselves so this is in a playground that we're about to to mess with but let me just go through what's happening here so I have now now here's where things get a little tricky so I see new here but what's actually being created here so this is is this a person it's an array of references to person objects so I've created an array called people that will be able to store for references to person objects what do you think the default initial value inside that array is no they're empty Java does not create those objects for you that's your responsibility which we're gonna about to do right here okay so now on line 11 again this is one of those examples that I would you know ponder after class asked about on the forum if you can understand how this works then you understand how references work and job on line 11 I'm creating a second array of that's going to store references to person objects that second array is called same people and it's going to store also store for references to person objects now what I did in this loop from 8 to 10 now I'm calling new so you see me call new and I'm creating persons with ages starting at 0 starting at 18 SR 18 19 20 21 the loop runs 4 times so after when I get to line 11 my array people now is full references to actual java person objects that i created inside the loop now what I do inside this loop is different do you see new no I'm not creating person objects instead what I'm doing is I'm copying the references from people into same people so you know like when I get to do the fun thing with my fingers that's not a very good diagram you know you imagine I have an array right that array was filled with references to person objects I now have a second array that has references to those same objects so I have two arrays that together are storing eight references to Java person objects but I've only created for Java person objects so every Java every person that I created was initially stored in one place in the people array and then I made a copy of it in the same people array so now I've got two copies of that reference now I'm going to go through my first array and increase everybody's age and then I'm going to go through my second array and print everybody's age so what you're gonna see what this is going to show you is that people insane people actually have references to the same objects okay so let's let's do this let's take this out and see what happens so now I'm removing my modification if I removed the modification that was done between lines 18 and 20 you'll still see that same people stores the references to the people objects that I initially saved in the people array so down here I can go through either same people or people so if I go through people this works identically reason is that both arrays store references to the same objects likewise I can make the modifications to either same people or two people these two arrays store references to the same option so now if I do this you'll see that everybody's age is increased by 10 the years fly by questions about this example again we're gonna toss this out right at the end of class give you something to chew on a little bit but if you can if you can work you know in a part of working with Java's objects and part of actually becoming a great computer scientist is learning how to internalize some of these systems so that you can think about them effective no draw some pictures when you're getting started but start to work on building your own mental models about how this stuff works all right as a reminder there's a little cheat sheet here oh wait sorry object copy yeah so someone so that's actually a great place to finish because someone had asked how do I copy Java objects the answer is there is no built-in way to do this in Java so you might think that seems really obvious like I have an object and actually one another object that has the same content as the first object why is it there a nice way to do this in Java and it turns out that the reason is that sometimes objects have state that they don't want to be copied to another object okay but if you want to actually copy Java objects you have some options so object provides this thing called clone that doesn't actually do what you think it does so that's actually not enough one good option is to implement something called a copy constructor so between line 6 and 8 I'm showing an example of a copy constructor for my person class how does this work what it does is it takes another person takes a reference to another person object it's a constructor you see that it starts a capital person same name as the class doesn't have a return type this is a constructor but as a constructor that takes as its argument a reference to another object of the same type and then in here you can copy over anything that you want from the other class so in this case my person when I use the copy constructor will return a person that has the same age let me go back oh let's just do this here quickly so here's my second person object let's do that and now we'll go back and we'll say so now we actually have a way to copy person object so so now I have a constructor for person that will take a person reference right but I do have two different persons here let's make sure that that's the true so I'm going to set the age of the second person object to 18 and you'll see that it's not reflected right sorry it is reflected there sorry I've got a print the first one so we make sure that we don't have a reference right so if this was a reference then the age of the first instance would change it's not it's a it's its own object because I provided its copy constructor up here now the nice thing about a copy constructor is you control what gets copied this is code that you write if you want to leave off some fields if you have a field that you say you know what that that shouldn't be copied when I copy an object you can do that alright so this is the option that gives you the most control and this is the thing that's the most common you can actually this is one of those things you can actually get IntelliJ to generate for you it's boilerplate code it's not super exciting but I think there's a you know an option with IntelliJ that says you know generate method and you can have it generate this copy constructor for okay so again let me just summarize what we talked about today in a couple of couple of points unless you see new there's no new object that's been creating objects are only created in Java when you see the new keyword only period there are no exceptions of this you can hide it inside a function or whatever but you can put it inside a loop but I only create a Java object when I use new and the type that comes after new it's the actual type of the Java object which become more important once we go back onto polymorphism on Friday the variables that store objects in Java all of them actually store references to objects so when you copy one to another they're copying the references you're not copying the objects themselves okay all right so oh I need to I need to throw this out there very quickly because you need it for today's homework problem this is one of the last little bits of Java keyword bingo that we're doing this semester so final is another modifier that I can add to a class if I add final to a class it means that that class cannot be extended so if I make a class final then nobody can extend that class okay this is just a little bit of esoterica that you need for today's homework problem all right I have an important announcement as you guys are getting up so after talking to the CAA captains we've decided to move our Wednesday night office hours to Friday so there will be no office hours today after 5:00 there will be office hours starting this week on Fridays from 5 to 8 p.m. ok so hopefully that is agreeable you know they feel like that's gonna do a better job of meeting need I have office hours today 1 2 3 enjoy the beautiful day I will see you guys on Friday we still have office hours from 12:00 to 5:00 just not from 5:00 to 8:00  
﻿ hi everyone this is Jeff Channel so today in class we're gonna have a special guest visiting us and I wanted to help keep us on track this week so that you guys continue the homework problems and that means that I decided to record the screencast so that we can look at interfaces and specifically our vases are fermented in Java a little bit of this is review from Monday which so you're welcome to skip ahead unfortunately that lecture the mic didn't seem to work so I don't have any video to post of it so I'm gonna pick up kind of about ten minutes where we left off at the end of lecture when I introduced interfaces as a concept and then we're going to introduce the idea of working with interfaces in Java and what an interface means in the java programming language so the concept of an interface is something that we talked about in CS 125 because it is so important and it really does pervade computer science and computer systems we see interfaces all over the place an interface as the name implies is really a place in a computer system or a computer program where two things come together it's the boundary between two things that boundary can be between many different parts of a computer system so for example you'd have interfaces between two pieces of software between the library that you're using and some other piece of code you can have interfaces between software and hardware when you plug a new device into your computer this thing said that you sometimes have to install called a device driver is essentially the software that runs on your computer that understands how to talk to the hardware that you've connected and it does that using an interface that's provided between your machine and this new widget that you've decided to hook up if you have interfaces between computers and their users so these are sometimes on this computer you know computer human-computer interfaces things like a keyboard that's an input device that's an interface it's a place where you know literally in this case you and your computer come into contact with each other you're touching the computer a screen is also an example of an interface again a place where there's a boundary and data is being exchanged of the pixels that are rendered by the computer are entering the eyeballs so it's a boundary between you and the machine and then we again you know various permutations of these different components between humans and Hardware between you know software and hardware and things like that so the interfaces are you know something that again it's a general concept really does pervade the design of computer systems and computer applications in a way that's incredibly powerful and you know one of the things that's so important about interfaces is that because they are a place where two things come together and connect and touch and interact that's a place where we need to be very specific and very careful about how we design communication between these two components so if you think about software libraries a well-designed software library has an interface that's easy for other people to use and makes them you know eager and happy to integrate it into their own project but in the best case you know when you use a software library you guys are doing that on this empty check point using the the GCL library by Google there's all sorts of code that Google wrote somebody at Google wrote that you don't need to understand that code works to implement the interface that Google provides but all you need to do is read the documentation so you understand when I call a particular method that's part of this package or a part of this library how does it work what does it do for me how does it interact with the rest of my program so I'll define interface you know allows two different parts of the system to really define what they need to know about each other what does my part of the system need to know about your part of the system what does your part of the system need to know about my part of the system and once we agree on that and we agree about how the communication and the interaction across that interface is going to work then a lot of what happens in each part of the system is completely hidden from the and that's a good thing right this is what allows big software development projects to work so you have things like Microsoft Windows or Chrome or you know all the code that powers Amazon's various services these are huge projects that are worked on by tens of thousands of people and one of the main ways this happens is by coming to decisions about where different parts of the system touch and interact the interfaces and then how those interfaces are going to work and then the teams can go out and work independently from each other and things will still fit together and work once they're integrated in the end so this is an incredibly important idea so let me give you just quickly some examples again to kind of set the stage so there is there are all sorts of examples of software interfaces that separate two pieces of software sometimes those interfaces are really explicit like when you use a library that has an API an application programmer interface that's an interface that's designed for you the application programmer to use and those interfaces are usually well documented there's a lot of you know Java doc that surrounds those interfaces so that you can figure out how to use it without doing too much work but an interface can also be more implicit so for example the test cases that we write for each MP checkpoint or for the homework problems establish an interface between your code and our test suite and again that interface involves agreement if you decide to call your function something different our test Suites not going to work because part of the interface between our test suite and your code is that you're going to write a function with a specific name that takes a specific set of arguments if you violate that interface then the test code won't be able to work so that's an example of an interface that's less implicit and sorry less explicit and more implicit you know again there's lots of software hardware interfaces and these are kind of fun fun places where think cool things happen right so you know when I teach class and there's a chromecast that has been stuck in and there's actually a bunch of different interface that are going down there's the interface between the chromecast and the projector there's an interface that's a that's a hardware hardware interface there's a there's software that runs on chromecast that helps manage that and then when I plug in the chromecast and connect to it over my laptop now there's an interface that's established between my laptop and the chromecast data is being sent actually over Wi-Fi and there's software that runs on both my laptop and the chromecast that makes that possible so again a lot of these sort of fun you know new software catches that hardware catches that we all we use are really examples of creating interesting interfaces between things that normally wouldn't have them so normally I wouldn't be able to project my screen directly to the projector because my screen has one in her face and the projector needs something that that's a different interface but the chromecast allows those two things to be brought together and then you know I mentioned there's a lots of different computer user interfaces pretty much every way that you interact with your computer whether it's a touchscreen that will a keyboard that pops up or using a phone other peripherals these are examples of computer user interfaces or human-computer interfaces and this is a really interesting you know area of study and and increased development right I mean thinking about how to make these interfaces better thinking about what they'll look like in the future we've had keyboards around for a long time and there's been a there's been a lot of points where people said oh people are going to stop using keyboards and everybody's gonna be talking to their computer or gesturing or the computer will just read your mind or whatever and I think you know we will see some of those things in the future even if computer keyboards have turned out to be remarkably resilient as an input device okay so now we're going to focus in this class specifically on software interfaces and of course specifically an interface used in the context of the java programming language that we're using but i just want to make it very clear that interfaces are not an idea that's tied to java we're really not an idea that's not to any specific language you do have certain computer languages one example is java another example let's go another example there's something there's a bunch of them right that actually include a specific notion of it faces this part of the language specification so in these computer languages an interface means something specific so we'll see in Java exactly what an interface means interface is actually a keyword in the language like class like extends right it's something that means something very specific but even in languages that don't have a specific notion of an interface like Python or JavaScript interface it still exists right any place where two pieces of software come together and have to interact communicate is an interface it's an interface if you declare it like an interface in Java or it's an interface if you don't and you're using a language that doesn't have that specific idea of what integral is interfaces are something that every language has some languages choose to formalize that others don't but interfaces exist in every programming language that you will ever use perfect so one final note about about this is that you know even we're gonna see the few slides exactly what an interface means in Java but even every Java class that you can possibly use a class that's public again is visible to you as a programmer has an interface that interface even if it doesn't implement a just specific Java interface and the interface to a java class is essentially the set of methods that it provides that you can use so the set of public methods that a class provides so you know let's see your own block of Java blank string and pull up the documentation for that here and it's latest documentation ok so Java 10 so again I mean java.lang string does not implement an interface but this right here is essentially the interface to a string it consists of all these different functions that we can call and again I've mentioned before that interface is a place well I'm actually about to say that right so an interface is a place where we need really really good documentation because part of the value behind an interface is that you can it allows you to use something without understanding how it works but that means that someone has to write down what it does and how to use it right so for example with the trim the trim and method right here returns a string whose value is this string with lending leading and trailing whitespace removed it tells me how to call it doesn't take any arguments and it tells me what it returns which is a new store so this is interface that essentially interface documentation it's in English or in another human language now again I don't there's no code here for trim there's no code here for to lowercase all there is is the description of what it does this is what we need at the interface now there is code in the string class that implements to lowercase but with a well designed interface I never have to read that code I never have to know that it exists I don't need to know how it works all I need to do is read the documentation here and if I need to convert string to lowercase I see that there's a method to help you do that okay so this is what Java Docs for basically I bet doc does the interface documentation all right so let's look at our first example of an interface in Java so this is like I said Java has an interface keyboard and if you look at this little snippet of code the thing that it probably reminds you of is a class declaration so we talked before about how classes allowed us to open up Java's type system and create new types new types of java objects that have that makes different types of State and behavior and an interface on some level starts you know the beginning part of it looks sort of similar right so I've got public interface and instead of class here I've got interface I have something that looks like a class name we follow the same conventions for interface names that we do for class names they're capitalized okay and then I've got an open block and and now okay so what does this kind of look like right so this sort of looks like the beginnings of a method declaration right I've got a return type and I've got a name if the method add I've got a list of parameters I've got the first parameter int it's named first the second parameter is it and it's named second but then no I've got a cold sorry a semi right there's no body of this method right so many ways Java interfaces look like objects without any contents just method signatures with no implementation so interface this interface you know what does it tell you so it's got a name called an ad and then it's saying essentially that a function exists called ad and I can learn things about that function from looking at you know the interface declaration so I know that there's a function call and it takes two arguments first and second and returns in the end that's all I know there's no code so clearly the interface doesn't by itself do anything because there's no code here to implement ad but it is sort of providing some information about you know something right now interfaces can declare both methods and variables we're gonna focus on methods in this class interface variables are essentially only useful for declaring constants any variable that you associate with that interface has to essentially be public static final and so they don't hold you know it's not I don't think it's useful to think about interfaces declaring variables in a way that's at all analogous to how an object class declares variables they're really just useful for the pointer console alright so so clearly by itself this interface is providing information but you know clearly not doing anything there's no code here to run it's just a declaration of a function so in order for the reason that we declare interfaces is because classes can then implement yeah so once I have a declared interface I can declare that another class implements that interface so here's my ad interface on line one to close a function called ad and it says you know this function takes two arguments and returns an int now I have a class called adder so this is now looking more familiar to us the first part of this public class adders I'm declaring a new type and I say implements act so again this is a little similar to extend right we saw extends before that meant that I was extending another class that I was going to inherit its there to behavior and potentially ads on my own things when you implement an interface in Java what you commit to doing is you you use this implements keyword and then you have to implement all of the methods that the interface the clickers so this interface declares one method it declares a nothing called add that takes two arguments in order to implement add my adder class has to actually provide an implementation for ADD so that kind of makes sense the implements keyword makes sense so such it what I'm saying is I'm gonna take this interface and actually make it work right so you told me there was a function called add to take two arguments I'm actually going to define how ad works I'm going to implement AB and so my class is providing an implementation of that function in public and AD takes two arguments and then returns the two of them some together which is what we would expect that to do right alright so again interfaces don't declare they don't do anything useful by themselves they essentially kind of provide the declaration about what a certain capability that's right so our class can add tags right and then to declare that you want an interface use this implements key all right so let's play with this a little bit so let's look at this code again this is just you know pretty much what we've been looking at loaded into the playground so I've got a public interface ad it's declaring one method called add that takes two arguments and then I have this public class called a blur okay now here what I'm doing is actually let's do this that's just have this being a door reference for now so let's say at ad is equal to new matters I'm creating a new matter and then I'm gonna try calling this add function now if I run this you know clearly right now I haven't implemented ADD and so this is not going pop so now let's declare that my outer class is going to implement the ad interface now if I run this I need I get a different error because now I've told the compiler hey I plan on implementing that interface you know I see what I need to do to implement this and I plan on doing it and now the compiler is telling me hey you told me we're going to implement the ad interface but I don't see that function anymore all right let's Elizabeth that lets say [Music] okay so I need to Claire this is public there we go all right great so now I can call this function right it's great now let me just point out a couple things so first of all I don't have to implement ad in order to get this to work all right this what worked fine right I implement ad it's a way of declaring that I'm going to provide this particular capability and it's also because we're doing this example on interfaces but let's see what happens if I change the interface so let's say I know their method now what's going to happen so now I get the same error I got before which is to say that the compiler is complaining that I haven't fully implemented the ad interface and and interfaces can have multiple methods in fact a lot of times they do alright so not always about a lot of times and so here's the case where I have to add methods and now if I want to fully not be at interface okay great now notice here you know I don't have to follow I don't have to use the same parameter names as the interface uses that's up to me you know what the interface does is set up type signatures for the methods that that I need to declare so essentially this says you need to implement a method called add that takes three integer arguments what I call them is up to me okay let's go ahead for a minute and then we'll come back and and and look at this example again when we talk about interface references so here so now when I have an object when I have a class and implements an interface so we talked before about when I you know and and because we've been being more specific about the difference between a reference variable type and the object type we talked about the fact that a reference variable can store a reference to an object of that type or any of its descendants so any object that extends the type of the reference variable reference variables can also store a reference to a class that implements an interface so the reference variable type can be an interface type and then what the compiler will do is check to make sure that the class that I'm holding a reference to or that I'm trying to set the reference to implements that interface so that's what's going on here on line 12 okay so now what I'm doing over here on the left is I'm saying I'm creating a reference variable called lowercase ad and that reference is going to store a reference to something that implements the ad interface okay so that's why I'm telling the compiler and then on the right side I'm creating an object called adder and that's what I'm going to use to try to initialize the value of this reference for it and because adder implements ad that works out fine however once I have a interface reference so remember we talked about before if I can take any job object and cast it to a capital o object reference but then I can't call any methods that are defined on that object I can only call methods that are defined on capital object like to string and you know things like that and the same thing is true for interface so let's look at this example adder implements ad the ad interface says in order to implement you have to implement a function called act it doesn't say anything about multiply and so once I refer to the object as something that implements add I can no longer call multiply even though the object that I use to initialize the reference does implement multiply all right so let's let's make this more concrete go back to the playground here okay so let's do let's do this okay so now let's do a couple examples so first let's look at a case where I have something that implements so so here's what I'm doing here on line 11 I have the class called adder I'm not implementing ending interfaces I'm just providing a public method called add that takes two parameters and returns their sum I'm not implementing add I can create so here what I'm doing is on the right side and creating an instance of the class adder and I'm saving it in a reference variable that can store an instance of app and because of that I can call hat because add is it is a reference variable the stories a reference to adder and add or implements the add function okay now let's do this okay so that still works actually sorry let's do let's not do this yeah let's just do this okay so now let's try changing my add variable to be an interface reference so this now says I want to use add to refer to something that implements the add interface and what you're going to see is that I get a compiler error when I try to compile this code because a door cannot be converted to add why because adder doesn't implement the interface once I add implements add this works fine now let's let's try a second class and must implement add as well provide in this case you know what here's the here's another lesson about interfaces I don't have any way to determine whether or not the class implemented the interface for important correctly all the interface knows is that you're providing a function called add that takes two integer arguments and returns an integer does it know if you're actually adding them together this is where good documentation comes in handy right so now the interface says you should have the two arguments my another class isn't doing that but for the sake of of messing around let's just keep this up for okay so here's what I could do now I can say add is equal to new another and now I so again slow down and just go through this carefully so here on line 17 I'm saying I'm declaring a variable called lowercase ad that's going to store a reference to any object that implements the ad interface I initialize it to store a reference to an adder object but then on line 18 I change that reference to store reference to do this another object and I can do that because another implements and so this variable can store reference to anything that implements the ad interface if other didn't implement ad then I would get a compiler error here on line 18 this lines fine because a door implements add this line is not okay because another is not yeah but let's have another half now here let's do public voice something at pulse you know let's just have this beam up you function latex style is not gonna be too angry and then let's do a boy like boy whatever I've got another sort of empty function so I can't call it's important to note here I cannot call whatever here alright because whatever is not part of the ad interface and interface only includes this method called add whatever is only part of the another class same thing here I couldn't call something else let's try it out Alice I can't do that either because I can only have if I have a reference to something that implements an interface I can only call methods that are implemented on the elements so I could do this let's do something else right now I have another problem which is another needs to implement something else right and now I could call a dots because it's actually part of the interface that's in this case that's just just so I can prove that it's doing something are confusing there you go okay good so again you know if I have something in the fulness an interface I can refer to it you see a reference of the interface type that's essentially the takeaway here okay so I just did this so this is in some ways so I want to make a point here about is this relationship to inheritance right so in some ways this is pretty similar to inherent and overloading right the interface is sort of like a parent plants implements is sort of like extends and providing your own invitation is sort of like overriding a parent's method so this is kind of like extending a superclass extending another class and then implementing overriding a method that was provided by that class and it turns out so again here here here's the here's the example of that's right so I can you know I'm doing something similar here except that now add is a as a public class and it implements add I'm up casting my reference to an adder object to add because I can do that because it extends add and then here if I want I can override the method and and how to do whatever a while right okay so now so now I have you know behavior that in some ways it's very similar to the example I just walked and actually if we go back and we pull one of our buzzword you know keyword bingo cards out again abstract class does make it possible for this to be even more similar because I can also have abstract methods okay so and again I don't want to dwell here because I do want to talk about interfaces but I just kind of want to make this I'm trying to what I'm trying to draw out here it's what's special about interfaces and so to see that what we first have to think about is what could we do using the class inheritance model that we already know about so here's an example I have a public abstract class called add and instruments an abstract method if I declare an abstract method I can't provide an implementation so if I try to do this ordinal today all right you're gonna see that it's complaining abstract methods could not have a body so this cannot have a body it can only and now you'll see when I extend add the compiler actually will fail because it says I have to implement app so now I actually have to provide an implementation for add since it's abstract great so now you'll see okay so here was my example use an extension where my parent class actually provided two default implementation on the I overrode it and now if I use abstract I can actually have a case where my parent doesn't provide the default of publication because back here the problem could be you know there's actually no requirement that I even provide add I could just not override it and then I get this you know nonsensical result right here I can't do that I have to implement at if I take this out you know we're gonna see that same compiler error because add is an abstract method meaning that when I extend the class I have to provide an implementation okay wait okay so so why do we need interfaces it seems like we could have actually gotten very similar behavior to what we you know to what we wanted what we talked about before just using a combination of extension inheritance and abstract classes and methods so why interfaces okay so here's the problem with Jonathan's inheritance model it's limited every class can only have one parent and there's and that means that essentially you know if you think about how children inherent capabilities that means that if I want a certain if I want in a you know certain classes to be able to do certain things then an entire part of the tree has to be able to do that so since as soon as I had a capability to character then digit letter of all the consonant all have to be able to do that thing right and sometimes I don't want that sometimes I want to you know it have things that are a little bit more flexible so one of the big differences between inherit between inheritance and interfaces in Java is that classes can implement multiple interfaces and this is super important so here's an example now I've got two interfaces I have an ad interface and a subtract interface and then I have this Madi class and the matthew class declares that it implements two interfaces and I can declare that I and the interfaces as I want when I declare that implement multiple interfaces I have to implement all of the methods that are declared in all the interfaces that I declare that I implement so to implement ad I have to do you know implement this ad method that takes two integer arguments and returns an integer diplomat subtract time to implement a method called subtract that takes two integers and so this is the big difference between inheritance and interfaces in Java is that a class can implement multiple interfaces it cannot extend multiple classes and so again here's an example of this and then you know why I wanted to add about the tier to another subtract method now I'm going to get a failure because I have to implement that one too and I'll just code I love to do this all this have to be further than a second okay so so that's interfaces in Java so now let's let's step up a minute and and we're gonna spend a lot of time between today's screencast and Friday talking about what interfaces are and how they work because this is something that's new a new concept I think pretty much for everybody who took this class no matter what how much prior or experience you had because the interfaces aren't something I don't think that gets covered in most AP courses and if so not particularly well but this is what's really really important about interfaces is that you know regardless of other interview about how they're implemented and regardless about whether actually they're part of the language like there or a job or not like they are in JavaScript an interface represents a contract between two parts of your program or two parts of the system and the idea is that the interface you know codifies the things that two parts need to know in order for things to work correctly okay now this interface that I'm showing you is one that we're going to use a lot over the next a few days into homework problems and on the quiz next weekend in other places okay and this is actually a real Java interface let's see here I can pull up the Java doc for it obviously other stuff like that okay so here's this is actually a real interface it's an interface as you can see this is implemented by a lot of classes and this is you know the definition right I'm showing you a simplified version of this but this is pretty much it okay so okay what does it mean for something to be so this is an interface called comparable and it has one method called compare to that method returns an int it takes an object reference to another object and it returns it it okay and here's one place you know if you were just the ad interface we looked at it was sort of sort of clear what was supposed to happen if I have a function called add and it takes two integer arguments even if I didn't give me any Java doc you could probably guess what that was supposed to do here it's less clear what you know all I gave you was this right you wouldn't be sure what to do but here's what this interface is supposed to do comparable is an interface that a class can implement if it instances of that class can be put in or okay and that means that there's a meaningful order that exists among objects in that class and we'll talk more about this as we continue to go deeper with comparable this is kind of an interesting concept the compareto now if you are comparable if your class can be compared if there's a meaningful or among instances of your class then to show Java to show other parts of Java how to compare two instances of your class you only have to implement one function that function is called compare to compare two takes a reference to another object and it returns the following a negative integer zero or positive as this object is less than equal to or greater than the specified object so if other is less than this object you return something negative it could be negative one it could be something else if it's equal you return zero if it's greater than if this object is greater than the specified object you return a positive okay let's actually go through here because sometimes I get this wrong right returns a negative negative number zero positive is this object is less than equal to or greater than the specified pumpkin okay comparison object with the specified object for water so why is this a good example of a nervous the reason is that not every Java object can be compared in a meaningful way to other Java to other instances of that class some can some can't and the ones that can and the ones that can like you might have objects that inherit from an object that is comparable that aren't comparable and you might have objects that extend an object that isn't comparable that want to establish a comparison relationship so this is a you can think of it as a trait it's like a capability that some classes in Java have and others don't if your class has this capability you can declare that you implement comparable and then you have to implement this one function to show someone using your class how to compare two instances of that object okay what does that get you okay so this is this is where this becomes really cool right so again interfaces are awesome and this is where this becomes really powerful so if you live in the compare let's say you create a new class in Java okay and it's part of a project you're working on and you realize okay well actually I can I can put you know I can actually sort there's an order here I think there's a meaningful order among instances of my class right so for example if you're working on the machine project and you wanted to order games maybe a meaningful order is buy time like when did the game start right so I order games so that games that started earlier in time always come before games that started so if you give me two games what I do is I look at their time stands like when did they start and I tell you that the one that started earlier is less than the one that started great later okay so that's an example all you have to do is do that and then there's all this other code of Java that can do the following so all of a sudden I could take an array of objects of your class and I can sort them I don't know anything I didn't need to know anything more about your class other than how to put two instances in order that's it once I know that I can sort the right I can also find a maximum or minimum value we're about to do that that's an example right I can arrange instances in your class into a data structure called a binary tree that we're going to come back and talk about in a couple of weeks so this one again this is a you know why interfaces source were powerful by doing this one thing so essentially you you are setting up a new interface between your class and other parts of Java and there's all sorts of other parts of Java that could use this interface that you are now implementing to do useful things you don't have to write that code you don't have to know how it works and that code doesn't have to know anything more about your class the only thing it has to know about your class is how to compare two instances of that class so again just to make this really crystal clear because this comparable instance represents this abstraction barrier when you implement comparable you don't have to worry about how a sorting function is going to use that implementation to put instances of your class in order you don't have to worry about how the binary tree code works all you have to do is tell Java tell the world how to compare two instances of your class similarly when I use comparable so every interface has two sockets there is the implementer and the user when I use comparable I don't need to worry about how the interfaces is implemented but I know that I can correctly compare two objects of as long as they implement comparable okay this is tough I understand this is a slippery idea we'll come back and we'll talk about it more on Friday and we're trying to wedge this as firmly into your brain as possible right this isn't an example of something in computer science it's not-it's an abstraction barrier so there is a point of agreement here what we've agreed is that when you implement comparable you implement this function and we've agreed about how the function works and that's all we need to agree at that point your code just has to implement comparable and all the other code out there that uses this ability to compare two instances superclass just goes on its way doing what it was doing and there's no other communication or coordination that's required between those code bases which is a great thing okay so we're gonna close out today with an example of this for fun okay so it turns out so the first thing let's do is it turns out that there's a lot of code out there in Java that already implements comparable let me give you an example so I'm gonna create for every Java primitive type there's something called a wrapper type the wrapper type is the object that stores a value of that primitive type so for int the rapid type is called capital I integer it's what I'm gonna do here is I'm going to create a array of integers okay and then I'm going to call this I need to kind of cast this let's drop it out laying that in a drink not from that comparative silence oh I know why it's because I'm using this get rid of this and see what happens now yeah okay I think this is gonna work yeah cuz I'm using this oh it's okay china style relaxer okay great so sorry let me do this okay let me put that definition back but I'm gonna put it under a comment because the problem is if we put this in here then we're using our comparable interface and what I want to do is use Javas all right great so I'm close cool alright so now so now let's look at an example of using an interface so this function called Maxima alright and we'll come back we're gonna talk about with more on Friday so it's function takes an array of values that can be compared so this is an example of casting something to an interface time so I know that the values that are stored in this array are all values where I can compare them to each other all right and that's critical for my maximum function to work okay so my maximum function is return an object it's going to turn the maximum of this array and all I need to know in order to finish this in order to do this is that all these values are there so let's implement that we can actually do this okay so let's say first we need to do if the value is null or values length is equal to zero in that case so these are kind of the corner cases if the values array is null or doesn't be content and doesn't actually contain anything we'll just return no if it only contains one value then the maximum is the first value okay otherwise here's what I'm going to do and you guys have implemented this before I'm going to say that I'm going to start off saying that the maximum is the first value and then I'm going to go through the rest of the array just using a for loop it gets been missing for loops coming back and I'm gonna say now what I need to do is check be able to print with the value is greater than maximum how do I do that well let's go back and look and compare so that I know that I can call this compare to function so because what I have is a comparable because my values right is full of comparables I can say yes that I use on I got zero to maximum and it says it's going to return positive integer if this number is greater than the specified object so if values greater than zero and thus a maximum is equal values I say the reference to the maximum value and then down here I'm going to return okay how cool is that so now I'm doing this with integers okay and again I can now find the maximum of anything that implements comparable so how does that this is actually really neat let's try some strings so I could say a new string string something like comparable okay so now let's get rid of my integer one I'm going to do strings oh it's mad at me about the let's see here checks out Paul do you want me to do this what's that there we go okay so now I can put the maximum of an array of strings I can compute the maximum of anything that implements comparable right again this is like so powerful because this piece of code that I've now written works for any Java object that implements comparable any object at all now let's do the other part let's actually implement compare for an instance of our class right for an instance of the value class okay so actually I don't want to ever do that so first of all let's try to see what happens if I do this so let's say I have a couple possible value and I'm gonna say initial you know this have the story ends alright so now my compiler is complaining because it says value cannot be converted to comparable and the reason is value does not implement comparable so I've created this new class but I haven't shown Java how to compare two instances on so now let's implement my comparable interface and it's gonna tell me that I need to implement this method so and prepare and for now let's just return 0 ok oh I've gotta make a call and about fits ok so essentially at this point it's basically saying that oh and let's add a two string method sure so this nicer public string oh how you there's a cute little trick you can use there we go so now what I'm doing is I'm basically saying that the values are always equal and so the maximum value for my array is going to be whatever is the first value there's nothing above or bigger than that all right that's probably not what I want so I need to do a little bit more work here so the first thing and this is kind of like equals the first thing is I have a reference to an object and I actually don't that's actually not what I want what I need is a reference to a values that I can check it's about so just like equals what I'm gonna do is I'm gonna say that if Oh so now what I'm saying is if the thing that you passed me does not actually return to refer to a value then I'm just going to say that it's the same alright there's actually a better way to handle this but this is the best thing that we can do right now otherwise I'm gonna create a value reference and I'm gonna downcast my object reference to that value reference and I know that I can do that because I've done this check here so if always not instant-on instance of a value that I've already returned and so now I can do what I can do is I can create another reference another reference to something I can downcast this object reference safely and now let's say let's do return other than value minus value so how is this gonna work so whether that value is bigger than my value then this is going to return a positive number if it's smaller it's going to return a negative number and if it's the same it's going to return zero and that's pretty much what corresponds to the you know to the to the to the to the interface here except I think I have it backwards so let's try let's try something like this let's see what we got here okay so yeah I think I have this backwards so this is always gets me with this interface so a positive integer if this object is greater than the specified object so right now if the value if the other value is bigger I return a positive object so I'm actually I'm I'm actually flipped it around right so rather than sorting smallest rather than saying that the smaller value is less than the greater value I'm saying the greater value is less than the smaller back and that's kind of fun actually that's sort of what I wanted to try here to show you right because now that we have our own class we're in charge of deciding how we want to compare it to other classes so here's an example where now I'm I'm returning the I'm saying that another value is greater than other value if it's value is bigger but if I swap these around defining its comparison now I've got the opposite not returning to Smallville so again you know the the cool thing about this you know and and so here I have both a consumer of an interface and I have the provider right so this class provides implements the comparable interface this piece of code is using the comparable interface to compare different batteries and because a bunch of other classes out there implement comparable I can actually you know like I just did before I can actually now find the maximum value of all sorts of different heights you know a raise of all sorts of different types of objects the only thing that they need to do is implement the comparable interface okay so this should be enough to get you through the next couple homework problems we will come back and continue this conversation on Friday I know that this is this is kind of this is really the last thing we're going to talk about in objects next week on front on Monday we're going to move on to the third part of the class and begin talking about data structures and algorithms this is it for objects this is you know the most difficult I think conceptual bit of the object or part of the class but it's also incredibly useful you know if you can wrap your mind around this concept around what it means for something to implement an interface and the difference between an interface provider and an interface user you will be well prepared to understand how many many different types of the computer systems work all right I'll see you guys in class today and then in class on Friday good luck on the homework problems  
﻿ all right come back everybody so today we're gonna continue our discussion of algorithms and algorithm analysis so this is the last part of the class the most fun by far you get to use the skills and abilities we've built up the knowledge about imperative programming and object or any programming to do some cool things that's kind of what we're gonna do throughout the rest of semester we'll learn some new things along the way we'll add a few object-oriented concepts and techniques to our bag of tricks will also learn about recursion which is a new problem-solving technique that we haven't talked about yet but you know a lot of what we're gonna do is think about algorithms how to analyze them data structures how to build them and and really I should say how to analyze both all right how to analyze data structures how to analyze algorithms so as a reminder from last time and earlier in the semester so you know and again I think this is really important to understand an algorithm is a set of steps that you can use to solve a problem algorithms need to be you know in a form where you can write them down so you know you need to be able to describe how to solve the problem in some way that someone else could then use to either solve the problem or implement the algorithm in actual computer code but the algorithm is not the code the algorithm can be implemented in a variety of different ways sometimes you'll see algorithms written down in something called pseudocode pseudocode is an actual real code there's no compiler or computer program that can run that pseudocode but it's specific enough that somebody could then take it and implement it in Java or Kotlin or Python or Ruby or rust or whatever okay and as computer scientists you know we we are going to utilize these computer capabilities to implement our algorithms so we're going to perform simple computations this is stuff that we talked about like the first couple weeks of class we've been using ever since we slowed down a little bit during the object section but we're gonna go back to thinking about performance circum-pacific calculation using variables to store the results you know repeating things over and over and making simple decisions those are the building blocks for the algorithms that we're gonna talk about so data structures you know so algorithms sort of connect back to the first part of the class data structures connect more to the second part of the class right where we're finding new ways to structure data we looked at arrays we talked about arrays for the first data structure and so far the only one although today we're going to start talking about a generalization of arrays that we use to both build a cool data structure in loader a little bit more about Java and get some practice analyzing algorithms so as programmers Java programmers if we want to structure data in new ways one of the things that we have now in our bag of tricks is that we can extend java's built-in classes so we can create new kinds of data using the classes that we've been practicing with all right that's what they're for right one of the things they're for is to create new data structures so we're going to utilize that capability we can also you know we'll also need to go back sometimes and store things in actual arrays so the data structure that Java gives to us in today's homework problem and on Friday we're going to talk about how to use an array is the building block to build a more general data structure that acts like an array but has some features that arrays don't have that we would like the ability to extend you know by adding items to the end or just the beginning the ability to add items to the middle these are things that if you programmed in Python or other languages that have built-in support for this you've gotten used to job arrays don't do that but we can build a data structure that acts like a Python list on top of a Java array so our data structure is going to store its data internally in an array but it's going to provide an interface that allows it to behave like a list that's what's kind of neat all right and then when we look at our second array implicit implementation so lists are like a great way to start this whole project right because not only can we build the new same arrays which is the data structure that we already know about but we can also build them by utilizing object and that's something that we're gonna then use to bootstrap our discussion of trees right so that's another way to establish structure between data is to take two objects two instances of a class and have one of them or both of them store references to each other so now we're creating structure between those pieces of data all right and again these two topics are highly complementary so this is really the part of the class where we're going to interweave this as much as possible so you know today and Friday what we're really doing is building a data structure a new data structure called a list but we're gonna analyze some of the operations on a list as if they were algorithms how long does it take to add an item to a list how long does it take to go through all the items in the list how long does it take to add an item at the end of the list things like that we're gonna analyze those like they're algorithms we're also going to util in plantago themes utilize specific features of data structures all right so a lot of times you know all the recursive algorithms that we talked about almost all of them are gonna implement it on trees because trees lend themselves very well to this type of algorithm in this style program so you know we don't use data structures arbitrarily we use data structures to achieve a result which is typically that there's an algorithm that we want to implement that we can now implement because we've chose to destructor the data a little bit different and you know again when we talk about trees we're going to talk about tree data structures first and then we'll talk about the cool algorithms that we can use to build on top of but this is this is you know again there's a deep relationship between these two topics neither one of them exist in a vacuum they're really very much intertwined okay and again along the way we get plenty of chance to practice with both imperative programming techniques that we learned in the first third of the class and the object-oriented stuff we've been learning recently all right so as a review from Monday when we talk about algorithms and the most important things that we usually want to understand about them is how they perform so here's the thing you know you guys are have been born into a world that is filled with algorithms you know if you look up how to sort data you go to the Wikipedia page you're gonna find a list of like 30 or 40 different sorting algorithms these are different sets of steps to solve the same problem that have different trade-offs that's the trick so if you just want to sort something you can implement bogo sort anyone know what bogo sort is okay you view that few of the sorting fanatics here have some sense of that is you can implement Fogo sort your program will be very slow once you guys figure out what bogo's sort is hopefully a little chuckle out of this you can implement bogo sort it will work it will eventually sort data it's not very good at it in fact it's extremely bad but it is a series of steps that will accomplish the result as a sophisticated computer scientist however what you would do is you would look through that list but think a little bit about the properties of the specific data that you're trying to sort and you would choose a different algorithm because boboso doesn't perform very well and their sorting algorithms that do better okay so so this the ability to think about not just implement okay so you know any hacker can implement an algorithm a computer scientist can think about an algorithm and analyze it they can think about what happens on different types of inputs they could think about how it would work in different scenarios is it good enough is it really good enough to solve this problem these type of choices really matter right you know this type of choice down the line for you might determine whether or not you get to keep a job whether or not you get a job in the first place whether or not your startup makes it big you know you you you guys don't because don't really remember this right how many people remember a social network other than Facebook yeah if you're embarrassed by your age you don't to raise your hand but there's a few of us out there right you know contrary to popular belief Facebook was not the only social network back wasn't even the first anyone remember any of Facebook's contemporaries the old old people out there MySpace oh yeah whoo and has anyone ever seen myspace before so I think MySpace was actually like a covert project to get all of the terrible web pages really ugly web pages into one place you know so then we can kill them all off at once yeah MySpace what else MySpace actually didn't really try to offer some of the features paper - yeah well was was like yeah okay I'll take that but something that was really trying to do something similar to Facebook where you could go on and identify friends and stuff like that there's actually a name for this Friendster how do you remember Friendster anyone have a friend store account back in the day yeah I did it's pre Facebook it was the social network that was out there do you know what the things that doomed Friendster I mean Friendster worked kind of like you got on you could see other people's profiles it was kind of like an early version of Facebook I mean it never had the newsfeed it never evolved because it died off pretty quickly do you know one of the problems Friendster and Facebook didn't at least initially related to what we're talking about just from a user perspective yeah it was slow yeah it was slow you go on a page would take like a while to load and my understanding I got never worked at Friendster and hopefully hopefully someone that worked at Friendster will notice this and then flame me and I'll find out what really happened right but my understanding was Friendster was actually trying to maintain the social graph in real time so anytime so for example if he and they had these rules like if you were three people removed from somebody you were allowed to see their profile well imagine is people are using this you guys are some of you were probably on Facebook right now you're like oh there he goes on another tangent it's not going to change the slides for a few minutes so I'm gonna go check my newsfeed right but imagine as this graph is changing all the time Friendster constantly to be able to answer these questions about whether or not I can see somebody else's profile so part of what doomed them I think from my perspective as a user was that their site was slow and I think it was just because they were trying to solve a really hard problem Facebook didn't do this initially Facebook got there eventually but early versions of Facebook were siloed to specific schools that you were a part of so you could you had certain permissions allowed you to see pretty much everything that went on at like your college and very little that went on anywhere else and that user model worked for a while for Facebook to help them get off the ground so again this stuff matters if you go out and start a start-up and at the core of your business model is solving some unsolvable problem you may not get very far if you don't have a clever way to do it okay when we talk about algorithms typically what we're going to focus on is what we refer to as the behavior at the limit so what happens is the problem gets really big what category does it come into and there's a couple reasons for this um you know one of the reasons is that that's when things get interesting all right when the problem gets really big that's when things will slow down and might become a problem so we'll start answer questions like you know given certain inputs in general cases how is the algorithm gonna perform so what's the best-case scenario for the algorithm what's the worst-case scenario but the number one thing that we're always trying to figure out is what's the relationship between an algorithms performance and the problem that it's trying to solve okay so for example if I'm sorting things then you would expect there to be a relationship between how many things I have to sort and how long the algorithm takes and sure enough there is if I'm searching for something let's say I'm have to search through a bunch of items again you would expect there to be a relationship between the number of items I have to search and how long it takes me to find the item or to figure out that the item doesn't exist right so this is one of the things that we're going to try to do the notation that we use to put things into categories so and and a lot of what we're going to do this is very this is a very gentle simple introduction into algorithm analysis you guys will see more of this in 173 and way more of it in 225 and then down the line and 374 in other classes so this is an important enough concept that we teach it to you over and over again so this is just a gentle introduction the notation that we use here is sometimes referred to as Big O notation okay and it's essentially putting things into categories that are defined by the relationship between the size of the problem and how long the algorithm takes to solve and we're gonna today we're gonna go through those categories one by one and not only talk about certain problems that might have that property but also look at some features of actual Java code that could give you a hint that you're dealing with the problem of that of that type so here are our categories shown graphically so and this is why this matters right so o n is sometimes we refer to as linear time that means this the problem gets bigger the algorithm gets slower but it gets slower linearly as the problem gets bigger so if you give me twice as many items to look through my search algorithm takes twice as long right so that's down here that's the green line oh I have a little friend here helping me out I wonder if I could like zap it with the laser and it would actually probably not that powerful all right so let's look at a different one that we're gonna look at today so this is Owens square so this is now polynomial time with with two is the exponent this means if the problem gets twice as big the algorithm now takes four times as long the problem takes gets ten times bigger the algorithm takes a hundred times long okay so this is this is bad then let's look even farther up here so now two to the N this is exponential time my the size of the problem is no longer the bottom part of the exponential it's the exponent okay so now as the problem gets bigger the solution is slowing down even faster right so you can compare these two to each other polynomial time and exponential time and then way over there on the Left I have factorial time which is which is awful one of the algorithms so that I mentioned earlier bogo's sword actually runs in factorial time it's not good it's not a good algorithm to use you know and then and then there's some other categories here particularly the ones that have a logarithm in them they're not going to make a huge amount of sense to us until we talk about recursion okay but these typically have some these typically occur when we have certain features of the problem where it we can make it half as big so searching through a phonebook for example you know this is the famous demo that that David Malan does in cs50 every year take a phonebook I'm looking for a number what do I do I open it to the middle and then I say is the number I'm looking for him the first half of the second half of the phonebook and now I've made the problem half as big so essentially I only had half as many numbers to look through and now they repeat that process so no matter how big the problem was if at every stage I can make it half as big then I'm gonna be in what's called log end time which is down here and you can see log n times pretty good you barely see it it's it's barely growing as the problem size gets bigger that's actually a really a really nice nice way to when I heard about that example that David does it was like oh he's ripping a phone book in half I thought he was ripping it in half like the hard way you know like I crossed the spine I was like wow he must have been working out since I knew him at graduate school but he's ripping it like down the spine that's easy to do right I always thought it'd be fun to do that example like with the chainsaw where we actually could like you know cut it cut it apart but that algorithm doesn't work very well either all right so here are complexity classes now let's start meeting them one by one okay now this one you this one you don't even see here well actually it's on the graph but you can't see it because it's it's it's hidden by the axis so oh one now one thing I want to point out here is that this is the only time that n does not appear in my Big O notation sometimes you'll see this is OC you know the idea here is that these algorithms do not depend on the size of the input they always take the same amount of time you know that Goodman's like that right imagine you give me any number of balls and I have to pick one at random takes constant time I describe one I don't have to look through them all I just pick one at random so this is called constant time this is not very common so if you think about looking for something do you think about sorting you think about you know some of the algorithms we've talked about like designing a route across the United States to try to minimize travel time these don't run in constant time but sometimes we have algorithms that do run in consequence and and you know these operations these kinds of operations in Java do take constant time so here's an example accessing an element from an array in Java takes constant time one of the reasons why it's important to understand some even something like positon that's not that useful is that this is a building block for other algorithms so if I have a loop that has something that does is constant time inside of it then I can be assured that my loop you know that the inner part of the loop takes the same amount of time every time I execute it and now I can think about the complexity of the whole loop rather than just the inside ok all right so now let's talk about where things start to get interesting so o n so sometimes known as linear time here the problem grows linearly the amount of time it takes to solve the problem goes linearly with the size of the problem and remember part of our Big O analysis is actually figuring out what n is so depending on the problem the first thing we have to do frequently is figure out what is n right what is the thing about the problem that we're measuring that we're then connecting with how long the solution is going to take so if you imagine that I have a problem of size N and my algorithm needs to take a pine that's proportional to the size of the input one of the features that you're gonna see a lot here particularly in code that we look at is a loop right if I have an array of size N and I need to go through every element in that array I have an oh end that's an O n step right so essentially here's my array in this case it's the size 1024 and imagine I'm going through and I'm computing the sum all right so I set my sum to 0 this is concert time and then I have this array here I have this loop where I'm going through every value in the array and I'm just adding it to myself this are good to your question aside this is an example of an onl girl and you and you know here's the way to think about it can anyone if you guys can come up with an algorithm that can sum the elements in an array without reading every element in the array then there is definitely some prize waiting for you somewhere right and a lot of cases o n is the best that we can do because I have to look at every value I can't compute like if I wanted to sum all of your ages I can't compute that without asking every one of you your age I could estimate it I could you know sample this area over here and then multiply by the size of the room but that's not that now I'm solving a different problem right if I really want to know exactly what the sum of all your ages is I have to ask every one of you your age I can't do it without you know getting to everybody question is there difference from our perspective between the ants for enhanced for-loop and their regular for loop for algorithm than elses no yeah no so if I so the question was you know if I replace this with the regular for loop or the index for loop maybe it's what we should call it does that change the algorithm complexity no all right it's tough to go through have you got yeah all right so whenever I need to see everything whenever I have a group of elements and you might think about searching - alright let's say that I want to search through this room until I find somebody that has the same birthday that I do maybe there's nobody in this room that's the same birthday now there turns out actually the probability that someone has the same birthdays me and here is really hot like really hot sometimes known as the birthday actually sorry I don't know I misstated it the probability that two of you have the same birthday is like almost 100% probability to everyone that someone has the same birthday as me is lower than we'll talk about this is known as the birthday paradox but if I wanted to look through the room to find someone with the same my birthday again I it's possible I would have to go through everybody let's say I don't find any I come over here the side of the room I go down I've worked the entire floor nobody has my birthday I go up to the balcony nobody has my birthday I might have to look talk to every one of you before I find someone that has my birthday now I'm not I'm curious does anyone have my birthday 915 any nine Thirteen's in here he claims the people next to him are saying yes and he say no so someone is confused about somebody's birthday we can talk about that later anyway but if I really want to make sure I'd have to go through all right there's like a lot of search problems there away particularly if I don't have the data organized in some way when I have the data organized I can do better than that okay so again here's and you can see already we're seeing a pretty big difference between these two these two complexities so here's when and Oh constant times down here right okay so what about this let's let's look at something more common this is essentially a search algorithm okay I've got a value called looking for this could be my birthday and I'm going through the array and if I find looking for I'm gonna break okay so let's apply our algorithm analysis principles to this problem and here frequently when we do this it's helpful to think about best case worst case first okay and then maybe you get to the average case all right so what's the worst case here let's start with the worst case scenario okay yeah yeah or it just it's on in there yeah so so essentially the worst case scenario is the array does not contain the element okay why is this the worst case scenario because in that case I will never hit that break statement and so I won't exit the loop until I've looked through every single value in the array okay okay what's the best-case scenario yeah it's the first position yeah bingo okay if it's in the first position I have one iteration okay okay now this is where it gets tricky average case performance for this algorithm who wants to start me down a conversation about this this is not as easy as you might think average case performance yeah okay square root of n okay that's interesting can you can you explain your answer just sounded cool yeah anyone else wanna what what what don't you know here that you need to know to answer this question yeah so the distribution of the numbers in the array okay so let me make it easier what if I know that the value looking for is in the array somewhere I don't know where it is I know it's in there somewhere then what is the average case performance so I'm gonna find it it might be the last element it might be the first element it might be anywhere in between what's the average case performance yeah and over two sometimes it's right at the beginning other times it's all the way to the end but if I can guarantee that the element is in the array then the average case is n over two but what if okay so what if the element is not in the array never in the array what if the array is full of positive numbers and looking for is negative then what's the average case runtime so now it's a win right because every time I go looking all the way through so the thing that you you you don't know that prevents you from solving this right it's a best case first element worst case last element average case I think the slide is wrong it depends on the distribution of elements right if I know the looking for is in the array then it's Oh n over two now when we talk about one thing I want to point out here is that when we talk about complexity analysis we typically just ignore multiplicative factors so 2n + / 2 + / 4 8 n they're all n to us doesn't matter just throw that out now you know again if you work at Google and you go to your boss and you say hey I found an algorithm that makes search eight times faster you're still going to go to Ray for that right so don't be like oh it's still Owen who cares right you know I only made it a million times slower but it's still Owen so like no one cares right no people care about that but when we talk about categories of algorithms and growth we're gonna make nor those factors okay are they are they you know relevant in the real world absolutely right are we gonna worry about them not so much okay let's go on Oh N squared so now again the problem gets ten times bigger the solution runs a hundred times slower problem gets twice as big decision runs four times so here's a hint that you're looking at an O n squared problem you see nested loops right so now and if I had Triple E nested loops I've had Oh n cubed I wrote Rupa blessed o n to the fourth right so here's an example okay and this is also an example of a terrible algorithm remember I said we talked about last time you know algorithms can move a bad algorithm moves a problem from a faster complexity class to a slower complexity class a good algorithm does the opposite so this is a bad algorithm well I'll talk about it more in a minute but you might start looking at and figure out what it does okay so I'm taking well actually you could just read the name and figure out what it does right so this is called is sorted it returns a boolean takes an array of integers as input so nice to look at some imperative code again right kind of fun I have two loops my first loop goes through the array my second loop goes through the array and it starts at I okay so it's not actually going through every element you know it doesn't make that big of a difference here and essentially what I'm looking for I'm looking at pairs of elements and I'm looking for a case where an element with a larger index is less than element with a smaller index I so if I start at J at I and J goes up to array dot length J will always be equal to or bigger than ah I could really start J at I plus 1 okay so essentially I'm saying if I found a pair of elements where J is bigger than I better Ray J is smaller than I I'm gonna return false otherwise if I go through the entire array and I don't find those elements I'm gonna return true so what is this doing it's checking to see if the array is sorted all right that's one way of doing it it's not a good way alright so in this case I both have to loop and compare and so in those cases frequently I end up with something that has nested loops and ends up being Oh n square and again you know we're ignoring the constant factors here this isn't exactly Oh N squared because the first time I go through I execute n the second time I go 3 or X minus 1 and minus 2 and minus 3 and so really this is and you know N squared over 2 it's n for the outer loop and n over 2 is in average for the inner loop but who cares we're gonna ignore the constant factor and call this Oh n square all right and you can identify this frequently by these nested loops 2 loops on top of each other where they're not less where they're not nested don't mean you have oh and square there you might have like Oh too wet but Owens step in an O n stuff but that does add together they don't multiply all right so let's analyze this little algorithm so what's the best-case scenario so now again we're thinking about inputs I'm thinking what I'm asking you is give me the input that causes this algorithm to perform well or tell me what kind of in in what kind of cases there's actually an infinite number of inputs here where this algorithm will perform well it'll take basically one or two steps alright what are those yeah well remember we're gonna normalize for the size of the array so the answer was super small array yeah you give me a small array and as small and and the performance is small but I'm saying even within n right this this is actually true of any size array right there's a feature of the array that's gonna cause this algorithm that perform really well put it this way if I give you an array with n elements in it all you need to do is look at change the two elements in that array and you can cause this algorithm to do very well ok what two elements are they and what do you do yeah yeah look I've got an escape hatch here I have a return statement in my inner loop it's under a conditional so the trick is how do I get this algorithm to head down this path okay so let's think you know okay so the first time I come through here I is 0 and J is 0 now array I and Raj are going to be the same at that point so I'm never going to get into the conditional on the first time through ok if I started this at I plus 1 I could but I started it not right all right if I and J are the same then array J is never less than array I they're the same value but the next time I go through the array my inner loop J is now 1 and I is 0 so if the second element of the array is smaller than the first element I'll return false every time the rest of this doesn't even execute remember little review about how functions work as soon as I hit a return statement I'm done bail out go home so I can give you an you can run this on an array with a billion elements but if the first one is 1 and the second one is 0 it is finished it has found when it needs to find because it's looking for whether it's sorted in ascending order and if the first elements one in the second MLS here well clearly it doesn't matter what happens to the rest of the array I've already found a counter example that the array is is sort okay so the best case is that the unsorted pair is right at the very beginning in that case this algorithm will never take more than two steps what is the worst case for this algorithm that's kind of interesting yeah yeah that it's sorted right so imagine it's sorted in ascending order then what's gonna happen is I'm never going to get into this loop into this return statement excuse me I'll never get into this condition okay and so I won't return until I get here which means that I dropped out of my outer loop and that means that actually could to my inner loop every time there's no break it the only way that I escape here is through this conditional that starts on line four all right so the worst case here is if the array is sorted and this is actually an interesting example of a type of algorithm that you see this algorithm tries to find out whether the array is sorted by finding a counterexample and so if the array is sorted it's going to return true but it only returns true at the very bottom and so in certain cases you're like let's say that you have an let's say as part of your program you need to check to make sure an array is sorted you're pretty sure it is sorted this might be like part of a testing code that you run that just makes sure the array is sorted before you render a list of elements of the user something on that now your verification step takes o N squared every time you run it even if you think the data is already sorted let's cut them not a great great property okay so and again if I don't know where the element is that is unsorted it could be at the beginning it could be at the end the average case performance of this algorithm is o N squared okay because essentially the pair of elements could be anywhere here so now we're up here we're looking at an O n squared algorithm these are worse things start to get bad you know where we start to worry about performance particularly as the problem gets big so this is one of those cases where if you ran this on your local machine and you gave in an array with five ten now someone pointed out small arrays always do good yeah so if my test cases all have arrays of size four and eight and 12 or whatever because those are the ones that I could write down for the test then I'm good but now I'm running this in production and I have an array with a million elements and you know my co-workers like dude the server's down and you're like no it's not just running my sorting algorithm right no problem just give it ten minutes and it'll come back up I'm sure nobody will notice all right as I pointed out before I'm not going to talk about these growth rates very much we'll come back and get these because the logarithmic part of these has to do with this again this feature of making the problem dividing the problem in half right but essentially way you can think about it is that if I have an algorithm that can make the problem half as small in every stop then I have usually either oh log N or oh and log in one time all right and they're recursive algorithms that we'll start to implement on trees frequently have this one okay so now let me come back and go you know trying to make this this relevant for you again before we would spend a few minutes talking about less so you know remember a dumb algorithm makes a simple problem harder okay so the test that we wrote to see if an array is sorted is dumb that is an oh end problem okay so again I sometimes have wished in the past that I could have some sort of special like slide background that I use when I show you bad code but if I did I would use it right here do not reproduce this algorithm it's wrong there is a much faster way to find whether an array is sorted so this is a dumb algorithm that has taken an O n problem and made it o n square on the other hand smart algorithms can take a problem that you could solve you know maybe using a brute force solution and certainly like we did with GCD right so our GCD algorithm is o and Euclid's method is o log n so now we've taken a problem that the straightforward solution was you know ran in linear time but actually sorry it was Oh N squared right and we can actually take that down to o n log N and that makes a difference right so again my sorting algorithm by is sorted method took a problem that belonged here and moved it up here and Euclid's method took our algorithm that started here and moved it down here okay so you know since this is an introduction to computer science I always find it fun to get to this moment all right so now again I want to make sure that you guys don't exit this class without a sense that there are deep interesting unsolved problems in computer science how many people have heard about this problem okay so a few okay and and and the way that we refer this problem is you know the P and P problem that's how you hear people talk about P versus NP as P equal NP and I am NOT going to talk about this at length but what this problem is really about is hardness difficult algorithmic difficult so essentially well there's something about the world that we don't know okay we don't know if there's a specific category of problems and we've identified lots of problems that fall into this category and it turns out they're all related to each other which is also really interesting right well right now it seems that there's a specific category of problems in the world that are harder than every other problem that we know about okay those problems are in this category called NP non polynomial time they are slow to solve everything else is in P so pretty much everything other problem you can think of we've managed to find a polynomial time algorithm for right so again let's go back here right so so what is what is a polynomial time algorithm a polynomial time algorithm is something that could be N squared it could be n to the fourth it could be under the 12th at doesn't map okay non polynomial is the stuff to the left right things that grow faster than every polynomial so this is you know again and I don't know I'm I'll be really curious whether in your lifetime you will see somebody prove this now over time we have developed a little bit more confidence about this because no one has been able to find a pie mealtime algorithm to solve certain problems and the thing that's interesting is that the remember I said there's this like group of problems that are all similar so that's there's a group of problems where if you solve one of them you'll solve all of them all right the one I'm going to show you is in that group there's a group of similar problems where I can take a solution for one and use it to create a solution for any of the others we have not managed to find a polynomial time algorithm to solve any of those problems okay the problems that aren't in that group we have found polynomial time algorithms for first so does anyone that this happened maybe in the last ten years anyone remember there was kind of a big announcement about one problem that we had thought was in NP somebody came up with a polynomial time algorithm for does anyone remember what that problem is we're super relevant to online security and all sorts of other interesting things remember what problem that was you guys were alive when this happened it's not that long factorization so given a number figuring out all of its factors right it's actually testing if it's prime I think the problem was called prime given a number testing whether or not it's prime we used to think that problem was in NP now it turns out that we found a polynomial time algorithm now the polynomial time algorithm we found still doesn't get used a lot because it turns out that it's slower than the best non polynomial time algorithms that use randomness to attack the problem in a way that's really cool all right so here's an example now here's the thing that's interesting about this this category of problems is these non polynomial problems they don't it's not just that they're hard it's that it's also easy to verify a solution and Sudoku is a good example of this so Sudoku turns out to be an example of a problem that is what's called empty heart or np-complete but if I give you a Sudoku puzzle and ask you to verify that I've solved it correctly you can do that in polynomial time so there's two things that have to be true I have to be able to verify the solution very quickly but coming up with the solution is very different now it turns out for small grids Sudoku is actually pretty easy but if you makes if you make really big Sudoku puzzles they get hard extremely quick all right I'm actually gonna well you know what I can get through this in two minutes all right total change of topic very quickly because it's something that we need to talk about in order to talk about the container data structures we're about to get to I apologize for that it's like a total train wreck transition right there okay so remember we had those primitive types like the the primitive types int long stuff like that so those turn out to be annoying at this point in our life everything else in Java is an object and objects have these methods like hashcode and equals and we want to be able to use those methods sometimes but we still want to be able to work with things that are like integers Long's and stuff like that and so Java provides what are called wrapper types okay so here's an example now you see something that looks like creating an object but it takes an integer literal okay and for every single this is a super exciting slide get ready for every single permit of type there is a wrapper type the wrapper types are objects they start with a capital letter usually they shares a similar or the same name as the primitive type that they wrap so again eight primitive types eight Java wrapper types I mean doing this because we're gonna start using these okay when we talk about lists okay yeah super exciting okay I'm glad I got that out all right so I'm gonna go through this quickly because partly you guys need this for today's homework right and then the next couple homeworks you guys are going to do so we're going to start to build together and it's a great chance to both talk about data structure design and algorithm trade-offs is something called a list right a list is a generalization of an array so just like an array a list puts items into order okay and it has features that are similar to an array so for example you can get and set values in the list just like you get in set values in an array now to do that you use a get and set function you don't use bracket notation but the list provides that function for T however like I said this is a generalization of an array it has some new features that we want I can add and remove values anywhere in the list at the front at the back in the middle okay so lists are probably one of the two most useful data structures that you will meet as a computer scientists sometimes refer to these as the data structures that you meet in heaven lists maps will get to both by the end of the semester lists or the first one that we're going to talk to okay we're gonna implement two different types of lists together both in class over the next couple of lessons and also on the homework problems okay the reason why we're doing this is a great chance to show you the trade-offs between two different ways of implementing the same interface I also use the word interface right because lists provide an interface that allows them to behave the same even if they're implemented differently so lists our first example of this okay and so we're gonna look at an example of an a list built on top of an array and then we're gonna build something called a linked list that uses object references to store the structure of the list all right so Java lists are a real thing there are already less implemented in Java we're gonna have you guys work with a simplified version of the list interface that I'm providing right here okay so this is the interface that your a list that you start working with today on the homework and we'll continue working with next week it's going to implement we're gonna get to the point where we have two different implementations of this interface one is gonna be called a simple ArrayList the other ones be called a simple linked list the reason why we're not using Jabez list interface is because it has a bunch of stuff in there that we don't care about so this is it okay get and set work the way you would expect them these are very similar to just using the array bracket notation add is something new that actually increases the size of the list by one remove decreases the size of the list by one and then we also have a size method alright this is where we'll pick on Friday I have office hours today from one to three please clear the room quickly today the class after us has a midterm I will see you guys on Friday  
﻿ all right hi welcome back on this gloomy late October day so today we are almost done with lists you guys aren't almost done with them because you're gonna continue to get to struggle with them for a few more homework problems but today I'm gonna quickly review the linked list insertion algorithm and then we're going to start talking about a new data structure trees we're just going to consume us for the next couple weeks not only because trees are an incredibly powerful and useful data structure but because trees are where we're gonna open up a new programming technique a new problem-solving technique that's called recursion we're gonna practice that on trees for a while give you guys some experience with that recursion is again really a I want you to think of this as a problem-solving technique there are recursive programs but really what we're going to be doing is implementing recursive algorithms it's particular approach to solving problems that proceeds by first making the problem smaller and smaller solving simple instances of the problem once we've made it small enough and then combining the results together so those are kind of the three characteristics of a recursive al all right but let's start out by quickly looking through our linked list insertion algorithm since we went through this quickly and then we'll do kind of a table based comparison of linked lists and array lists and talked a little bit about the trade-offs between the two remember these two implementations provide the same interface to a user so if you are writing a program you can use either a linked list or an ArrayList using the same interface and your program doesn't have to change at all the performance of your program will change because these two implementations have different trade-offs in terms of how the operations actually the performance of the underlying operations well let's first talk about how do we insert into a linked list so and this is something that you know you guys should follow when you're working on the homework problem about insertion okay so the first problem here is that we need to find the right place in the list so a linked list stores the structure internally and so we need to walk the list using something similar to the reference following for-loop that we looked at last time to get to the place where we have access to the reference that needs to change now that should not doesn't turn out to be the index of the new item it turns out to be the item that's before the item that we want to insert we find the right spot then we're going to essentially set we're going to change some references around again this is tricky to get right you're gonna make a few mistakes when you do the homework on this and but this is again great practice for things that you guys will see in 225 and 222 41 and other courses later on and also just general working with data structures as a computer scientist alright when we look at trees we're gonna do a lot of reference manipulation as well so essentially I need to kind of insert a new link into my chain and the way I do that remember the chain is made up of these references from one item to the next item so I find it if I want to stick an item in the list I need to both make it some other items next item so I change its next reference and then I need to make sure that the rest of the list follows after the new item that I'm inserting so I need to make sure that the rest of the list becomes the first item and the rest of the list becomes the next item of the list that I'm item that I'm inserting okay so these are the two steps right here and then I'm done that's all I need to you alright so let's look at this on on our diagram again quickly so let's say I want to insert value 7 I wanted to sort a new item with value 7 and index 1 so when I'm done this item will be the next item of item 5 and its next item will be item 8 that's one way to think about it so if I can get a new item 7 such that item 5 have a reference to item 7 and item 7 has the next reference to item 8 I'm done that's what I want okay so the first thing that we noted is that that actually requires walking the list not to item 8 which is where I'm gonna put the new item that's the item that's currently at index 1 I need to change the preceding reference so I actually need to walk a list to item 5 which is the item in index 0 this makes a little sense right if I stick an item at the beginning of the list then the reference that actually needs to change is the start right so essentially I'm walking the list to the in the element at index negative one doesn't really make any sense but that's my start reference that's the start reference that my list implementation holds internally in this case I'm gonna walk the list leg up to item five now I haven't it reference now I have access to the item I need to manipulate okay so now there are two steps I have my new item seven the first thing I do is I set item five you know I need to make it the next item after item five so I just did that here and then I need to make sure that the rest of the list so item eight is the next item after item seven now if you're not careful about how you perform these two steps you can get stuck because you might get to this point and think oh things are going really well but I don't have a reference to the rest of the list anymore right so that's where this becomes a little bit tricky this is not hard to do I mean this is one of those you know small two or three pieces lying pieces of code that's just subtle to get right the first time once you do it a few times it'll make a lot more sense right so make sure that you keep a reference around to item 8 because you're gonna need it here to read to make sure that I relink the rest of the list on after the new item the nightma 3 any questions about this no this is very abstract that's kind of the point it's you know you guys have been a common you know concern I hear about this classes oh I have a hard time translating my ideas into code and that's like yeah you know that happens I have a hard time translating my ideas into code right things you're like Oh that'll be really easy and then a year later you're still working on it so that's not a that's not something that's gonna go away you do get better at it with practice okay this is a case where the algorithm itself is a little bit you know subtle I walk through this a couple times use a whiteboard to kind of draw what's happening to the references as you go if you don't understand the algorithm you're never going to implement it properly even once you understand the algorithm it can be hard to the problem yeah what's that how do I set the reference well every item has a next next instance variable that's a reference to the next night so I just changed that it's just a reference I can set it to refer to any item so here I would say something like you know whatever item five was I would say item five dot next is equal to a reference to item seven and then I would say item seven dot naxx is equal to a reference to item E yeah other questions about this okay I just want to briefly point out that what we've been talking about is something that's referred to as a singly linked list reason for that sometimes just a linked list but the reason for this is because every item has a single link to the next item that's the minimum I have to do in order to establish order between these items you imagine if my item didn't have a next reference then I wouldn't have a list of items I would just have a bunch of items and I wouldn't know what order they were in okay so at minimum I need one link right I need to be able to walk the list from item to item following the next reference but I can also add another reference to each item to the previous item okay this is something that's sometimes known as a doubly linked list so in this model every item knows not only what the next item is in the list but it also knows what the previous item is in the list this allows me to do a couple of nice things the first thing allows me to do it it allows me to traverse the list in either order so I can start at the end and move backwards I can start at the front and move forward in certain cases if I give out references to the middle of the list this allows me to find the start or find the end right and so again this is kind of what this list would end up looking like right here you'll see that my simple doubly linked list class holds two references shows a reference to the start and a reference to the end and if I start at the end I can walk backwards to the start if I started at the start I can walk forwards to the end if I start at any item I can walk in either direction so I can either find the end of the list or I can find the start of the list now remember we were talking a little bit about we pointed out that with linked lists the performance characterization of different operations on a linked list was different than an ArrayList that's why we have these two implementations of different trade-offs so if I have a if I have a doubly linked list and I store a reference to the end what does this allow me to do that might be nice yeah I can add to the end of the list how long is that going to take now a 1 remember with the singly linked list I could add to the beginning in oh one that was cool that was useful that's actually a really good feature of Lists when you guys go on you're gonna talk you know you're gonna get to twenty five is gonna be like oh we did stacks and queues stacks and queues are just lists that don't have as many features right a queue is a list that you can't modify in the middle you can just modify at the ends a stack is a queue that you can only modify at one end so I can only add or remove items from one end of a stack so essentially a stack in a queue are watered-down versions of Lists the reason why they're useful is that by removing some of these extra features I can actually gain a lot of performance so imagine if your list implementation didn't have to worry about sticking things into the middle that would mean that it would be a lot faster right not only do you not have to worry about sticking things in the middle but you can't access the middle of a queue you can only get what's at the beginning or what's at the end and again there's certain algorithms from which that works great they never need to access the interior of the list and they get much better performance that way but with the W linked list if I store the end now I can add things to the end in constant time I can add things to the beginning in constant time and if I don't allow you to access the interior of the list if there's no get operation that takes an index if I can only get the beginning or get the end then all those operations are constant time which is pretty cool all right so the last thing I want to point out here before we look at the the runtime trade-offs between different operations on these lists is that there's you know I really would love to know why this happens I don't know it happens once it's like once a class and never again okay so this also there's another trade-off here between the ArrayList and the linked lists and that's a trade-off between time and space so we're not when we implement data structures and when we've put in algorithms we also have to think about how much memory they consume how many you know bytes internally of the computer's memory is going to be required to store the same amount of information and you'll see here this is my doubly linked list class you'll see that for every item I have to store three references every item serves three references so I store a reference to the value that I'm actually storing in the linked list I have to do that otherwise I can't store any data in my data structure I also hold a reference to the next item in the list and the previous item but this means for every one reference that I stick into my list remember the whole point of these data structures is to store data so for every one reference of data that I stick into the list I need two references of metadata right so essentially I need a next in a previous reference for every piece of data I put in right now again lick lists are faster for certain operations but they do contain more space take up more space an ArrayList internally had that array well the array stores exactly the right number of references for the list so there's no wasted space in an ArrayList if you make the array bigger than it needs to be then you're wasting some space but if the array is exactly the right size the way that you guys admit implementing then there is no wasted space in an ArrayList so for every one reference of data I don't need any references of metadata I'm using the array to help here for link list for a singly linked list I need an extra reference for a doubly linked list I need two extra references and so now I'm trading off space versus time so this implementation will consume more memory to store the same amount of data but certain operations particularly adding and removing from the front or the back viable doubly linked list are faster okay so again an ArrayList only needs n you know to store n intz or n references I only need to store n references my linked list you know it's three n for the doubly linked list one for the reference one for the next reference one for the previous one it's one for the value reference okay good so now let's you know to say goodbye to our lists let's finish this this table so this is really you know these are the interesting parts of the list interface I've got add and insert so I'm distinguishing here between putting things at the front and then sorting them everywhere and actually insert we can do insert and remove right insert and remove get in set these are the fundamental list operations so ArrayList if I stick something in the front what was the runtime of that for the implementation that you guys finished and that we looked at in class I stick an item new item into my ArrayList what's the runtime yeah where n is what yeah it's Oh n in the size of the list because remember I mean our chair analogy I've got to not only stick somebody into the chair but I have to move everybody else in the row down one so that's n steps what about a linked list this is add to front essentially guys remember what ad two-front looked like and gets worse in a link list once you have to add be able to add anywhere but what it at the front look like a one yeah fast so here my linked list is the winner it can perform insertions at the front of the list extremely fast and removals if I had to take an element out remove from the front is also a one with an ArrayList if I'm gonna repack the array every time it's only right what I'd get and set all right so here if you remember get in set for my ArrayList I just translated those directly into an array index operation and that is constant time right in a linked list what did what's the problem let's say I want to get an item that's in the middle of the list or change a reference to the oldest I have to walk the list in general how many steps is that going to take sometimes it will be beginning sometimes it'll be at the end but overall this is an O in operation I've got to walk the list an average Owen Owen over to but you know we're throwing out these constant factors okay insert anywhere at an ArrayList of the general case of insert in an ArrayList is similar to the special case of inserting it in the front but here's an interesting caveat to all this which is once I need to start being able to insert items anywhere my linked list does as badly as the ArrayList so it's really this special case here adding at the front or adding at the end I can make those constant I'm for my linked list implementation and you might wonder like well from this part you know from down here it seems like my ArrayList is kind of the winner right because linked lists are Oh n for getting set the general case and their Oh n for the general case of add or remove whereas my ArrayList at least get me a win on getting set but it turns out that there's a lot of algorithms that only need to access the front or the end list and so those algorithms do extremely well with the link list because they don't care they could use you know essentially what I was calling a queue or a stack before a list where I can't access the interior where I don't get these operations at all right so imagine I take these operations off the off the board and all I can do is get and set or add and remove at the front now my linked list is looking a lot better okay questions about this before we go on so look you guys now essentially know how this work if you guys went through and you read the implementation of lists in Python or JavaScript or whatever you guys would have some sense of some of the trade-offs that would be made here now let me let me throw some caveats out here just for fun so you know our order of you know our Big O analysis is ignoring like all sorts of interesting things that go on okay so the computer the processor is this incredibly complicated beast and it's gonna start to mess with our own analysis in certain cases so for example processors are really fast at copying memory around and so remember when we were doing those array copies may have to move stuff that turns out to be not as slow as we might think so the creator of C++ actually came and gave a talk here a couple years ago I was talking with some colleagues the other day and apparently he pointed out according to their tests in C++ array lists were actually faster than linked lists across the board just because processors are so fast at copying memory and there's also the thing that you learn about in CS 233 that's called memory locality which means that when you access one piece of memory it's fast to access other pieces that are around it and so when I work with an ArrayList when I'm copying the ArrayList I'm always accessing chunks of memory that were initially nearby in the actual computer memory so anyway you guys will get a chance to think about all these cool complications and caveats down in downstream course right but it's but it's fun there's a lot of subtlety here and to be honest as computers continue to change and evolve this stuff is something we have to revisit a lot right because the fundamental underlying characteristics of computer processors memory architecture memory hierarchy storage devices and supply path all play into these decisions about how to implement these algorithms right that's why we'll talk about this in a week or so that's why there is still you know so you might think sorting is a solved problem there's still an annual competition to implement efficient sorting algorithms that's held every year and the reason is because Hardware keeps changing and people keep up coming up with other ways to do it okay questions about lists before we say goodbye to lists at least in class and sally forth okay let's talk about trees so and the next data start so we're gonna look at in this class is something called a tree this is not the first time you're gonna last time you're gonna hear about trees in fact you may get sick of hearing about trees trees are an incredibly widely used data structure they get used to store all sorts of data they used to as a part of implementing all sorts of different types of algorithms and so start to you know get comfortable with this right so a tree you know essentially emulates a hierarchical data structure to be honest I always feel like we should probably you know I sort of realize this recently I mean we're kind of looking at our trees wrong we always start at the top and go down but it's sort of like your turn to tree upside down or maybe you're looking at the roots right the root node is on top and then the tree grows downward right I have lots of pictures okay so let's let's introduce some terminology here so that we can have you know intelligent conversations about this all right so in a tree I have a tree consists of a set of nodes that are linked by references but there's structure there are rules about this right so every parent so we can refer to a node in a tree as a parent if it has children that has nodes that are below it okay so in this case here's my parent node this parent has three children so the way that working to construct this tree is that the parent is going to have references to each one of its children its shoulder may have references to other nodes so they may be a parent of other nodes okay now here's the here's the important role in a tree this is what distinguishes it from a graph which is a more general data structure so in a tree every child has one and only one parent so if I start at any node in the tree and I walk to its parent and to its parent at its parent eventually I get to this node that's called the root that doesn't have a parent despite remind you a little bit of the object hierarchy that Java uses and that's not a bad analogy because Java does organize objects into a tree where the root node is capital o object so we refer to the node that's at the top of the tree the only node in the tree that does not have a parent as the root a lot of our algorithms we're gonna start on the root and we're gonna work through the rest of the tree by moving downward we're start with the root node then we'll have examine its children then we'll examine its children's children etc all right so here I've got a tree where I have one root node every tree has one root node a single node is a tree doesn't have not a very interesting tree but a single node is still the tree just like a single item is still a list here my root node has one child that node has two children and then this node has one children this is an example of a tree so children that don't have any leaves so if my tree has a finite number of elements which the trees that we work with will if I start at the top and I work my way down word eventually I'm gonna get to a place where I find nodes that don't have any children we refer to those nodes as leaves this is where the tree stops growing all right so a tree can have an arbitrary number of leaves you can certainly can't have more leaves than it has notes depends on the structure of the tree but again with a finite size tree if I start at the bottom start at the top and work my way down word I'm gonna find myself at leaf nodes right so this nodes not a leaf because it has children thus notes on a leaf because it has one child this nodes on a leaf because it has one child this node and this don't have no children for the leads all right well you can talk about the level that a node is at in the tree and we enumerate this sometimes referred to as depth we were numerate this by starting with the root the depth of a node in the tree is the number of steps it takes me starting at the root to get to that node so here I've got again a tree I I've highlighted the root node that's at levels level or depth zero it has two children because it took one step to get to those children there at depth one one of those children has another child so now it's taking me two steps to get to that child it's a depth two and then this leaf node down here is at depth of three so the height of a tree now the height of a tree is the maximum number of steps it takes to get from the root to any leaf node so the height of this tree is three okay it's not one because there's a deeper there's a deeper branch over here that I need to go down okay any questions about this terminology before we go on you know and again I think you know if you think about just sort of you know turning these things upside down the tree growing upwards or these kind of bean like roots descending it doesn't write the tree grows downward right the trees that you see out there then are nice and pretty particularly this time of year they grow up all right any questions about this yeah yeah so the question is like what's the difference between a tree and a linked list so in a linked list every item had one next item in a tree my every node can have one or more children so it's a great point if I eliminate this node here what I have here is a linked list but the fact that this node has two children makes this a tree okay general tree in general in general trees can have in a tree a node can have as many child the children as it wants a lot of the trees that we look at in this class are going to be what are called binary trees where every node has either one or two children zero one or two children but not three or four or five all right but again you can create trees and they're useful and you guys will work with them when you go to do 25 that have Arbit where every node has an arbitrary number of children it's a good question though so this is it's some level of generalization of a list usually don't think of it that way but that's kind of what it is good question other questions about trees before we go on and talk a little bit about why okay so Li let me try to motivate all of this work that we're gonna have a lot of fun with trees over the next couple of weeks particularly writing recursive algorithms to run on those trees I was just gonna you know recursion is one of those concepts that is going to hurt your brain the first time you learn it's gonna give you a mental workout it's not easy to think about it's not easy to get to work we're gonna give you a lot of practice but I'm just warning like I remember I remember years ago taking my second semester programming class and encountering recursion I mean like boo boo you know it just took me a long time to wrap my head around what was happening and trees are going to be our friend here that we're gonna book so what can we do with these things why do we use trees at all what kind of data can be storing them so like I'd hinted that before the Java class hierarchy represents a tree why every node every object in Java has a parent one parent hey if I don't extend something explicitly I get capital object if I do I get whatever I extended but that determines where that node where that class attaches to the tree okay there you know and the fact that I can only extend one class means that this becomes a tree if I could extend multiple classes it would be more complicated it would not be a true but every node has that has one parent except for one node so the root of the java class hierarchy is capital o object it has no parent but it's the only object in Javas type system that does not it's only class of Java's type system that does not have a pair okay so there are you know again you guys are only sort of like subliminally aware of this I think but there is data on your computer does anyone as people are aware of this like your computer stores data like there's data that's there like if you turn it off and turn it back on it's still there and I'm not teasing you about this we I've been talking about with so my colleagues and the fact is that like the world is so different now than when we grew up you know I can certainly forgive you for thinking that all of your stuff lives in the cloud which is not actually that bad of a model right you can actually kind of operate that way today but it turns out that there's actually data on your computer that data is stored in chunks that are referred to as files every one of those files has a name and they're organized hierarchically and the way that they're organized particularly on Linux or UNIX like systems like Max and you know if you have a laptop that runs Linux is into a tree whether they say single root and then the names of the files on your computer all descend from that right so that's another place where we see trees internet domain names all right so this is sort of interesting here's another place where we have a three okay so what's the so so first of all what's a domain name give me an example of a domain name on the Internet you guys use these all the time you probably don't know what they are maybe maybe you do give me an example of one yeah well so those are what are called top-level domains but it's gonna be a full domain name you're on the right track I mean a full domain name the example of one how about dub dub dub google.com so domain name you type it into your browser you had a bit of website right the dots in that separate different parts of the domain name for the purposes of organizing the way that we control domain names into a tree right so a you know the the the person and so the question point out conde d u dot org these are what are called top-level domains that's the first level of the tree those names are at level one the next level for dub-dub-dub google.com would be dot Google the next level is www the reason why we organize these names into a tree is because this also represents who controls the name so there's an organization that controls the dot-coms and the dot edu x' and the dot funds and all the new ones that they just created right so at some point Google had to go to them and apply to get access to google.com but everything after that docs.google.com music Google com I know this is something like a Google Ad right but whatever replace Google with Apple or Facebook or whatever you want all of the names below that are controlled by Google Google doesn't have to talk to anybody if Google wants to put up April Fool's Google com go Google gets to make that choice because that's controlled by Google now right and you can actually create more levels of that so see s-125 dot Csilla noise edu dot edu is controlled by this organization at some point Illinois applied and they got access to use Elinor wait for the University of Illinois even on campus though so CS dot C s those domain names are controlled by the cs department so if i want one of them which i did like two years ago i just go down the hall and i talked to someone who works in the building i say hey can i get CS 125 dad Siesta illinois daddy do and they were like yeah sure right so this you know the the the structure here represents how the domain names are managed and you know we find a lot of data in the world that has this sort of hierarchical structure right because the hierarchical structure in java allows me to inherit and determine what a class does what properties it has you know for your computer it allows you to name files to organize them at the folders and stuff like that and on for an Internet domain names it represents the control right so as you go from the dot edu to Illinois to dot CS you're going from you know a group of people that I've never met who control who gets access to Don edu to a group of people that I know on a first-name basis who control dot cs right all right so and again it is just some extra pictures so here's the you know example the Java class hierarchy here's what it looks like it's a tree right here's files on your computer yeah at some point we guys get into 225 or 126 you guys will maybe start poking around you've seen a interface your computer called the command line that allows you to look at all the files on your computer and they're actually this isn't all the files on my computer but this is a snapshot of them they're organized in this way they end up organized into a tree and then again like I said domain name the way the domain names are translated right so both CS 125 dot form and dot CS are both domain names that I got by talking to somebody who works in this yes Department who controls all of this space so if you want to put something in front of dot CS you know who to talk well it's a little confusing about domain names and actually some of the people that design this system said they always regretted that they're backwards right so you could have typed comm Google dub dub dub and that would have been also okay right that makes a lot more sense it's like top down right but they're all reversed right so the more general part is at the end the lower part the leaf is at the front the root is at the end all right so the data structure we're going to work on this in this class is known as a binary tree so a binary tree is a special case of a tree where each node has one or two children or zero zero one or two children at most two children here's how we are going to represent our tree data structure and this is kind of cool actually right so this is my tree class and it consists of three references three instance variables every node in the tree we want to be able to store data in it a lot of times when we when we work with trees in this class we're gonna be concerned primarily with examining their structure but trees store data examining again you know for example the tree that stores all the different domain names on the internet is used all the time every time you go to an address in your browser so we need to store information about you know the domain names that the tree represents so just like my linked list item class I have a value I have a reference to a value and then I have two references here now I could have like a list of references or an array of references but with the binary tree the nice thing is I know that I'm only gonna have 0 1 or 2 and it's also helpful to name them right so I'm gonna name them right and left so every nodes gonna have either a right child or a left child or both or 9 I represent not having a child by this reference being know so if my right child is now I don't have a right child my love child is no I don't have a left child if both are no then I'm a leaf node I don't have any child okay so so this is what we're going to work with and when we when we look at these graphically well also that's where the right and left comes in handy as well because that'll refer to which side of the parent that node is hanging off right it's a right child hangs off on the right left left okay so now here here's where we get to make this cool connection with recursion as an algorithmic technique so let's just start with an observation here if I look at this tree and this is also true of Lists but I want to point it out with trees every subtree of this tree if I break off a part of this tree it's a tree okay so no matter how I break this tree into smaller pieces the pieces that I end up with are themselves trees so here's an example let's say I just look at the left subtree of the root so the root here is the node with value 1 its left subtree is the subtree that starts with the node with value 3 okay it has a single child and then its child has a couple child but this if you just like squint a little bit and only look at the blue nodes that's a tree it has a different route rather than Route one I have a an object with root three value 3 instead of having let's see 3 6 9 nodes I have 4 nodes but it's still a tree okay if I look at Three's subtree so I have a look at the subtrees of 3 there's only one because 3 only has one child this is also a tree again it's a small or treat here's the other thing that's cool about this the trees are getting smaller this is going to be really helpful for us when we start to write over corrosive algorithms so I win from having a tree with 9 nodes now I'm looking at a tree we're didn't note for that has 3 nodes and I can keep doing this a single node is a tree so now I've reduced the problem to a tree that has one no truth one node 8 is also a tree okay with one node now I could start down the other side and do the exactly the same thing so the tree that's the the subtree of the tree rooted at node one that's rooted in node five is itself a tree I could consider it completely separately it's a tree with four note and then the tree root it's seven it's a tree here's a tree here's another tree so as I descend into this tree what I did was I started out with the problem where you know I had nine nodes that I needed to think about a nine node tree and I reduced it to a series of problems where I was only thinking about one tree a one node tree and you can see this in the definition of our tree class so recursion the actual definition of recursion you guys are going to come up you guys are gonna start to think Veron I don't want you to think narrowly about recursion recursion is a very broad set of ideas and problem solving techniques recursion is not when a function calls itself that's an implementation of one possible implementation of a recursive algorithm you know recursion is not even an algorithm recursion also can be used to describe a data structure so recursion occurs when something is defined in terms of itself look at my tree class my tree class and again this is the same thing was true for lists we just didn't stop to point it out my tree class says that a tree consists of one value and then references to two other trees all right so this is a recursive data structure in order to define it I have to continue to try to define alright so it's defined in terms of itself I have references to myself here as part of the definition and that's why this is true right because if you think about it if I'll go all the way up to two to my first node node one is going to be if I represented this in Java use in this class node one is going to be a tree where the object the value is going to refer to an object like the integer one but then it has a tree a reference to a tree that's its left subtree and a reference to a tree that it's right there so this this sort of hopefully these two things connected together make it very clear how this workers of definition so so again you know recursion as an algorithmic technique is a way of decomposing the problems so that what we do is we take a big problem and we break it down into smaller pieces those the solution to the big problem depends on the solution to the smaller pieces but we keep doing this until we find problems that are really small where the solution doesn't depend on smaller pieces and then we reconstruct a solution to the larger problem that probably made very little sense so let's see some examples about how to do this but so far let me let me distinguish between what we've done before so what what one of these we've done before the things the ways that we've approached problems sometimes referred to as iterative okay we have looked at iterative solutions throughout this class but you guys did what you're doing with the linked list right now when you're walking through it that's an iterative approach to walk in a list there's also a recursive way to get to every item in a list I don't teach that because I don't think it's very useful I think the better way to go through a list is to use an iterative loop it's also a great chance to practice with references trees on the other hand are a great fit for recursion okay so with iteration what I'm doing is repeating the same steps over and over again until I'm done with the recursive solution I'm breaking the problem to smaller and smaller pieces until I find one that is small enough that I can solve it easily okay so let's talk about counting one of those basic things that I probably want to be able to do with the tree is to determine how many nodes does the tree have I want to count the number of nodes in the tree all right so if I was approaching this problem iteratively what I would need to do is I would have to find a way to visit every node in the tree so let's say I give you a reference to node five which is the root the node with value five and then if I can write a loop that goes through all the nodes in this tree one by one then what I can do is I can just keep a counter inside my loop and I just incremented every time and I'm done when you guys implement size for length list this is how you're going to do it right and so I can do this I could basically you know now here's the trick with trees though here's what I want to warn you about at some point maybe in a few classes once we've had some practice with recursion try to write this loop okay it is not easy it's not impossible you have to use some other data structures and stuff like that it can be done but it is not natural it's not going to be as nice as you think it certainly is not gonna look as nice as that length list for loop that we wrote that one's nice the reason is every item in a linked list only has one item after it here I've got cases where I've got two items so how do I handle that yeah like I said at some point we'll come back yeah or I'll give it out I'll leave this as an exercise to Melissa to come back and try to so how would we approach this problem recursively okay so the trick with a recursive algorithm is to make the problem smaller and then do that until I have a problem that's so small that it's so easy to solve and then try to figure out how to combine the results from my problems all right so here's how I'm going to approach this for County we'll come back and we'll implement this on Friday together so I want to break the problem down into smaller pieces so how do I do that okay so this is my in general this is our pattern for recursive algorithms break the problem into smaller pieces continue that until I find a really small problem that I can't avoid solving and then combine the results together in a way that's appropriate to the problem I'm trying to solve alright so here's what I'm gonna do you gave me a tree you gave me a reference to a tree rooted at node 5 I know I can make this problem smaller and here's how I'm gonna consider the left subtree of 5 and the right subtree of 5 to be smaller problem so some time let's say look know how to count the whole tree but here's what I know if I could count the left sub-tree and if I could count the right subtree and if I knew how many nodes were in the left subtree and knew how many nodes in the right subtree I would know how many nodes are in the tree right because it would be left + right plus one for me okay so essentially I'm saying I don't know how to solve the problem but I do know that if I could solve the problem of counting my left subtree and solve the problem of counting my right subtree then I would be able to solve the problem okay so now here's what we do we just start over on the left subtree we pretend that it's the only subtree in the world so now I say oh we know what if I could only count my left subtree I don't even have a right subtree if I could count my left subtree I would know how many nodes are in this tree because it would be the number of my left subtree plus me plus 1 I write some trees empty so now I start them over I start the algorithm over again and now I pretend that the only tree in the world is the tree that's rooted in node 7 ok now what do I need to do I made the problem smaller I made the problem smaller now I met a problem that is so small that I have to solve it this node has no children how many nodes are in the tree rooted at node 7 1 I know I know the answer right so I finally found a problem that's so small that I know how to answer it okay but remember I'm going to keep doing this and my other subtree so I'm gonna say okay if I could figure out how to count the left subtree of 10 and the right subtree of 10 then I would know how many nodes are in the tree rooted at 10 because it would be left subtree plus right subtree plus 1 and again now I'm in a leaf node so now I know how many nodes are in this tree now I go over to node 1 I'm again in the leaf node I know how many notes are in this tree so now what I start to do is combine the results so remember 3 said hey if I could count my left subtree I would be done because I would know how many nodes are in that tree and Ted said hey if I could count my left subtree and my right subtree I would also be done the cuz I would add myself so now what I'm starting to do is is integrate the results back together bring the problem back together I broke it down til it was really easy and now I'm combining the results so now I know how many nodes are in the left subtree of node five and I also know how many nodes are in the right subtree of node five and again where I started at the very beginning is node five said if you can count the nodes in my left subtree and the nodes in my right subtree I know how many nodes are in the tree and at this point I do alright we'll pick up here on Friday and we'll write some code to solve this problem I do not have office hours today I had them on Monday good luck on the midterm if you're taking it today I know many of you are I will see you guys on Friday stay dry  
﻿ so today we're done with trees we're gonna do a few more problems with tree recursion but then what we're gonna do is we're gonna move on to the next set of challenges it's going to occupy us for the next week which is sort of a classic problem in computer science it turns out actually to be at the heart of a lot of really interesting systems and a building block for a lot of other important and interesting algorithms and that's sorting so how do we take items and put them in order and sorting is a fun thing to talk about it's an easy thing to understand conceptually what the goal of sorting is but there are lots of different sorting algorithms and even though we know we can prove and I think you guys will actually do this you can prove in CS 173 or maybe if you go on and take CS 370 for the worst-case performance of a sorting algorithm good there are still new sorting algorithms being developed because the best-case performance or average case performance is kind of up in the air right so even though we know that you know the best sorting out of them can do do no better than a certain performance given if I am allowed to pick the inputs in practice we still see new sorting algorithms being developed and in fact the default sorting algorithm for now Java and Python and I think a variety of other languages was developed within the last 20 years which is you know you may think well I'm only 20 years old so it's not that exciting but that's actually you know for a problem this is classic is sorting that's actually a pretty new owl okay all right so let's finish up what we were talking about at the end of class on Wednesday so what we did is we went through this recursive tree algorithm right and here was our recursive approach for searching all right so the goal of this is to return true if the item exists in the tree and false if not and remember here's our sort of recipe for building recursive algorithms on and particularly recursive algorithms on trees although this will work for other types of data structures and actually today we'll look at a couple of other recursive data structures that you can actually build recursive algorithms on top all right so our recipe here is first of all identify the base case so when is the problem so small that we have to solve it and with our recursive tree search you know essentially the base case here is if I've reached a node with no descendants or really if I've reached an empty tree so if I walked onto an empty tree because I walked off a leaf node or I walked off one side of a node that didn't have a descendant I know that that at that point that treat is not to contain the node I'm looking for because that tree contains no note okay so there's my base case a recursive stop is that I'm gonna consider my left and right subtree separately and again remember one of the goals of my recursive step is that I always have to may be making the problem smaller if I don't break down the problem make it smaller at every step what's happening is I'm actually not making any progress in solving it right recursive algorithms solve problems by breaking them down into smaller pieces until they're so small that they're easy to solve but if my recursive step isn't creating smaller problems then I'm actually the rehearsal algorithm is not going to work right and here with trees the nice thing is I know that at any given node the right subtree and the left subtree represent smaller problems because each one of those sub trees has fewer nodes in it than the tree that's rooted at the node that I'm at okay alright so my recursive step is to look at those together and then the Comedie the way that we combined results here was interesting right so here the idea is that I'm going to use a logical or because essentially the value is in the tree if I contain the value if the node that I'm starting at I'm currently examining contains the value or if it's in my left subtree or if it's in my right subtree right so that's how we combine our result together right so I'll just reproduce this again quickly for us it's practice so as as usual we're going to use a private function and we have a public function and we're gonna use a private we're gonna essentially call into a private function to bootstrap our search on the root node so we're gonna return search of root and then we need a private wrapper again we did this last time so I'm just kind of kind of speed through it that's gonna take both a value and a node to that I'm currently considering so my base case is if current is null then I've reached an empty tree the empty treat us and contain the note otherwise I say if current value equals value so I have so and remember how this short-circuit evaluation is going to work if the current node that I'm examining contains the value I don't have to look anywhere else and what will happen is if I contain the value I won't proceed down the other branches of this or statement because of short-circuit evaluation Java will know that the whole statement is true and it will stop all right so if I contain the value and then I also have to look in my left and my right subtree so I'm gonna restart the search on current out left and I need to also restart the search on current dot right all right so and and this this statement really contains both the recursive step and the result combination together this is pretty common it's what the cursive step is the fact that I'm looking at my right in left subtree the combination of results is that I'm using a logical or to say the value exists in the tree if either it exists at this node or if it exists in my left subtree or my right subtree all right so let's see if this works no Chuck Styles angry at me again about something I think I would have fix this earlier but I didn't I don't know why there's a tab in there there's still a tab see there we go okay so something went wrong here what happened here guesses what did I do sir there's a bug in this clearly so what did I do wrong yeah ah yeah so whenever I use the wrapper function I have to be careful that I'm actually calling the wrapper function so what's happening right now I didn't plan on making this mistake but you know people make mistakes including me so what's happening I'm calling the wrapper function the wrapper function is calling and this is tricky the wrapper function is calling search on the root node but there are two remember how Java distinguishes when you overload a function I have two versions of search I have one that takes two arguments where the first is an object reference and the second is a node reference I have a second function that takes one reference or the reference is an object reference but why can I call search with root root is a node right so why is it calling itself over and over again here instead of calling why isn't been an error I would hope that there be a compilation error here but why is this okay what's happening here this is good review of object references so Java compiler and runs this code clearly it doesn't do what I want what's happening yeah yeah why is it doing that so I'm calling search and I'm passing a node so I would assume that the compiler would say wait there's no version of search that takes one argument that takes a node reference what's happening here automatically yeah yeah node like everything else in Java can be up cast safely to an object so what's happening here is that when this code is compiled the compiler is saying okay let's find a search function that takes one argument you're passing me a node okay I don't I don't see anything that takes one argument except this function that takes an object and I can safely up cast a node to an object so that's what's happened so here what I need to do is I need to actually pass my value down and now I think things are working out okay so let's try some things here let's try a value five and make sure it's false let's try sticking some more values in the tree now that should be true let me try something that's let me try something that's at the root so again if you were when I do this sort of thing in class I'm thinking like how would I write test cases for this if we had to if you guys did this is a homework problem I would say okay let me make sure you can find something that's a leaf node let me make sure that you can find something that's a root node let me make sure that you do the right thing when I give you an empty tree okay so and and here's the thing that we saw right and this is sort of just like a little bit of so when you guys get on to 225 you're going to learn more about trees than you probably care to trees are this entire really interesting family of data structures that you'll learn more about there are you know we've been looking at binary trees they're trees that are not binary they're red black trees there are binary search trees which we're gonna look at in a minute there are all sorts of different trees that have different trade-offs and different properties and you guys will learn about some of these downstream but let me show you one of them so you know where we left off last time as we said ok so so here's the here's the problem in the in the best case so we don't always have to search the entire tree that's kind of nice right on if the value is at the root node then my search is only gonna is going to stop as soon as it gets to the root node and that's because I'm looking at the current node first so what happens if the root node contains the values so search calls into my search function at the root node it says roots not know and then it says does root dot value equals the value I'm looking for if the answer is yes I'm done I never get into the right or left subtree let's let's uh let's make this explicit so let's do a just for fun here let's put a let's put a search count now let's make this public to zero and then every time I start my search function will initialize search count to zero and then every time I enter a search I'll set search count plus plus and in fact let's only increase it when we're actually at a node so let's say search count plus plus and then when I'm done I should also be able to print the value of the search count variable okay so here can we have one conversation please ladies hi I'm up here Thanks all right so if the tree is empty right then clearly you know there's no work to be done all right but let's put some nodes in this tree and see how many steps it takes to find things so let's say 1 2 3 5 7 8 ok so now I only had to run this once why because the node I was looking for was the root node and now let's look for something that's deeper in the tree okay so now it took me how many nodes are in the tree 6 so here I actually had to search the entire tree before I found the note I was looking for that's going to vary a little bit because we're building the tree randomly so sometimes I'm gonna have to look through the entire tree other times 8 is going to end up like in a subtree and I'm gonna find it more quickly but if you look and I run this a bunch of times you'll see sometimes it's gonna be 6 sometimes it's gonna be 4 it bounces around a little bit but I still have to look through a lot of the tree to find this and the reason is that 8 is a leaf node now how many steps azar gonna take me to find something when it's not in the tree all right let's look at something like negative 1 well there it's always going to be 6 it's always going to be n where n is the number of nodes because until I look to the entire tree I can't be certain that it doesn't contain the value I'm looking for all right so here's the question how do we how could we make this more efficient and here what we're gonna do is we're actually going to not just so to beyond you know the answer is there is no way to make this search more efficient without changing the structure of the tree ok so given the type of tree that we're working with whether there's no organization into where things are put there's no way to make this search more efficient think about it if I'm looking through the tree and the tree has no structure items can be anywhere then it's like a it's like an unordered list or an unordered array I have to go through the whole thing before I can be certain that a value is not in there and actually when we talked about sorting later in the class one of the reasons why sorting is such an important building block of so many algorithms it's sorting can make searching a lot more efficient when it's done on arrays and other flat data structures like lists but here we're dealing with the tree so the question is what can I do to make this search more efficient and again the thing I have to do is going to involve two things I have to change the structure of the tree and then I need to exploit that structure in my search Agra so here's the the key observation here all right this is also an interesting place where we can start to see some runtime behavior that falls into complexity classes that we haven't looked at yet all right so the key line here is on line 61 and you'll see that this line always has to look in three places the current node right subtree and left subtree what if we could build a binary tree in such a way that I knew whether or not the node had to be in my right subtree or my left subtree so I don't have to search both I can just search one I can essentially say okay well I know the node has to be in my left subtree so I'll only look there and so what's going to happen is I'm not going to start the search algorithm going both directions I'm going to know which direction to go and again this involves a change to the structure of our tree right if I want to know where to look when I search I have to have some rules about how things get added to the tree and then a glorious moment of confluence this also brings us back to our friend comparable so remember when we worked a little bit with the comparable interface I promised you that the ability to put two things in order is really powerful right we're gonna use it when we sort stuff anything that I can any two items that can be put in order can be sorted in a list I can also use this to build what's called a binary search tree okay so now my my search tree so I've changed the name this is a binary search tree let's go through here and look at the differences a little bit I still got a node class but you'll notice that my node class is a little less general than it used to be it used to store a reference to an object so I could put anything in there now it starts a reference to an object that implements comparable so this search tree can only be used to store items that I can put in order if you can implement compareto you can be put into a binary search tree if you cannot you can't and so there is the trade-off here this tree cannot store every type of Java object it can only store ones where there's a meaningful notion of comparison you have to be able to put two things in order to be contained in this tree all right other than that things are you know the node class is pretty similar okay my my constructor is not that different essentially what it does is it takes in terrain it just adds the item to the tree one at a time but now and and I have a public add method which takes something and I have it calls into my private add method the add method is still recursive right it essentially says I try to add the node here if I can't do that I pick a right or a left subtree but here's the difference okay before when we added a note to the tree we picked a right or a left side randomly we essentially said either put the node here more choose the right subtree or the left subtree of the current node and try to add the new value to that subtree and that's why values could end up anywhere in the tree so I could build two trees with the same list of elements and I would get two different trees because I'm making this random selection every time here I'm not doing this randomly anymore right there is structure to it so what you're will see here right here is that if the new value is greater than right if current dot valued up compared to sorry if it's less than or equal to right if current Dada valued up compared to and I can click Hall compared to because every value in the tree is comparable so if it compares to the new value at if it's greater than zero I go right and otherwise I go left so now what I'm doing is I'm building a tree based on the properties of the elements that are put into it so with this tree building algorithm if I build a tree twice with the same list of elements I will get two identical trees because I have a rule about where things could put now I want to be careful about this if I build two trees twice with the same elements but in a different order they're added in a different order I get two different trees ok the order in which they are added matters but if I build two trees with the same elements and they're added in the same order I get two identical binary search trees because again I have a rule now about where things get put any questions about this before we go on all right so I think it's instructive let's go back here and look at this guy so here our add method right I wish I had these side by side right so here our add method on line 27 I'm randomly choosing the right subtree or a left subtree okay here I'm not I'm making the choice based on the value of the node that's being added questions about this right okay so here's the cool thing I can now take advantage of this when I search through the tree right because here's the idea before if I didn't if the if the so you think about our recursive algorithm I look at myself do I contain the value if so I'm done right that's not different that's the same in both cases right so if the current node contains the value I return true but what's different here is that if I don't contain the value I know how did this I can decide whether to look in my right subtree or my left subtree I know where the new value should be if it's in the tree at all right so I can essentially say if the value is greater than me look in the right subtree if it's less than me look in the left subtree or vice versa it doesn't matter right the thing that's important here is that our search function and our constructor agree about where values are so for example I can change the code up here to be less than or less than or equal to it doesn't matter what's important here is that our add function in our search function agree upon the rules about putting items into the truth all right so let's give this a try we have again the interface is the same right I have a search function so let's go ahead and what happened here right okay so this is nothing that's the new problem so let's let's do the search problem that's a fun problem all right so I'm gonna write my wrapper my wrappers gonna take a value and a current node okay and now let's just return false and let's have our search function call search with the value and the root node so I'm gonna make sure that I oh I have to return the result of this couldn't make sure I don't make the same mistake I made last okay so now let's just make sure this is working all right this is false not supposed to be false okay let's go back and let's reconstruct our recursive algorithm so if current is equal to null I return false I know what to do this means that I found an empty tree either the tree itself has no elements root is no or IRA cursed you know off a leaf node or off the side of the tree somewhere okay but all I mean again simple concept empty trees contain nothing right so they will never contain to know I'm looking all right so otherwise I want to do the following so I essentially say if current dot value dot equals value then I'm going to return true that my colon still needed so if I have the value I'm gonna return true stain but now I can make a better choice about where to look okay so here's here's what we're gonna do we're gonna say else if current doubt value dot compare to value and now I'm gonna now I'm gonna look up here at my add algorithm right so this says if the value is if current add value doc comparative value is greater than zero then the value is going to be in my right subtree so I'm gonna use that same piece of code return search value current dot right else returns search how are you all right dot left I get mixed up about this stuff sometime so it's possible that this is backwards but let's test it and find out okay so again notice something about this I will never look in both my right and left sub trees I'm using the relationship between the value at the current node and the value I'm looking forward to decide where to look should the value should I look at my right subtree sure look at my Lobster okay no it's angry about something okay it's this yeah okay so that looks like it found value let's make sure that it's not finding things that shouldn't exist okay all right so this found a value that found it back okay so this seems like it's working all right so so far doesn't seem very exciting right essentially I've just reimplemented the the same search algorithm I had before right in the sense that it still worked right but what we want to do is we want to look at the performance here let's do this again let's make our search count and we'll set that to search yeah search it's equal to 0 and then incremental here it's pretty a little bit of instrumentation here and we're done we're gonna print okay the other thing I'm going to do here and this isn't this is important is I'm going to change the order in which nodes are added to the tree and I'll come back and talk about this in a sec let's see here okay so I've got a little bit of a different tree here right okay so let's actually look for something that's not in the tree all right let's look for negative one okay so this is cool right about the results correct right the don't sound in the tree but look I only had to look at two nodes right before I had to look at I would have had to look at five let me put one more value in here alright or six here I only have to look - all right let's try to find a node that's deep in the tree like node eight okay so this one should return true how many steps is big in this case it takes five right it turned out that actually needed to look through almost all of the nodes in the tree right and this is because I built this tree in a dumb way so let's do this okay now it's four I don't have a picture of this but it really depends on what the structure of the tree is but in general the number here is not going to be n I'm gonna find things quicker right I'm also gonna find out that things don't exist a lot quicker right which is really useful right so any time I'm going to search for something that's not in the tree I'm gonna see that it's going to take a smaller number of steps okay so let's think about this a little bit let's do some out let's just just do some you know algorithm analysis of binary search now this again I I really should've had some pictures here I'm not really prepared to talk about this in the useful way but let's let's think about the thing about the thing about a tree that's what they call balanced so it has the same number of nodes on one side is on the other side you looked at it it looks like a tree alright it's got a bunch of like a nicely balanced fall tree okay if I'm searching through that tree using this algorithm what's the run time let's imagine you're looking for a value that's not in the tree okay how many steps is it going to take so with our normal search tree what's the run time for looking for a value that doesn't exist in the tree the tree has n nodes then the run time is good question with the search trees that we've been working with so far if I search through the tree looking for a node and the node isn't in the tree how many nodes so I have to visit yeah and because the nodes are all over the place right I don't know where things are so I've got to go through every single node before I find the one that is before I can convince myself that it's not there okay now here's the challenge problem with the binary search tree how many nodes in the best case how many nodes do I have to look through before I can convince myself that the node isn't there this is tricky yeah log and ok interesting so that's one of the complexity classes we haven't thought about yet and that's correct so let me tell you why so remember how recursion is making the problem smaller okay and that's exactly what's happening here so imagine that the tree has n nodes in it I start at the first node and I look at it and it doesn't contain the value because this value is not in the tree then what I do is I can I pick the right or the left subtree to look at I don't look in both so after the first step I've gone from n nodes to n over 2 and I continue this and then after the second step I go from n over 2 to n over 4 and I continue that and I'm gonna go to n over 8 every time I'm making the problem half as small and if you repeat those steps over and over again the runtime that you get is log right this is why when we talked about complexity classes be pointed out that log N and n log n are both characteristic of recursive algorithms because the log n part is the result of making the problem smaller half is small roughly so with the tree if the tree is set up properly I'm making the problem half a small each time ok I think I've said as much about this as I can without a better picture all right so let's let's do something else well let me see here I'm gonna come back to this if we have some time at the end and we'll do the recursive tree traversal with Lisp which is fun all right any questions about this before we go on that's a fun example but I think I I got distracted by how cool binary search trees are you guys will see them again they're they're super useful and one of the things you'll do in 225 is you'll spend a fair amount of time figuring out how to preserve that nice property that they have of log and search because it turns out if I build a tree if I build a binary search tree badly I can get oncb havior instead of log n okay so up until this point we've been doing recursion on trees and trees are a really nice fit for recursion and hopefully I'll get back to the problem that I just skipped over at the end because that's a problem that's designed to convince you that I can essentially convert a tree into a list and then I can use an iterative approach to solving a problem right but trees lend themselves very well to recursion but they aren't the only recursive data structure that we've seen so we talked about the fact that one of the things that makes trees nice for recursion is that every subtree of a tree is itself a tree so essentially if I'm at a node and I look at my right subtree and my left subtree separately I can restart my algorithm on those sub trees and it can behave identically because they're trees right they're smaller trees but they're still trees okay what other data structures fall into this category so we've talked about trees every subtree of a tree is a tree there's a couple of other data structures that I can stick in here that have this property where it's like if I take them and I tear them apart I get two smaller pieces but each piece is still a valid data story yeah an array yeah I remember a raise so if I take an array and I break it in half and I have two smaller all right so I've got two smaller arrays they're both the Wraiths so arrays are recursive data structure Wells something else that we worked with a couple weeks ago it's kind of a generalization of an array lists same thing listen arrays here you can think of it's basically interchangeable right I can take a list and if I break it into two contiguous pieces what I have are two lists and if you think about it what was nice about trees the two sub trees were smaller if I break a list in half the two halves of the lists are both smaller than the original list so I've made the problem smaller by breaking a ray in half the two halves of the array are smaller than the original ray and so you can actually do recursion on lists right so we didn't do this this way what we did is we said let's use lists to give you guys practice at working with references and doing iteration using reference following all right that's that for loop that we wrote to walk through a list a linked list but I can also write recursive algorithms on a linked list so let's say I'm doing search all right let's say I just want to you know count the number of nodes in a list right well we did this for a tree what we said is the number of nodes in a tree is 1 plus the number of nodes in my right subtree plus the number of nodes in my left subtree before the list it's even simpler the number of nodes in the list is one for me plus the number of nodes in whatever list follows me right so it's 1 plus the number of nodes in the next part of the list and if I continue this process eventually what I can do is I could write a recursive sized algorithm right so again if I'm at item 6 item 6 is like I have no idea how many nodes are in the list but I know that the size of the list is 1 plus however many nodes are in the list that you know is after me so if you count the number of nodes in my next after me right and add 1 you get the number of nodes on the list and item 5 says the same thing it's like hey I have no idea how many nodes are in a list either I'm just kind of here hanging out in the middle but I know the number knows then list is 1 plus whatever is left item 8 says the same thing you get to item 0 and item 0 is like wait I know how many nodes are in the list it starts with me because my next pointer is no my next reference ah my next reference is no there's no list after me so there's one note in this list right and so then I could go back up and I could essentially solve the problem right because 8 now knows how many list notes are in the list after it 5 knows how many notes are in the list after it and 6 those hot many notes are in the list after it and that's what I wanted to know the number of nodes in the list ok so you know again with lists what we do to make the problem smaller is we break it into the current node and whatever nodes are after it it's similar to right and left subtree except I only have one subtree right it's like only having a right subtree the smallest sub problem is either an empty list or a list with the single element so you can imagine if I was searching a list once I get to know I know that the list doesn't contain the element because it's an empty list right I can again it so I can do the same thing with arrays and this is more important for us to understand because this is actually a technique we're gonna use I am NOT gonna ask you to do recursion on lists I just think that it's not you know you could try it right and it'll work and it's actually a nice way to compare the two approaches right but we are going to do recursion on a rings so this is important to understand so again imagine I take an array and I done and I absorb the fact that every contiguous part of the array is itself an array so let's say I was looking for a value in this array what I can do is I can break it I can break it into its left and right sub arrays and then I can break its left and right sub array into its left and right sub arrays if I continue doing this until I get to an array that only has one element and then it's trivial to figure out if the element is in the array right I just look at the one element in it I say is it equal to the element I'm looking for and I can again build up a solution to the complete problem from these smaller subproblems in a way that's very similar to how I did with trees and in fact there's actually a really nice mapping and I think again you guys do some of this in 225 between trees and arrays you can kind of look if you look at it you kind of see what we're doing you can kind of feel like I can organize the nodes in an array into a tree and what I'm looking at is kind of the process of recursing down the tree into the leaves which is where we are now and then building up solutions to the larger problem by combining the solutions that I get from the leaf nodes right so again raised just like lists just like trees how do I make the problem smaller I break the array into two smaller arrays the smaller subproblem is either an empty array or an array with a single item right that's an array that's easy to search it's in a way that it's easy to count how do I build the problem back up I sort of combine the results in the very same way okay all right hopefully I've convinced you that this is a more general technique questions about recursion yeah yeah so the question is what happens if I have an odd number of elements so you know imagine that negative one wasn't there then I would just get to seven and then I would just start up you know I basically start combining results right yeah yeah that's a great question we'll do this with we are going to implement recursive sorting algorithms on a race so you will see this and that will some of them will have odd number at all good question other questions about recursion before we go on and I introduced the next topic zit we're done with recursion you guys have some homework problems love to do I think the next couple homework problems are fantastic I hope you guys enjoy them you know it before just came out this is a good time to challenge you guys but a little bit of harder harder homework problem so the next few days.there but they're super fun okay so sorting so this is now what we're going to talk about for the next week or so sorting okay as I said before sorting is a really fun problem it brings together things that we've worked on a variety of different things whether it's interfaces algorithm analysis recursion sorting algorithms are also really involve some imperative programming a little bit tricky we just brought time analysis we're gonna do recursion so you might feel like sorting is a solved problem or something that's not interesting but it turns out that sorting is a building block for lots of other really important algorithms okay do you think about all the data that Google or Facebook or Microsoft has stored away about you a lot of the way that they access that data efficiently is by sorting it in some way once I have data that's sorted it's much more easy to find things so there's the famous example that my old graduate student colleague David Malin does with the tearing the phone book in half think about how you would find a name in the phone book if the names weren't sorted right like good luck take you weeks actually it's a good question has anyone here ever touched a phonebook before like a real phonebook how many only a handful okay yeah I know it's sort of an old thing these do it like you used to like get them they used to come like they would would you know you'd be sitting at home one day and you'd hear this massive thump and it would be this like six inch phonebook that the phone company would bring I'm not even sure they actually hand them out anymore anyway but the point is that by sorting the data in the phonebook I make it easier to search and so maintaining a sorted list of phone numbers is something that's important for building other albums right maintaining Dana in a sorted format makes it much easier to work with search and to perform other types of algorithms right okay so again searching it's way more efficient if the data is sorted story it can be used to do things like duplicate detection so if imagine I've got a data set that has come from a bunch of different places and I'm trying to find to do items that are the same if I sort it those two items wound up next to each other and then I can remove the one that's extraneous sorting is also something that's used to present data to people right we like to see data in sorted form because it helps us understand it right it also helps do things like identify trends right if I take a bunch of data from the stock market and I just throw it up on a graph and it's not sorted by time it makes no sense if I sort it by time you might be able to see trends and see the impact of various events that have gone on the financial markets or whatever so again this is important enough that there is a still there's still you can see from this webpage there's still an ongoing yearly challenge this is called the sort benchmark so apparently this year's deadline is passed but again this is 2019 and there's still an active sorting competition that's being run you guys can enter this if you wanted it's kind of cool so they have different categories I'm not going to go through all this in detail obviously but essentially the so first of all this is a competition for sorting massive amounts of data right which is a problem that still b-doubles a lot of big you know companies that work with data there's a bunch of different categories here and I can't remember what they means but I so for example minute it's like how many records could you sort in a minute and then I think there's some limits on the type of computers you can use in stuff like that right there's all sorts of rules about this if you want to enter this but you'll see let me let me look you know some of these records were set like fairly recently so 2016 looks like 2016 was was a good year for sorting records but they're still running this right people are still trying to make this make this better this I have to stop here mention Jim Gray when we talked about sorting so the sort benchmark one of the cop categories is named after Jim Gray Jim Gray was a Turing Award winner he did a lot of really foundational work on databases and data processing and in a really sort of tragic finish to his life he vanished at sea I don't know if this is probably before your time but there was actually an international effort to locate him or a bunch of researchers crowdsource the problem of going through lots and lots and lots of satellite imagery looking for his boat sailed out of San Francisco Harbor one day and and never never came back anyway he has it has left a massive legacy on the field also one deterring over all right so there are a gazillion sorting algorithms out there that's one of the things that makes us a fun problem to talk about we're not going to talk about them all we'll get started on Friday looking at some simple cases and doing analysis of something called insertion sort you guys will see selection sort in lab it's another approach next week we'll do merge sort which is a recursive sorting algorithm so that'll bring together a couple of the things that we've done recently there's something called heap sort there's something called quicksort which we will talk about quicksort is an example of a sorting algorithm that has really interesting behavior it can perform very well given certain data that can perform poorly given other data sets so quicksort is an example of a sorting algorithm that has sort of pathological behavior in certain cases right bubble sort you guys will look at in lab and again so Tim's sort Tim sort is a sorting algorithm it's named after Tim Tim invented Tim sort Tim sort is used now in Java Python and a bunch of other programming libraries as a default sorting out was developed in this century 2002 this is kind of cool we're still developing better sorting algorithms even after people have worked on them for decades and decades ok so let's lay some ground rules for our discussion of sorting we're gonna talk about sorting on a race a race around random access with a one performance ok the algorithms that we look at will can be applied to things like lists any type of ordered linearly ordered data structure ok in general and again these are just like our constraints we're gonna sort things in ascending order that's not doesn't express any view I have about the world it just is a convention that we'll use right we're gonna put things from in order from smallest to largest but of course you can apply the same algorithm and reverse that sometimes you want the largest I used to beginning so most of what we're going to talk about is sorting integers but you will have some problems where we'll ask you to sort comparables and again this is what's cool about Java interface system anything that it's comparable can be sorted any place where I can put two items in order I can sort when we look at things in class just to keep it easy the examples that we use will have integers in right because you guys are used to thinking about integers okay when we analyze sorting algorithms we're going to talk both about time complexity but we also talk about space complexity because sorting albums deal with large amounts of data and so sorting album that's faster but requires twice as much space in the computer's memory may not be appropriate particularly if your Google and you're like I've got 8 trillion records that I need to sort that sorting algorithm may not be okay so we'll talk about how long sorting algorithms take and we'll talk about how much memory they need to run to complete ok any questions about this I don't have enough I think I'm talked about the fair on Friday I'm not sure I have enough time to talk about it today so we may God get out of here a little bit early unusual I know all right any questions about sorting or anything really I will talk about the fair on Friday just a couple of announcements today and before us out get started on it those of you that are working on it I hope a lot of you will choose to do it it's a really nice MP that brings together everything you guys have done this semester it's a really nice empty check point right it's the final step I have office hours today from 1 to 3 I hope you  
﻿ [Music] right so today will conclude our discussion of sorting which is something that's consumed us over the past couple of classes were going to review we did this sort of quickly at the end of class on Monday but we're going to review merge short run time and then we're going to finish by looking at an algorithm that is interesting it's a well-known sorting algorithm it's fun to implement it's fun to talk about because it has very interesting behavior it has good behavior in certain cases and poor behavior in other cases and so unlike merge sort which is sort of like the you know predictable you know the steady predictable algorithm in the sorting space as we'll review in a minute quicksort can work really well or depending on the inputs you give it it can work very poorly right so that'll give us a little bit more of a chance to exercise our you know algorithm analysis muscles on something that actually has a large amount of input dependence and we'll think a little bit about what some of the sort of canonical so DIF quarter cases are the cause quicksort to perform poorly after that point we'll go through kind of our sorting algorithms lay out everything we'll talk about a couple of other properties that we sometimes like sorting algorithms to have and that'll be it okay so let's start by reviewing merge sort so we had implemented in merge sort together last time you guys will have another chance to do that on the homework this week and a little bit of a different context so we had done the merge step which was really all the work we didn't extend it at to actually provide a recursive sorting function and then we wanted to think about run time this is the case where you know it's a little bit trickier it's not just one loop or two nested loops of something like that there's actually a function there's a recursive algorithm here and so we need to think about you know how many times is the recursive function going to get called and so here's an example of doing this analysis for array of a certain size so I'm going to pick eight that's a size that's chosen of course to make this example work out nicely let's just think about what happens here so after we get to the point when we reach the base case and we actually start merging so remember the first like many recursive algorithms we've looked at the ones we run on trees the first thing the recursive algorithm does is get all the way to the bottom so it keeps breaking the problem into smaller and smaller pieces until it finally gets to a problem that it can't make any smaller and in the case of merge sort in the case of a tree that was typically an empty tree or single node in the case of an array that's an empty array or an array with one value so array with one value was already sorted and so the first merge step we do is actually the very bottom right so we took an array of size eight we divide it into two and arrays of size four we took those arrays of size four and divide them in two arrays of size two we took those arrays of size two and divided into two arrays of size one and now total we've got eight arrays of size one and we're gonna start to put things back together all right so our first merge takes eight arrays of size one merges them in pairs into four arrays of size two okay so here's the tricky thing so remember merge is oh and the size of the resulting array so each one of these merges between for each one of the merges is producing an array with two items so I'm doing four merges of O n where n is two and that's equivalent to one o n step where n is eight okay so this takes o n and the size of the original array right I'm doing a lot of merges but they're all small ok now what I have is four arrays of size two that are all sorted that I need to merge back together okay so my second merge I'm working I'm taking my solutions to these smaller problems and combining them together into a solution to the bigger problem so now I've got four rays of size two and I'm going to merge them together I'm going to merge them in pairs into two arrays of size four so again I have two merges where n is four which is equivalent to one step where n is eight Oh okay so I've got another Oh n step and my final step I take those two arrays of size for merge them together into one array of size eight so that's clearly one merge of size o n where n is 8 so every step every level of the algorithm takes o n and so the question only becomes how many levels is it going to take and the idea here is that if I take an array of any size we've taken an array of size N and I break it in half at each step this number of levels that it's going to take to get two arrays that are size 1 or 0 is log n where it's log base 2 of n ok think about it as we go up the log log is he you know again this is sometimes hard for people to think about but log is the inverse of an exponential right so as we as we combine things together so when you get all the way to the bottom we have arrays of size 1 that's true no matter how big the array is and then we have arrays of size 2 and then 4 and then 8 and then 16 and then 32 and then 64 and eventually I'm double eight in every stop so eventually that n is going to get to be bigger than the array that I started with which point I'm done so this doubles on the way up so the number of doublings that it takes to reach a particular value of n is log n so I've got log n steps every step takes o n because it's either one big merge of size o N or a bunch of smaller merges but it always works out to be Oh N so I've got log n levels each level takes o n I get o and log n we're again the logarithm here is base 2 any questions about this mouse this is you know again this is kind of tricky right so the the binary search algorithm you guys worked on yesterday and lab right that was the case where that's a o log n algorithm right again think about it from the bottom up right so when you start it's a recursive search algorithm it keeps making the array smaller and smaller says I don't know where the value is in array of size n but it'll be easier to find if I look for it in array of size n over two and I keep doing that until I get an array with one item at which point I say okay I now I've got to be able to find it's either in here it's not when I worked my way back up every time I go up a level I start with an array I start out having search an array with one element and then I have search an array with two elements then four and then eight and at sixteen again I'm doubling on the way so this this property of either the problem doubling or the problem getting twice as half is half the size produces this login behavior it was log n for search because you only had to do one thing every time it's n log n for sorting because I have n steps that I have to do at every level of my tree all right so here's maybe another way to think about it you know I start with these eight arrays here that are totally unsorted now I've got four rays that are sorted now there are size 2 now I've got two rays that are sorted of size four and now I've got one big array so again three levels here which is log n base two of eight okay any questions on merge sort runtime make sense everybody ok it's important because we're about to see another algorithm that performs similarly although there's some more variation ok so let's think about this unfortunately I don't have the implementation up here so remember whenever we think about you know algorithm analysis and this is true forever it's not just true in this class whenever you think about how an algorithm performs you always want to think about you know how bad can it get you also want to think about oh when what case this is going to do well right but how bad can it get okay so for time one of the nice things about merge sort is that it doesn't care hey it's n log n in the best case it's again in the average case it's n log n in the worst case it is always n log n if you go back and look at our implementation from last time the reason is there's no step at which point a merge sort is actually you know branching based on the data that's in the array you know it says I don't know the data might already be sorted even if you give me a sorted array I'm still gonna break it into two and raise that half the size and break those into two race it does the same thing every single time right so that's nice okay it's predictable to worry about it before me badly now here's the other concern though with merge sort this sort of motivates our next sorting algorithm is the merge sort actually needs a lot of space so can I wish I wish idea implementation from last time but that merge remember every time we do a merge we create a new array so during the merge I have my original arrays right and then I also have to create a new array that I'm merging the items into now it turns out that there's some clever things that you can do here to reduce the amount of space that we're just sort needs but in general merge sort always needs this temporary array so I'm taking I've got my two original arrays that are total size N and I need to create a new array of size n to work with them right so that I have somewhere to put the values as I'm pulling them out of those original rates okay so as the algorithm is running it needs a temporary essentially it always needs a temporary array of size N and and this could be a problem again think about it if you're trying to merge like billions of records trillions of Records this is something that's done right I mean it can't think about all the data that you know Google has collected about us or Facebook or Amazon or whatever I mean they have and and and this is actually child's play compared with if you think about things like biological data like your genome massive amount of data right linear data you know working through that I mean you can you can definitely it's feasible to have to sort trillions or maybe even whatever the next number passed trillions of records you go back and look at the sorting benchmark competition they have categories that involves sorting massive data sets and so it's hard to just find space to store that data set and now you're saying to run my sorting algorithm you need to take all that space and double it so if you if it took you know two terabytes to store the data I need to two more terabytes to sort I'd in many cases this is a non-starter right this really makes it's a serious weakness with virtual okay so now let's look at the our final algorithm right and both merge sort and quicksort are both sort of examples and a lot of recursive algorithms fall into this category of a technique that we call sometimes refer to as divided incompetent okay so divide and conquer algorithm you know this really sort of you know describes the recursive algorithms we've already been writing the idea of hind divide-and-conquer is to figure out how to make a problem smaller so that eventually I make solutions that are so simple they can be solved directly right and then it says the solutions of the subproblems are then combined to give a solution to the original problem that's what we've been doing all along right you hear this a lot in computer science because it's a great problem-solving technique right I take a big problem and if I can make it smaller and smaller and smaller eventually I make it into small enough problems that are easy to solve okay so here's how quicksort is going to work all right so here's my unsorted away away array it's my unsorted array in each step here's what folks or does it tries to make the problem smaller right it does this in a little bit of a different way than merge sort so merge sort we exploited the fact that we can merge arrays together in Oh n time in quicksort what we're gonna do is we're going to say I've got this big unsorted array and I know how to sort the whole thing but here's what I can do I can cut the array into two pieces where all the values that are smaller than a certain value are in one part and all the values that are larger than that value are in another part okay so those two sub arrays are still unsorted but now I went from having a sorted array of size and having two sorted arrays that are both smaller okay and maybe if I keep doing this eventually I can end up with small sorted arrays all right so let's see how this works in practice so I take a value that's called the pivot and choosing the pivot value turns to have it turns out to have a big effect on how well quick Detroit performs all right so I'm gonna pick a pivot and then I'm gonna move again I'm gonna divide the array into two parts values that are smaller than the pivot and values that are greater than or equal to the pivot so I want the pivot to be in between I don't care where the rest of the values end up that's not important all right I'm not sorting the array in one step I'm just dividing the array into values that are smaller than the pivot and values that are larger than the pivot all right so let's say I pick the pivot value eight all right you've got fine look through the array I have one I think I only have one value here eleven that's bigger than the pivot and so when I'm done with a step of quicksort here's what the array is going to look like so I'm going to modify the array so that eight is now in the right turns out eight is actually in the exactly right spot all these values to the left are smaller than eight and this value to the right is larger than me so I haven't sorted the array right this whole part over here is not sorted these two values are sorted but this whole part over here is not sorted but I've created a smaller problem to solve alright so I'm dividing and conquering so what do you think we do next well now I have smaller problems and now I can basically just restart the algorithm on the smaller arrays note that in each step of quick story I think this is important to point out the pivot value ends up in the right spot so eight will never move again eight is in the right place in the array none of the pivot value is the only value that ends up in the right spot all the other values they might end up at the right spot they might not but the pivot value is guaranteed to be put into the right place okay but I started off with an array of size eight two sword now I've got an array of size six and an array of size one well my array of size one is easy it's already sorted but for my array of size six I don't know what to do and so I'm gonna do the same thing I just did I'm gonna pick a pivot value in this example I'm choosing the first value in the array as the pivot there are multiple ways to pick a pivot value and the performance of quicksort is really dependent on how you choose the pivot value we'll come back and talk about that in a minute but for now we're just for simplicity sake I'm choosing the first time all right so I'm picking five as my pivot value and now again I'm going to reorder the array so that values that are smaller than five end up on the left and any values that are larger or equal to five end up on the right so again now the Rays still not sorted but I've got smaller problems to solve so now I've got an array of size three and an array of size two to sort and I'm just gonna continue this process I picked the first value in each sub array I pivot the sub array around that value and then now it turns out I'm done okay questions about this quicksort is subtle I'll be happy to stand here and go over this example I mean I don't expect you guys to I think quicksort it takes a little while longer than mergesort to wrap your brain around it's one of the reasons we're talking about now after we've seen some of these other elements right a little bit in the sack so now let's look at a single step of the partition because again we think about run time we're gonna have to think both how many steps does it take and how long does each you know so how many levels in the algorithm and how long does each level take right so essentially if I look here I've got you know four levels that I had to go through let's see what happens in each step I pick again my six is my pivot value and what I do is I track the position where the so so I'm dividing the the clever thing about quicksort is it has this way of dividing the array that goes one value at a time so essentially I look at each value in the array and I say does that value belong before the pivot or after the pivot if the value belongs before the pivot I'm I keep track of how big the space how many values that I need to store before the pivot right if I find a value that's smaller than the pivot I need to make that area one and you know one value larger and then what I'm gonna do which is clever is I'm gonna do a swap right so I'm gonna take the value that's in the current pivot position and I'm gonna swap it with the smaller value and that allows the smaller value to end up in the right spot all right so let's just watch how this works okay so I look at five I say is five is 5 greater than 6 sorry it's 5 less than 6 the answer is yes okay so I'm gonna make the pivot space one bigger okay now I look at 7 is 7 7 greater than less than 6 answer is No and right now my the the current so essentially what I'm gonna do is I'm gonna swap seven with itself you guys will see this in a minute when you promote it but there's nothing to show on the slide okay but I also don't make the space than they need to store smaller values any bigger because seven isn't smaller so now you get a better chance to see what happens so now I have a value three okay three is smaller than the pivot value so belong it's the left of the pivot so what I'm gonna do is I'm gonna swap it with seven and I'm going to increase the size of the area that stores the values that are smaller than sex okay so you'll see by swapping it with seven I moved it into the part of the array that's gonna store the values that are smaller than the pivot value in this case six okay so now I'm gonna go on all right so I'm looking at four four is also smaller than six I'm gonna swap it with seven and I'm going to increase the size of the area that stores the values that are smaller than the pivot keep going here I see 1111 is bigger than six so I don't do anything I just move on now I look at 8 8 is bigger than 6 so 8 stays put now I would look at negative 1 negative 1 is smaller than 6 so I swap negative 1 with 7 and now I increase the size of the area that stores the values that are smaller than fit okay so now I'm almost done all right I've made my pass through the array and the only thing that's left to do is get the pivot value into the right spot but I know where to put it right so the value at the very end of the range that I'm using to store values smaller than the pivot is the right place for it so essentially I'm gonna swap negative 1 with 6 and now I'm done ok like this that quick so it's kind of magical right alright so now what you'll see is that I've got 6 in the right spot everything to the right of 6 is bigger everything to the left well greater than or equal to there's no duplicates in this array everything to the left is smaller okay any questions about this again this is this is something I've implemented quicksort a bunch of times and I always have to think it through kind of exactly what's happened right all right so that's good let's give it just a try to implement all right so what we're going to do here we're actually not going to implement quicksort today what we're going to do is we're going to implement the partition function because this is the fun part all right so the way I've set this up is that our partition function takes an input array and a start and an end position and the reason I did it this way is because when you guys implement this on the homework you're gonna use the start and the end to target smaller parts of the array so that you can actually complete the implementation of recursive quicksort right so essentially the partition says you know partition this portion of the array right when you implement quicksort you start to partition smaller and smaller pieces for now we're just gonna try to partition the whole thing and make sure that works all right so you'll see that I'm calling partition with this test array and I'm partitioning the whole thing from 0 to the end ok so the first thing I want to do is I want to I want to test my bounds ok if I'm you know if you're asking me to partition a array that's too small then I don't want to do anything I should just return ok so essentially if n is less than or equal to start plus 1 then I'm gonna return well this is checking this to make sure like a start and end are the same I shouldn't partition and end is not inclusive right so here I'm going from start to to test array dot length you're a test rate that way so if if you asked me to partition a value an array that has no values I'm going to return immediately and if you ask me to partition arrays that has one value I'm also going to return and every other case I actually do need to do the partition okay so now here what I'm gonna do is I'm going to choose the pivot value to be the first element in the part of the array you asked me to partition so I'm gonna save this because I'm going to use this throughout my algorithm I'm gonna say I'm gonna take the first value in the array and I'm also need to save the pivot position so my pivot position starts at start my pivot value starts as the value that's stored in the first slot when I'm done I want that value to be in the right place and I want all the values to the right of it to be greater than or equal to it and all the values to the left to be less all right so now I'm gonna go through the array and this is just kind of a standard actually I'm gonna go through the array starting with star plus 1 right I don't need to consider the pivot value well put it into the right spot at the very end so I'm starting it I'm gonna go through and so I'm looping through the portion of the array that I'm working on and so now what I'm doing is I'm saying if the value in the array at this position is less than the pivot value okay so if the current value is less than the pivot value then I then I need to do two things I need to make the part of the array that stores the values that are smaller than the pivot larger by adjusting the pivot position and I need to move this value in to the right place and I do that by swapping it with what's that whatever in the current pivot position all right so two things to do right the first one is increase the pivot position by one and the second one is I'm just gonna do my standard swap you I'm going to say use a temporary variable to store the current value of input array I I'm gonna set this to whatever is in the current pivot position and then I'm gonna set to be temp my temp value okay all right so again I did two things here I made space below the pivot for this new value and then I swapped it in to the right place in the array okay so when I'm done I get to the bottom here remember if we go back to look at our diagram there was one I can get back here we go there was this one last step which is when I get to the end of the array I still need to put the pivot so here is what things look like when I got to the end of the Ray and I'm close to being done except there's one value that's in the wrong spot and it's the pivot die okay and the way I get the pivot value into the right place is I swap it with the same value that I would have swapped next so in this case it's negative one in our case it's going to be whatever is in the pivot position all right and the nice thing here is because I've saved the pivot value I don't need to use another temporary verb right so I'm moving the value from that's currently in the pivot position to the start which is where I got my pivot value from and then I set input array pivot position equal to pivot value okay so the pivot value has found its way into the right spot and again I don't need a temporary variable here because I essentially already stored pivot value into a temporary variable at the top of the loop because I needed it inside the loop to compare against that we value in the array all right you're feeling lucky let's see if this works all right okay so that looks right to me so let's think about what happened here so eight is the pivot value I'm choosing I'm trying pivoting the entire array by partitioning the entire array sorry I use the first values the pivot that's 8 so when I'm done there's two things I need to check one is are all the values to the right of 8 greater than or equal to 8 and that's in this case that's true it's just 11 are all the values to the left smaller and in this case that's also true let's try some other inputs here just to make sure that things are working as we expect let's try four okay so now things are a little a little trip a little trickier to interpret because there's two forms right so the question is which one is the pivot value when we're finished so what I'll do here because if you look at the let's say I look at this for I say well everything to the right is greater than or equal to but five and four are not less than four right so it kind of depends in this case which one of the fours is the correct pivot value so let's print the pivot position before the function returns let's put this out all right so the pivot position is indexed to okay so that's good because if I look at this for are all the values to the right of the pivot greater than or equal to the pivot value the answer is yes or all the values to the left of the pivot less than the pivot value strictly less than the answer is yes okay so let's make sure that we can handle a couple of other corner cases let's try where the smallest value is the the first one that works let's try the case where the largest value is the first one that also works okay so I think this works questions about this again as far as the code that we've looked at together this semester this is probably one of the subtler pieces of you know imperative programming that we've done a couple of different indices to keep track of you know it's ever right okay so as promised we're actually not going to implement quicksort today I'll let you guys do that on the homework but let's think about its performance okay so first of all who can who can tell me what the run time is to do a partition all right so this partition function tell do the can someone do the complexity analysis for how long is this gonna take yeah Oh an where n is yeah so well it's in number values in the part of the array that I'm partitioning right so oh an where n is like n minus start right so if I partition an array with one value I get 101 if I partition an array with 30 values to go to 30 so this is o n right in the size of in the size of the part of the array that I'm partitioning okay and the reason is that I've got a loop in there right so I've got a loop that starts at line 9 that loop does not have any break statements or continue statements unlike insertion sort so this is important to understand I cannot put a break in there because if I do I'm gonna stop too soon I actually have to go through the entire array because it's possible the last value it's actually smaller than the pivot needs to be put in right spot so I can't the quicksort can't assume anything about the values in the array and so there's no way for me to stop early I'm always gonna have to go through the entire right okay so this is Owen here's where quicksort gets fun all right I promise you'd be fun let's imagine okay let's imagine that the pivot value that we choose in every step is such that the array is divided into two equal parts okay now remember merge sort we always divided the arraign in two equal parts that's how we get the log n runtime and merge sort but quicksort doesn't guarantee that the array is actually going to be divided in half okay it picks a pivot value and then it moves all the values in the right spot with respect to the pivot but it's possible that the pivot is the largest value or it's possible the pivot is the smallest value but let's just imagine that we choose a pivot that divides the array evenly at that point this analysis looks identical to merge sort okay my first partition now the only thing that's cool about this is that quicksort actually works on the way down quicksort actually is sorting the array as it descends to the base case every time it partitions the ray in order to continue it's actually accomplished a little bit of the sorting task but let's imagine we have a set array of size 8 my first partition divides the array into two arrays of size 4 now I know this isn't exactly right because technically it's like 1 array of size 3 and one array of size 4 and the pivot value but just ignore that for now that's that's not important my second partition takes those two smaller arrays and divides them into 4 arrays of size 2 and my final partition takes 4 arrays of size 2 again I know you know it'd be like 1 or a size 1 and a pivot value into a 2 race of size 1 and I'm done because my base case is the same you go back and look at the partition function that we just wrote when I get to a case where you're asking me to partition a part of the array that's either empty or only contains one value I just return done I don't need to partition it ok so if the pivot value divides the array properly then I get this nice performance however here's the problem the problem is that like I said there's no guarantee that quicksort is actually going to pick a pivot value that works this well alright so let's imagine the Fowler so let me go back and let's let's actually instrument art the code that we wrote back here ok washi you know what let's let's just look at it right ok so let's imagine that you know I so so here's what can happen if I choose a value that's the maximum value okay well let's choose a value that's in the middle what's the good it'll value like 6 ok so if I happen to choose six as my pivot value what I end up with when I'm done is one array of size three and one array of size four so I've made the problem about half as small that's good okay but if I choose a value like twelve then what's happened here okay I started off needing to sort an array of size eight what's the size of the array I have to sort now seven I didn't really get much work done here right if I only sort one value at a time how many steps is this going to take if my partition creates two arrays about the same size that are that that I can continue to partition then I get log n steps but if I choose a bad partition value then here's what happens so my first partition partition it's the array into two arrays one of size seven and the partition value which is already sorted my second partition partition into the array into two erase again one of size six and size one my third step takes this array of size six and partitions it and this keeps going and going and going I'm not gonna finish until I've partition the array eight times right so now worst case performance for quick sort is n square remember insertion sort basically what we're doing is kind of a dressed-up version of insertion sort we're only moving one value into the right spot every time and the problem is only getting one one unit smaller okay questions about this so this is this is this is the bad case for quicksort right and again you know so here you know here's ah and here's the other thing about this look at the data in this array what's true about this data like we would kind of like to get good performance in this case why yeah it's already sorted and actually if you have quicksort picked the last value in the partition you get this behavior if the bat if the array is already sorted in ascending order okay we you guys have already wrote code to check if an array is sorted that takes Oh end quicksort is now going to take oh and squared to sort an array of values that are already sorted right so this is awful right and this is essentially how this would work right this is if it's sorted in descending order and I'm picking the first value but this looks identical if it's sorted in ascending order and I pick the last value in their partition right so again this just this is really really tedious alright so understanding this what do we do well when we implement picked quicksort we tried it we try to choose a good pivot value all right we try to choose a pivot value that's not going to lead to this type of you know pathological behavior right so so the first and again the first and the last values are typically bad okay so the first value will fail if the array is sorted in reverse the last value will fail if the array is already sorted in ascending order which is terrible let me ask you a question know what is the value that we want to pick if you didn't know anything about the array you want the value that partitions the array into two equal pieces and if you that have taken any statistics there's a special name for this value yeah it's called the median okay so I feel like we have just had this incredible breakthrough as a class we have found the ideal way to implement quicksort I don't know why anyone hasn't thought of this before but let's just choose the median value in the array to partition the array and then we know that it's going to get I'm gonna get two equal sized pieces why doesn't that work this sounds like it sounds like a fantastic idea right like I think this is this is incredible right I mean I'm gonna win a turn it work yeah yeah how do you find the median sort the array pick the value that's in the middle all right so I can't identify the median without sort of data it's one of the many things that sorting gets you we talked about fact the sorting is powerful once I sort an array I can very easily compute basic statistics on it max min media and things like that quartiles you know just based on the position so I can't choose the median because in order to do so I'd have to solve the problem that I'm trying to solve all right what I can do however you'll see that the median is on this slide so what actual quicksort implementations will do is they'll do one of two things either they pick a random value so they pick a rant a value randomly from the array and use that as the pivot or if they want to do a little bit more work to hoe in hopes of avoiding this kind of nasty case they choose like three values and pick the median of the three all right that can work a little bit better you can find exhaustive analysis on all this stuff online in terms of people running this on different data sets or comparing different choices of pivots election and stuff like that all right this is a pretty well study problem all right so now let's put our scores for quick store it up on the big board and see where we are right so best case time complexity is o n log n all right and that's in the case where I'm creating equal sized arrays every time I perform a partition the worst case is Oh N squared an average case again really depends on your data all right over random data the randomness within the data helps you with such a picking random pivot value so get something that's close to n log n all right the problem with quicksort that makes people nervous are these pathological cases where I end up with N squared that's pretty terrible how so here's the thing that's good about quicksort I don't actually want to get into why it's log N and as opposed to something else but you can do quicksort with a lot less space than merge sort this is one of the reasons why people like quicksort swell the reasons why it got attention in the first place was that remember merge sort needed a whole oh end space if you have a trillion values I need a trillion more slots in memory in order to perform merge sort quicksort log n okay it's actually a constant number per level right but the levels depends on log n ok so that's pretty nice right so in the case the quicksort works well it can be done with a lot less space than merge sir the variable behavior is what's tricky so now let's go back and think about looking at comparing some of the sorting albums we've already talked about so we talked about insertion sort we talked about merge sort we've talked about quicksort so for insertion sort the best case is that the data is already sorted in that case insertion sort will complete an O n all right because it will identify right away that the data is already sorted in the worst case if the data is sorted backwards every single value has to be moved all the way across the array and I get Owen squared right merge sort does not care what your data looks like and again this is an appealing property of it for certain uses quicksort best case turns out to be on random data the worst case can be sorted in one direction or the other it's sort of depends on D implementation all right so let's put everything up there just to do a comparison here so best case for insertion sort you know best worst an average case for all these algorithms right now there's one thing I want to point out here which is interesting right we've spent a little bit more time talking about merge sort and quicksort mainly because they're fun to talk about they also achieve optimal performance you should never choose a sorting algorithm that performs worse than Oh n log n in the worst case it doesn't have to it's just a broken algorithm insertion sort does so you might think why are we even talking about insertion sort why is it on this slide well here's the thing that's I found insertion sort for a sort of data actually performs quite well it's the only one on this slide that actually going to get down to o n in the best case right space usage insertion sort very little quick sort and that's all again that's because of the recursive calls it has to make every step every partition only needs a constant amount of space but I ended up having to do log and partitions all right so this is one of those cases you know in your career as a computer scientist where you're faced with trade-offs about how to choose an album in a minute we're gonna talk about the very briefly about sort of the modern sorting algorithm that's used by a number of different standard libraries for languages like Java and Python and that that algorithm is based on some of the algorithms we've already talked about but it tries to make careful trade-offs in terms of how it uses them right so it turns out if you have a small array insertion sort could actually perform faster it doesn't have as much set-up time if you want really printer performance mergesort requires a lot of space but gets this for you if you're really short on space quicksort is a good option okay I'm gonna skip the part on sorting as well let me do this really quickly so there's a property of sorting algorithms that we sometimes want to preserve which it's called stability I'm gonna say ten seconds worth about this in stable sorts two items in the array that have the same value end up in the same order that they were in the original array okay in an unstable sort two items of the same value can end up in different positions okay when you're sorting integers you may think why does this matter but it turns out when you're sorting objects based on some key sometimes you want to sort things twice so I want to sort first by person in this case I might want to sort people first by their age and then by their name and so about who get for every name I get a list in ascending order of the people with that name from youngest to oldest and so the way I would do this I was sort by name and I would sort by age if my sword is unstable then what happens is this second sort will mess up the results from the first sort right so the second sort will move things around in a way that I don't preserve the sorting based on the name okay they spend two minutes talking about Tim Sora's Tim swords kind of cool right so this is now all the sorting algorithms we've talked about we're talking about to help you learn right these are sorting albums that are valuable to understand whom an algorithm perspective even if they're not used that very much in the wild so in 2000 and 2003 somebody added a story on called Tim sort to Python alright and this is now the default sorting algorithm used by Python and now Java and so one of the ways to think about tim sort is the following okay well first of all Tim sort is very complicated I am NOT going to try to explain how it works right I knew I do know some of the design principles behind it okay but here's a common thing that people do with data let's say I have some sorted data and one array and I have some sorted data in the other array I I essentially append all the data from the second right into the first array and then I sort it okay so essentially what I have is I have a bunch of sorted data followed by a bunch of sorted data so how much time should it take to sort that array let's see I knew where those sorted parts of the array work right remember this was the building block that we use to implement another algorithm right we called this step what if I have two sorted arrays how long does it take to combine them together anybody remember yeah oh when it's merge we have a minute merge right just so what what Tim sort tries to do is it tries to identify what it calls runs runs are portions of the data that you gave it that are already sorted so if you give it Oh n values and it can figure out that the first half is sorted and the second half is also sorted then it can combine them together an O n time and remember that it what was how so if I give you n values how long does it take you to figure out if they're sorted or not that algorithm if I give you an array with n values and all I want to know is are they sorted or not that algorithm takes how long what's that Oh n yeah so it takes o n to figure out if something is sorted and takes o n to merge things together and so essentially again what Tim sort tries to do is it says look in the wild people don't people don't sort arrays that have random values they sort of rays that have data that's already mostly sorted so if I can identify those parts that are sorted and just merge them together I can get much much better performance and internally it actually uses both a combination of but bits of insertion sort to do small parts and then also merge sort to do larger pieces so it's actually this is a pretty clever out all right and again this is an example of a sort that's called adaptive meaning that it's going to choose a strategy to sort the data based on features of the data that it detects at run time ok cool this is a really cool I mean some of you have probably already seen this already hopefully somebody will repost this to the forum later this is a fun this is a funny YouTube video showing you sorting algorithms you know as they run I think it has a little soundtrack to it it's kind of fun so I would encourage you to check this out otherwise we are done for the day this week only I'm going to do office hours on Friday from 1 to 3 so no office hours today I will see you guys on Friday have a great enjoy the next couple homework problems  
﻿ okay look at that only ten minutes late sorry about that alright so today it's not a good day for this to happen either we have some cool code to write so we're gonna keep talking about sorting last time remember we got through insertion sort which had this problem which is that had and Oh N squared run time and so today our goal was going to be to look at ways that we could do better than that there we go okay sweet all right so so the the main sorting algorithm we're talking about an implement completely today is merge sort and merge sort is a nice algorithm in the sense that it is very predictable performance and so here's the key insight that underlies merge sort which is that it may be difficult to sort things to sort of raise right that's what we're spending a couple of classes on but if you give me two arrays that are already sorted merging them is straightforward so here I've got two arrays that are already sorted the one at the top and the one at the bottom and my goal is to combine them together in a to a single sorted array okay so I've got two sorted arrays and my goal is to combine them together and you know this is not hard to do right in this case the two arrays are sorted in descending order so I know that the smallest values are at the front and essentially what I do over and over again is I look at the first two values in the array sorry I look at the first value in array one the first value in array two they say which one is smaller I take that one out and then I move on so now I do the same thing okay so now the second array has the smallest out right now the second array again has the smallest value that second array has the smallest value again so as long as it's smaller I'm gonna keep pulling values out okay now I'm back to the first array now I'm putting values out of the first array get the last value from the second array and the last value from the first term all right so this is a straightforward process to take two arrays that are already sorted and merge them together so let's implement this this will be our first challenge today and again this is a terrible day for this to happen because typing on this keyboard is gonna be an adventure okay so let's do this oh god I don't know what you ever go away all right so what like what is the first thing that we're going to do here I'm given two arrays and my job here is to merge them together you guys forgot the chance to do this on the homework this week what's the first step here what's the first thing I want to do just going back to our sanity checking yeah yeah let's handle null cases and actually we'll handle two corner cases here will handle null and we'll also handle cases where either of the arrays is empty all right so the first thing we want to do is we want to say if first is equal to null and second is equal to null in that case we're just going to return no you don't have any values to merge so we're just gonna return an empty array actually not an empty array we're gonna return a null right okay now let's say that one of the arrays you gave me is null or empty all right so let's say that first is null so if I get to this condition this means that first is none but seconds not no so you gave me one array but the other one was null or let's also handle the case here where first is empty if first that length is equal to zero what do I want to do here the if you gave me a null array first it's now but second is okay or first it's empty but second has you know might have some value said it what should I do here I don't really have any work to do I am an empty array so if I have an empty array and one that's full of values how do I merge them together this return the one that has some date in yeah so it's just return second good okay then finally my last condition down here what am I gonna do I'm gonna do something very similar to what I did up here so I'm basically gonna rewrite this I'm gonna say second is equal to null or second length is equal to zero return first good all right so I've handled my corner cases here give me two seconds here I've it's like okay you guys are gonna find out something about me today well one thing you're finding about me is that I'm terrible at using windows finally oh okay okay years ago when I was in college I started having some wrist problems so I switched it does anyone here use the Dvorak keyboard layout any way the keys are in different positions so I've been using this for like 15 years that's why I looked like a total idiot when I need to type on a keyboard for the normal layout but now I'm now I'm good alright what led to one of my key observations about helping students never touch their computer because I can't type on your computer anyway I'm gonna look like more all right so I've handled my corner cases here now what do I need to do so now let's actually create the array the combined their combined array so let's say and we're gonna say make this into a new array and it needs to be big enough to hold all the values from both arrays alright so I've got a combined array now my loop here is going to go through the combined array and kind of pull things one by one out of the two smaller array but I'm also gonna need to keep track of where I am in my small early remember I'm assuming my smaller arrays are sorted so the smallest value in the first array is currently index 0 and the smallest value in the second array is currently in index 0 and I'm gonna use these variables to keep track of where those are so now I've got my loop here I'm gonna go through my combined array using our good old loop syntax all right so now who can who can walk me through what to do here alright so I've now I've set up the problem I've got a loop that's gonna so essentially what I need to do is in each iteration of this loop I need to either pick a value from the first array or the second array and copy it into the combined array at position I so I'm going front to back from my combined array and essentially what I need to do is I need to look at the front of first array the front of the second array figure out which is smaller and then stick that one ok so so that actually there are actually four conditions here but but who give me one of them I'm not gonna put in here yeah yeah okay yeah exactly so let's say here if first first index is less than second second index what this means is that the first array has the smaller value right whatever the value is that I'm currently looking at in the first array it's smaller and so I'm gonna pull it in to my combined array say combined here is equal to first first index and then I'm going to advance my first index so I'm looking at the next value in the first row okay otherwise I'll take stuff out of my second array okay it's going to work let's try it all right I got to put a return statement in here that's kind of saying the one I have right now is he's not okay scroll down a little bit pull this down all right so now down here I'm gonna return combined let's run this code and we'll see what happens Oh okay so I've got a I've got an array index out of bounds exception and it's happening on line 15 so it's happening right here so what's happening here I'm trying to merge two arrays of size four in the array size out of bound exception thy God is of size four so can someone explain to me what happened why am I not done you could try to figure out a little bit more about what's going on yeah in the back yep yeah so essentially that at some point what I'm going through here okay and I don't know when that's gonna be because it depends on you know the values are than the true race but at some point the first array is gonna be out of values or the second array is gonna be out about you so think about it this way when I get to the last value that I put in my combined array one of the two arrays is empty okay and I don't know if it's the first one or the second and so the problem is at that point I've advanced my first index øresund a second index past the end of the array so it doesn't hold a valid value in it okay and so essentially the way I have to handle this is with another set of conditions that are gonna make this statement a little bit less satisfying so I say if first index is first dot length what does this mean so if first index is equal to first dot length what does that mean about first somebody who hasn't volunteered an answer yet today so I've gone through and I've been pulling things off one at a time yeah yeah first is empty right so at this point I'm advanced first index through all of its valid values and it's basically at the end so at this point first is empty and what I'm gonna do instead is I'm just gonna pull so I can essentially cut and paste the code I have down here for a second so at this point the values I need are in second nope stop it let me fullscreen this again I can figure out how to do that again all right so here I'm gonna put right can I successfully cut and paste on a Windows computer or not find out apparently not for real it's the terrible all right one more time the last option key here Wow look at that okay there should be a round of applause for that please all right so the first arrays empty then the values I need have to be in the second array remember the second array is all sorted so at this point I'm just pulling things out of the second round I could improve this I could just stop here take all the values of the second array but let's just keep the outer loop the same okay all right so there's one more thing I need to do right so I'm handling the case where the first array is out of values and then I'm handling both cases where both arrays still have values and I'm picking the one at the front properly but there's one last case I need to handle here which is when very similar to what I have already up here remember I don't know what your Ray's gonna run into values first yeah both arrays are empty I'm done close right so I'll never get to the point where both arrays around yeah so I have to essentially do this same piece of code except for the second array all right so I have to say if second index is equal to second dot Lane then this means that my second array is empty and I should pick something from the first array so again I can cut and paste stop that I can cut and paste this code up here okay so again this has gotten sort of gnarlier then then we would want but it's actually not that not that complicated there there are two conditions I need to handle if one of the arrays is empty so if one of the arrays is empty all the data I need is in the other array the first erase empty takes something from the second array the second array is empty take something from the first story okay if I get down to line 21 it means that both the race they'll have data in them that's really snowing out there cool and I need to pick the smaller bout right and there I'm just using a conditional based on the value of the item all right so let's try this now and see if this has solved our problem with the array index being out of bounds and it has okay and now what you can see is that I've also successfully merged both arrays so now let's try some corner cases here since we're defensive programmers let's try the case where all of the smallest values are in one array the other array only has larger values okay make sure this works that seems like it does we could turn those around and make sure it works too but I'm pretty confident with this right now okay any questions about this this is like the hard I mean to degree the merge sort is hard to implement this is the hard part we haven't actually implemented a sorting algorithm yet what we've done is we've implemented something that could take two arrays together two sorted arrays emerge them together but what you're going to see it was very cool about merge sort is we can use this to build up a recursive sorting algorithm and when we implement the recursive sorting algorithm we'll come back and grab this code but the actual additional code we need to write at that point it's really really quite small all right any questions about this before we move on good sort of recursive sorry imperative programming review you know this is one of those things that's conceptually not hard a little bit tricky to to translate into code okay so now the question becomes how do we actually use this - well let's talk about the runtime of time complexity of this first ok let's go back and look at our implementation ok how many steps is this going to take who can talk me through this here's my here's my just my algorithm here's the implementation of the algorithm sorry how sorry how many steps will this require yeah yeah so to merge arrays of size and an M it's gonna take n+ out okay and on some level if we think about n is representing the size of the combined array this is Oh a okay so if my combined array is going to contain n values I know that when I call the function right if one has five and the other has three the combined arrays gonna have eight all right so I know how many values are gonna be in the combined array it's Oh N and the size of the combined array my loop goes through that array one at a time it's not doing anything fancy there's no break or continue there's no nested loops all I'm doing is array axises and comparisons those are constant time operations okay so another cool thing about this right is that there's no data dependence here all right so if I go back and look at this there's nothing in here like this loop is gonna run combined array size times it doesn't matter what's in first or second all right so this is not like insertion sort where we had breaks and stuff like that that were in there this is never going to depend on the data okay so worst case is o N best cases Oh in average case is owing that's something that we like about merge sort it's predictable and this is really the why right because the merge itself is predictable hey give me two arrays of size combined size and it's gonna take Oh n Demers now again there are some there are some sort of you know cases where you can get a little bit better performance here but particularly if one arrays out of values right but in general away right and again the way that we've implemented this there is no dependence on the values and first and second for how long it's going to take the behavior the algorithm depends on the values of first and second but its runtime just not all right okay so I've now so now we've sort of worked through this observation which is that it's easy to merge two arrays together into one sorted order but how do we use this to actually build a sorting algorithm okay so the question is where did those sorted arrays come from right I gave you two stories of size four but I didn't tell you how to sort those arrays however think about your merge step took choose sorted arrays of size four and created a sorted array of size eight so I have one of the ingredients that I need for a recursive algorithm I have a way to combine the results together if you give me two sorted arrays I'll combine them together and what you get is a bigger sorted array so I'm merging the results from smaller problems together to get a solution to a bigger problem right the question is how do we make the problems smaller first so if I give you the big problem how do you make it small enough that you can start to build up those combined solutions and the answer is to go back to this property of arrays that we looked at when we talked about the fact that arrays are also recursive data structures every sub array of an array every contiguous section of an array isn't a right right so here I can think of this as one array with eight values so I could think of it as two arrays with four values and this one on the left I can think of is to erase of two values and that array on the left I could think of as one array with one value and so I can keep breaking my big problem down into these smaller problems now what's kind of cool about this you know so if I take an array and I break it down let's say I break it into two pieces so I'm always going to split it in half I take an array of size and I create two small arrays of size n over two I take the arrays and I break them down until I have two arrays of size and over four what's the smallest subproblem so now I know how to break the problem down into pieces I know how to put the pieces back together but what's the smallest sub problem here then I'm gonna have to stop and solve a media all right so I know how to build bigger arrays sorted arrays from smaller sorted arrays what's my you know and I know how to take a big array and break it into smaller arrays but how do I get to an array that's already sorted yeah yeah so in a ray that is empty or has one value in it is sorted okay so if I start with an array that's empty or has one value it's sorted and I can take two of those and use my merge function and make a bigger sorted array and then I can take that sorted right and another sort of rate and make a bigger sorted array and I can continue to do this until I've sorted the entire array all right do I have all the ingredients I need here for a recursive solution to sorting it's cool right I make the problem smaller by breaking the array into two parts and what I'm going to show when we talk about the runtime of merge sort and actually in particularly we talk about the runtime of quicksort which we'll get you on Wednesday one of the things that's important to note here is the size of these arrays matters so when I do merge sort I'm always gonna try to break I'm gonna break the arrays into equal pieces as much as I can sometimes if I own an array with size three I'm gonna end up with one of size two and one of size four one if I own array of size seven I get three and four but I can always have them be almost equal right this is important for the run time but here's how this is gonna work we're gonna break the problem make the problem smaller by breaking the arrays into smaller pieces they're roughly the same size the smallest sub problem is an array that's either empty or as one value in it when I get there I'm done an MD array is also already sorted an array with size one is sorted okay so now I have I've solved the problem I created this sorted array how do I merge them back together I use this merge function okay all right so so again to do merge sort which we're about to do our base case is we've reached an array with just one value or zero value all right sometimes that happens because of how the arrays divide up the recursive step is to split the array into two pieces and I combined result by using this really nice merge function that I just wrote all right I just wrote merge so I know how to combine results all right the last thing you need to know how to do that I'm going to use in this example is you need to figure out how to split the array so in order to finish the job here I need to know how to do this step okay now you can implement this function you guys at this point are far smart and enough to implement this function but let's not bother let's just use a helper function that already exists in the arrays library so there's a library of this is a Java library that contains a bunch of functions that run on a rate they don't now this is an important thing arrays as a Java object only contain that one length property they don't actually don't have any methods these are static methods that take an array as an argument and do interesting things too so for example there's one that we're about to use that's particularly useful in here that's called copy of range right copy of range takes a bunch of different types of arrays here we're gonna use an int and it copies the specific the specified range and returns you a reference to that new array all right you might also notice that down here at the bottom are a bunch of sorting functions right that will sort arrays for you right so that's a little bit that's what you would actually do if you were weren't trying to learn how to implement sorting are going to just use the ones that are already built into John alright so the first thing let's before we go on let's go back and get our merge code let's rescue our merge code from earlier where they go yeah here we go I do not want to write this again so and now I know how to cut and paste grab this and then OOP undo well find you here ah sweet cozy control-c and then let's go back to where we were all right this is going to be really cool all right so let's drop in merge here great so I had the merge code that we just wrote and my goal here is to use this to implement merge sort all right so merge sort is a recursive algorithm what's my base case one argument which is an input array what's the base case here smallest problem what do I know when do I know when to stop yeah yeah less than or equal to one yeah so if my input array size so I'm gonna say if input array dot length is less than or equal to one just return input array that array is already sorted otherwise okay and and again this is this is you know kind of kind of cool what I need to do is I need to do two things so I basically have to sort the right half half I need to sort the left half or right is actually let's start with the left one it's a little more you so think about so the left is the first half of the values in the array and I'm going to sort the right half and then I'm going to merge the results okay so I know how to do the merge right so essentially let's say int is equal to or sort here's where I'm gonna use this function from the arrays library so this is going to give me this is going to give me a copy of the first half of input array arrays dot copy of range from zero to input array dot length over to my second and I'm gonna and I'm gonna sort that part all right so these are my recursive steps my second well here let's call this left just because that's what I called it so the left half of my array is here the right half is the result of running sorry I got to fix that I'm throwing over two so this is now the other half of the array I think Chuck style is gonna get anywhere with me and let's like do this okay so now these are my recursive steps I'm writing this out a little bit longer than we will in the minute just so you kind of see what happens right so remember this is a recursive function unless I'm at the base case I don't know how to solve the problem what I do know is how to make the problem smaller so here what I've done is I've said well I don't know how to sort an array unless it only has one or zero elements in it it's got more than that I'm gonna break it into two pieces and rely on the fact that eventually I'll know how to sort it if I keep making the problem smaller and smaller I'm gonna get to do small sub problems now okay so at this point I have a sorted copy of the left half of the array and a sorted copy of the right half of the array what do I need to do to finish the job right so again I don't know how this merge sort function I just call it works all right all I know is that it will eventually sort the array but now I have two sorted arrays one containing the values that were in the first part of the array the one containing the values that were in the second part of the array what do I need to do to glue these back together come on you hacen tributed yeah yeah so I'm gonna merge them yeah that's what I wanted to hear I'm gonna call merge right my merge function takes the left and a right array so essentially what I'm doing here is I'm gonna do merge left right that's it my merge function takes a you know a first in a second array and returns a new array that has twice as many values in or sorry that the the number of the first out length times like no okay let's see if this actually works Oh Chuck Styles mad at me about something hey brackets a legal position weird oh sorry here we go yes declaring a reference to an array uh-huh look at that magic all right like I said the recursive code here is not a complicated any questions about this where we talk a little bit about runtime I can make this even more appealing in the following way so let's just do this let's do return I don't have to create these temporary erase what I can do is return merge of merge sort of that common here now I'm just combining these get rid of the temporary arrays and it works okay questions about this it's our first recursive sorting algorithm down again I've got my base case up at the top and then in one statement now I'm combining both my recursive steps which are to make the problem smaller by looking at the first half of this input array in the second half at the input array I'm calling merge sort to sort those two and then when I'm done I what those return is a sorted copy of the first half of the race or to copy the second half of the array and I use merge to glue those together all right so let's talk a little bit about how long this is going to take because this is a little tricky just getting some intuition for this right so let's walk through an example and let's walk through an example with a carefully chosen value of the number right which is the power to that's helpful I'm thinking about this okay so let's think about if I'm sorting an array that has eight values in the first merge so they think about I go all the way down okay the first merge step is essentially taking eight array so I brought the problem down until a small small small finally I found eight erases size one my first merge merges those eight arrays of size 1 into 4 arrays of size 2 so that's 4 oh and merges where n is 2 okay so this is o 8 right 4 times o n the second merge takes 4 arrays of size 2 and merges them into 2 arrays of size 4 so now I've done - Oh n merchants where n is 4 right remember the runtime of my merge step depends on how big the arrays are so now I did - Oh n merges 4 and is 4 that's also Oh 8 for this step and now I've got a final merge which takes two arrays of size or into one array that has the all the original value Center sort it okay so that's one Oh n merge where n is 8 so what's interesting here is that every level contributes om right it was Oh and to do the first set of merges where n is 8 the size of the original array okay as the merges gets smaller I have to do more of them as they get larger I'm doing fewer okay so I've got o it Oh N for 1o n for the second I went for the third so now what drives the runtime here every step every merge level is going to be a wet right but what drives how long this is going to take it's the number of levels right every level contributes oh and here I had three levels of o n so it and it turns out that some of you that are thinking about thinking this through might have realized that two to the third is 8 8 log 2 is 3 okay every time I make the problem half as small I bird when we talked about o log run times we've said that frequently those were associated with recursive function recursive algorithm this is and so what I end up with is an O n log n runtime that is the best that we can do for sorting in the win you know that is the best that the sorting algorithm can do in the worst case right so now we have implemented a sorting algorithm that does as well as any sorting algorithm that you can find out there in the worst case there are certainly islands would do a lot better in the best case but this one will do better do as this one achieves optimal performance every time all right so here's another visualization of that to sort of how things are coming through right so at the top I have 8 values now I've merged them into 4 sorted arrays at the second level I merge them into two sorted arrays at the third level I've got one sorted array with everything it number of levels is login in the size of the array each step is OS so to combine the two together I go ghetto and login okay I think we'll stop here pick up here on Wednesday sorry about the technical difficulties today please stay warm out there looks like a blizzard going on a snowball fight joy some beautiful snow and I will see you guys on Wednesday  
﻿ [Music] started upper deck volume okay all right pull the back you can't hear me okay so I don't have a big agenda today the goal is to do what I can over the next 15 minutes to prepare you for the midterm next week okay so you know this is an important checkpoint in this class so please with the coffee yeah if you if you have a cold I'll post the video about this later all right no one wants to take the midterm sync you don't want me to write the midterm soon so you know one of the things we do a lot in this class we try to make sure that you guys are okay and that you're moving forward and appropriate pace and that's why we give these midterm exams not the format is the same as quiz so now we're long it's more cumulative the programming component will be emphasized a little bit more there will be no questions from the book which people are pleased about I guess but you know the goal you know is all of the assessments would do in the class the goal is to make sure that you know what we think you know you know I was thinking about how some other courses still work and how some courses I took in college used to workroom it's like you showed up you went to class for like two months and then it was like oh yeah we should give an exam see if anybody knows anything right and you know a lot of times it was like oh I got confused on like the third day and I've never caught up so we try not to do that that's why we do daily assessments but that's why we do the weekly assessments and that's why we do the commitment so this is not punitive it's intended to give us a sense of how you're doing the other thing and this hasn't been as much of an issue this semester which I'm pleased about you guys been doing quite well on the on the quizzes actually even outperforming last fall and last spring so congratulations I don't have numbers on that but I think out of last night but you know here's another dynamic that's going on many of you are freshmen you're all extremely intelligent but it's possible that you are starting to see some scores on quizzes that are unfamiliar to you maybe they don't start with a nine or they don't start with you know or they don't consist of a one followed by two zeros right you know I've had students come in in the past and they said oh I failed the quiz because they got a 60 we don't assign letter grades to any individual assessments in this class ever so you didn't get an F on the quiz F on the NP if you got it here at the very end of the semester you guys will all receive one letter grade for me that's it most of the time in the past people have been pretty comfortable with the letter grade they receive at the end of the semester but you know it's useful from our perspective to sometimes you know we understand this dynamic I get it I get that you don't like to get a 60 on a quiz I don't get that some of you guys don't want to get a 70 adequate some of you are frustrated if you get an 80 or even like an 85 I'm using that to my advantage we use that to keep you guys going right some of you will walk out be like oh I really wish I would have done better and you got an 80 and I actually think you did okay but I'm glad you think you should do better because you can do better and if you prepare better you will do better okay so format of the midterm yeah so the goal of this is just to make sure you're ready to go on well do this if you do really poorly we're gonna have a conversation about your future in this class right but poorly is relative so the goal here is to make sure that you're ready to go on and succeed throughout the rest of spend yeah oh is that better I've got this thing all the way up now I have it all the way up I'm not going to do this thankfully there's no video of me just the slides is that better okay can anyone hear me now anyone not hear me okay it's all the coffee that's why you can't hear all right so format of the midterm exam there will be 12 multiple-choice questions needs to be largely code reading questions in a multiple the sort of simple like what's the type of this variable question those are gone elsewhere quiz questions the midterm questions are gonna have you read some code there aren't as many of them but they're a little bit more they're a little bit medium every one of them there are three programming questions in the middle one is on a race they tell you something about the midterm one is on using multi-dimensional ranks you talked about last week and there's one on using strings I have to drink water just listening to you guys ball okay and there will be and here's another promise I will make to you one of the questions on the midterm is already available for you to practice it's on the homework 125 practice problem set I'm not gonna tell you which one again I understand how this works but there is one question on that will be drawn directly from the homework you've already done this morning before class I published all of the old quiz questions along with all of the old homework there is not a homework problem today by the way give you guys a little bit of a break I'll be back on Monday but so this is the format of the exam any questions about this yeah what's that there are no one of the three there are three programming questions one of them not telling you which is going to be drawn from the practice problems one of them it's already out there in the world available to you for you to practice other questions it's an hour long as usual yeah you can solve the problem any way you want yeah I'll show we're going to go over that later actually I will do some substrate based solutions yeah there was some clever solutions to the rotate string problem that used the substring function that did we give you a hint about using that or did you find that on your own camera I think there was a hit yeah great question so the question is which string methods to be expected to be familiar so anything that we've had you use in a homework problem I would at least know that it exists know that it's out there we will provide the documentation for the string class as part of the exam so you'll have that available to you now do you really want to be hunting around in there with the clock ticking and the CVT F I don't think so but you know knowing that there's a function called splint and a little bit about how to use it knowing that their strings have a length function knowing that there's an equality method for Strings those are useful things yeah there will be no questions about the book on the metric yes are you guys getting those wrong they're so easy all right other questions yeah you cannot review the multiple-choice questions from the quizzes but all the programming questions from the quizzes are up on the 125 problems if you want to look at the multiple-choice questions find a TA in office hours not a CA some of you guys are losing the distinction there are the TAS or graduate students the CAS or undergraduates we have a lot of C's we have a few TAS the TAS are allowed to look at your home at your quiz scores on per learn the CS or not so if you come to office hours when it's not crowded with people that are working on an MP and ask a TA to go over the quiz they'll be happy to do that yeah okay will you only get one attempt at writing each programming question how many people think the answer to that question is yes how many attempts have you gotten on the quizzes as many as you can fit into and out yeah why would who do you think I am by a bad guy now we want you to practice I know you guys make small mistakes I have a lot of sympathy for people to make small mistakes I make a lot of small mistakes you will always on any programming problem whether it's MP quiz homework get as many attempts as you can fit into the time allocated for this class I encourage you to use that in other question yeah sorry what's the point breakdown I think a good question I think the programming questions are worth about half of it I have to I'll have to go back yeah you asked that in the forum I'll give you the pitch oh right good question is there partial credit on the programming pressure I don't remember I think the answer is yes well I will check other questions okay so let's do some problems together actually I said this was an open review session is anyone have a question about the content does anyone have a problem that they'd like to do I does anyone have a yea-ah okay I have a call to do rotate left you guys want to look at rotate left yeah okay let's see here I've got this one on the slides alright so we did rotate right take a string rotate it so that the characters move to the right a certain number of you know based on parameter that's passed in can I solve the same problem rotating the string to the left okay so here's how I'm going to approach the problem now there are other ways to do this and actually in a minute I'll show you some other ways to approach the problem some of them are good some of them need some work okay so here's what here's my suggestion for how we approached it first of all it's usually easier to work when I'm doing these rotations within a range because then I could use modular arithmetic and I can let things wrap around a little bit with my indices so that's what I'm going to do so the first thing I'm gonna do is I'm gonna take the string and I'm gonna convert it to an array of characters we know that strings fundamentally are in a very imperative so this is just changing the representation a little bit so I'm taking this string and I'm gonna use one of the Filton string functions to extract the array of characters then I'm gonna work with that array and then when I'm done I'll return a string I'll take whatever array of characters I've left with and I'll return that is a strength so then I'm going to I need a move when I'm going through every string character by character because I know that every character in the string has to end up somewhere in the new string that I'm creating so the trick is to figure out where so inside my loop I know two things remember when I have in a ramp associated a piece of metadata with every piece of data in the array so the array the data in the array are characters the metadata is an index and what I really need to work on is that index because I know that that character is going to go somewhere in the array that I'm creating I just don't know where I need to figure that out once I know the new index I'm gonna copy that character into the new array and when I'm so when I'm done I'll have an array that I can return this this trick all right so let's do this together so I'm gonna declare a function that returns a string called rotate left take the string as input for now let's just return the input and make sure that I've declared my function I have not oh I need it has to take a parameter there we go okay rotation oh and my function signatures wrong it's good too oh and this SP static all right there's my starting point you did this in Prairie Lerner you didn't have to add this static but it's pretty much the same okay so let's go back to my algorithm and again what you guys are working on problems like this oh please whether it's in the CB TF or on the MP I strongly suggest you the less code you write between figuring out what happened blind tests putting some print statements in trying to examine what's going on the less code you write the more likely it is that you're going to be headed in the right direction so the first thing I needed to be able to do is figure out how to get an array out of this string and if I recall correctly it's a to care array let's try that okay so it seems to work now actually let's print the length of this array to make sure that I did things properly okay so that seems to work if you hadn't you know again that's you know you had asked about the string functions to remember this is a good one to remember right I can get an array of characters out of a string great so now what else do I need I also need an output array so I need a new array and here I'm gonna create a new character array how big should my output array be same size as the input array so I'm gonna say new care input array make sure that works okay good so now I'm gonna write that loop that goes through the character array and let's just make sure that this loop works first what is wrong with this oh sorry there we go told you about making simple mistakes all right so it looks like I'm retrieving the indices properly so now before we actually do the rotation let's just get all the wrapper code done so let's just for now let's not rotate the string at all let's just put the characters into the same spot in the new array where I say output array I'll say int rotated index is equal to I eventually I'm gonna need to do some work here add rotation code and I'm gonna say output array rotated index is equal to input array I and now instead of just returning the input I'm gonna return a string created from the output array okay so now I've got you know and again I would really encourage you guys to do this whenever you're trying to write complex pieces of code right the simple thing first get all of the kind of like fiddly stuff done so now I know that the top part of my function is right and the bottom part is right and all I have to do is work with this this bit in here okay so what do we definitely need to do right so let's think about this so let's try to let's try to do CS 125 rotated laughed one place so where should so if I'm at position I where should I put that character in the new strength I know I want to move it left if I add to it I'm moving it right if I subtract from it I'm moving it left let's try to say rotated index is equal to I minus rotation okay and let's see what happens if I do that so this is I'm sort of I'm I'm think I'm on the right track here but if I try running this code I have a problem and the problem is is the error message indicates I have an array index out of bounds exception whenever you have one of those it tells you right there what the bad index one okay all right so it looks like it's at line 7 and actually what's happening is when I try to use my rotated index to copy the character into the new array I'm trying to copy it into an invalid place ok so what's the problem what's going wrong well it's think about what happens the first time I come through loop I is zero rotation is one I take I - rotation and I get negative one which is not a valid inda so let's think about it what's the right place if I'm rotating left by one and I have a string of length five what's the right place to put the character at index zero rotated index should be equal to one negative ones wrong I want to rotate over to the right side of this frame so what's the position it's a very end of the string if I was doing a blank five last valid index is one yeah all right so let's try this all right so it seems like I have a you know I need to add a special case here which is to say if rotated index is less than zero then what I'm gonna do is I'm going to flip it over to the other side so this is going to take negative one it's going to add 5 to it it's gonna give me 4 and you can work out what would happen in the other cases if I've gone to off to the left to negative 2 this would take me back to 3 all right let's try this ah ok that's interesting so now now what happened here looks like I have a another problem right missed okay so let's put in zero see what happens again okay so when I put in 0 I've got this I've got things correct all right let's put in some debugging logic here so we can try to see what's going on again this is another thing that I would encourage you guys to do whenever you're oh my got to add another plus here okay okay there's a bug in my coat who can see it and every programmer makes mistakes what did I do wrong here you can see it just do bug bounties in this morning yeah what's that yeah so the problem is here right I wanted to send zero to position 4 and in setting the Epson isn't sending its position 0 so what did I do wrong where's the buck yeah yeah so the problem here is that I'm using rotation and what I want to use here is input array thing I want to use the length of the string okay so now I've got a correct result for one which is great okay right I'm gonna leave that little piece of debugging logic in there because I think we might need it in a minute not quite done with that yet again this is a useful thing to do when you're working for problems all right so let's try some other values let's try two and see if two works that seems to work let's try three three seems to work okay so let's try five alright five works what about six oh okay now I have another problem so again you know if you were writing this you might you might have thought it was right right this is why you know you want to think carefully about your test cases this is supposed to work for any rotation and right now it works only for a very fixed number it'll work it's not gonna work for negative indices either okay that should be a right rotation so it'll work up until I get to six and then I have the same problem when I had before so what am I missing here yeah yeah let's try this we put my debugging logic and back again and you'll see that I'm back to the whole problem where zero rather than going to four is going to negative one and actually if I use a and I use a larger value you're gonna see this is gonna get worse so now I've got three negative indices so there's one place here where I need to use a modulus to make sure that my index stays in rain or the remainder operator in jobs and the place is right here so when I compute my original rotated index I'm going to insert my modulus operator and that's gonna sorry I keep lying in modulus it's really important to remember this in job okay this is one of the things that's sad about Java another one of those little quirks about the language in languages like Python this is actually a modulus which cannot be negative in Java it's a remainder operator which can be negative so in many other programming languages we would not need this can we have one conversation guys here we go so there are many other programming languages where we would not need to insert this particular piece of of code to check it against the negative indices but in Java we do okay so now I think we're getting close actually this looks right let me take out my debugging statement let's put in some okay so let's let's check with some values here so let's check zero that works let's check five that works let's check ten any multiple of five should give me back when I started what are some other values I should try I haven't tried so I can try arbitrarily large positive values so for example I could say 10 say 5 times 125 I'm gonna get the right answer so that seems to work what happened I tested you okay so if I'm trying to test this code I need to test some negative values let's try this good what other thing am I not doing here they're defensive programming 101 what about about this what's gonna happen if I remember someone out there is always gonna try to get your code to crash sometimes that person will be me in the future it'll be somebody else there'll be a user right so the first thing I'm going to do is my input validation if input it's null I'll just return no I'm good okay questions about this you can already see the output of the print statements on on the quizzes it's it's not I'm sorry that it's not as obvious as it looks here it's sort of buried in the output of a trailer but like up until this point and I will double check this if you guys remind me on the forum we've always had print statements turned on on that right it can be a little bit tricky to interpret because we try lots of different test cases but you might want to look at need to just look at one but yeah that's always other questions okay so let me do I want to do something fun now okay so I'm going to all right so for a few minutes so here's later in the class we are going to start giving you some points on the homework problems for this but right now I want to talk a little bit about good code hygiene I want to talk about good and bad ways to to solve problems all right so what I'm gonna do is I'm gonna take this example this is a good example and I'm gonna show you some submissions from actual students not from you not from less like from two semesters all right these are actual student submissions now all of these submissions passed our test cases all right so from the point of view of our tests they are correct however they are not all perfect nor are they all even what I would consider to be good so let's look at let's look at a couple I'm not gonna post these as part of the slide back side I don't want to share these with you okay so let me grab one of these you see if I can find one that's oh okay hold on not actually that's a good one here's okay here's a good yeah Chuck Stiles gonna be angry with me that's okay I'm not gonna fix this all at once but but start taking a look at this and let's think about gonna fix these Chuck style airs quickly because I want to show you that this actually works this code is correct it's just not very good all right there you go so it works this is working code let me pull this down but let's let's critique it so someone you know came to my office hours a few weeks ago and they they pointed out that there's a lot of musical analogies in terms of how we teach computer science in flats so for example the daily homework our practice that's like practicing your instrument the quizzes are like lessons right the what you guys have coming up next week it's like a recital so the goal here is to have this be a little bit like a master class so again this is this is a student submission this is correct it's passed the test Suites the student got full credit what a like if you were reviewing this you work it some software on the company you're hiring someone or someone's hiring you okay let's look at some misconceptions that we can see in this code and some places where we can clean it up a little bit alright wants to get me started here yeah yeah okay so I like that right oh just so the second parameter be alright what can we call this a lot of options I mean I called it shift I called it rotation you could call it distance something else okay okay good I like that good descriptive variable names all right what else it's a good place to start what else can we do here yeah yeah so and and to be honest that one of the reasons so the concern which I pour tis that I'm creating a new variable length for the in for the length of the input all right and then so this isn't really necessary I could just just use input dot length this is actually connected with another feature of this problem which is that it's too long there's a fair amount of unnecessary code in here and I think that's why the person who wrote it decided to do this because they got tired of typing in put-down length but they actually didn't need to use and that the length as often as they did okay what else what else can we do here so here's one sign that your code isn't quite perfect which is that I can remove things from it and it will still work so anyone want to take a crack at this there's some code in here that we can just toss and we'll have no impact on practice you'll want to suggest a couple of lines or a statement in there that we can throw overboard I love doing this by the way it's like the best part of building software it's getting rid of unnecessary stuff yeah lines four through six yeah this is basically saying if the length is zero overturned the input but what's gonna happen if the length is zero well I'm gonna well first of all oh I know well actually I know why this is here right so this do we need this let's look let's try it let's start getting rid of it I'm gonna comment it out just in case we eventually want it again all right let me make sure that zero still works here let's try a zero length input ah there we go so that's why this is here it's here because if I try to use zero as a modulus going to fit so that we can't get rid of yeah yeah so this isn't this check here this this we don't need okay let's try five that works okay so now you know you might argue with me while that made the code more efficient like not really you know particularly when you guys are getting started like your job is to write code that is beautiful and concise right adding a lot of special cases like that isn't necessarily a good way to do okay what else what else can we do here I see something fairly glaring here it's kind of kind of awful where okay so so you've noticed something on line 11 that's a problem does anyone want to elaborate I see something on line 11 that I don't like a lot yeah well so what's happening here is that every time I go through the array I'm reconverting the input to an array of characters over and over again right it happens here and it happens here okay so there's a couple there's there's two different ways I could change this when we just did this we converted it once at the top and then we just use that array throughout the function because it's not going to change but there's another way to do it anybody remember strings have a helpful function here that I could use so for me this both sort of is is a little bit messy but it's also incorrect because there's a better way to solve the same problem what we're trying to accomplish is we're actually trying to get the bat a particular string value particular character out of the string do strings have a way to do that yeah use care act yeah there we go so I can accomplish the same thing here like that all right that makes me happy works anything else yeah yeah so the question is do I need this if else statement so and that's a great that's a great question remember this is rotate right rotate right doesn't have sum up well sometimes it does but rotate right doesn't have all the same problems as rotate left so the question is do I need this what's our hypothesis about why I don't need this who can make an argument for not needing this particular statement yeah yeah I did the mod right here or I'd use the remainder operator be careful there is no way after I applied the remainder operator that index could be greater than length so let's put some code in here and let's see if we can get it in there Oh see so we did need this why so notice that the modulus here is being applied to be this mysterious parameter that we should have renamed by now that only makes sure that index is smaller than length but once I start adding I to it it can be possible that index can grow outside so what a smarter thing to do would be to say index plus I mod or remainder length okay oh sorry I have to do with this I have to do this say plus I and I'm gonna do mod that's why this position now it's mad at me okay so now I don't need right now I've been just get rid of that piece of code so now like I said kind of happy about this I can break this though now when we gave you this problem we promised you that the rotation would only be positive how can I break this what's an input value that's gonna cause this to fail yeah I may try something negative boom so here's the problem with rotate right if I give it negative values it's essentially the same as rotate laughing where I had to handle this case where even after applying the module even after using the remainder operator I could have a negative in this so the solution to rotate right and rotate left starts to look very similar in fact the correct solution is identical if you need to handle all inputs because I did give you a negative move to rotate right you're doing a left rotation if I gave you a negative input to rotate left you're doing a right work okay see if I have another one okay let me just I just want to put this up here this is sort of a fun one because I want to give you guys this a sense of when you're going when you're on the wrong track all right so I will never I will promise you this I will never ask you to solve a problem in this class where you would have to write a piece of code that looks like what I'm about to show you if you find yourself writing something like that please come talk to us okay now I'm not there's no way I'm gonna fix all the Czech style there's and this caused by the indentation right not even a try but I promise you this works perfect okay it is also awful so again there's actually a lot of things that are wrong about this I won't go into all of them oh you missed the rest of it yeah sorry let me just hold this down so again you know the the point of showing you this you know that the main point of showing you this hold on we're almost done this solution actually checks the entire board manually inside the FL state which is pretty impressive you know someone put a lot of time and energy into writing this right but if you find you're like I said my point in showing you this is just is simply to emphasize the following point there's a lot of ways to get help in this class and if you find yourself writing a piece of code that looks like this please ask us for help because it's likely that you are off on the wrong okay nobody's code that's in the class right now all right any other questions or we will wrap up a little bit early today I wish you guys the best of luck yeah I don't know I hesitate to ask a long time I mean it's a very in many ways this is a very very delicate solution how they took that need a long time to get right okay so last announcement midterm exam next week this grade cannot be dropped you also need to take the midterm next week if you miss it contact the CBT app to reschedule all right I'll be in my office 1 2 3 today if you want to stop by if you have any questions or concerns on Monday we start the next topical unit of the class with a discussion of objects MP 0 is due this weekend good luck finishing that up MP 1 will be released next actually this weekend as well so we'll give you a chance to start looking at that we don't expect you to do much on into lap to the middle have a wonderful weekend good luck on the midterm and I will see you on Monday  
﻿ hi come back everybody welcome to a new season apparently without their hope everybody enjoyed Halloween I was well anyway doesn't matter I was tempted to dress up today but callings kind of over I should have done on Wednesday next semester maybe well no next year that's my next chance alright so today we're gonna keep talking about recursion so we introduced this as an idea last time there's a concept and that's what it is it's not just a programming strategy but today were not only gonna look at a recursive approach to solving a problem a simple problem figuring out how many nodes are in a binary tree well go through that schematically it will review what we did last time and then we're actually gonna write our first piece of recursive code which is fun and this is essentially the kind of thing that we're gonna do for the next week or so a little bit longer than that the homework problems today start with tree recursion and we're gonna continue that pattern for a while you guys are gonna get maybe a little tired of writing tree recursive algorithms but this is great practice and recursion is one of those things that you know you really have to see it over and over and over again particularly if it's new to you even if some of you that think that understand it may need to see it again and again and again in different ways before it kind of starts to click what's actually happening okay I also have some good news for you which is that the class did really well on the midterm so congratulations on that better than last semester better than last year actually so I was happy to see that we have a new MP checkpoint that will release on over the weekend that's gonna be the last part of the game so this is it this is when everything comes together I know that many of you have the opportunity to drop this part of the MP I hope that you won't I hope that you'll do this so that you can complete the process so that you can actually get to the point where we have a fully functional snake game that you can playin use once you guys finish that up so just to think about how to kind of rest of the semester works we have three full weeks until Thanksgiving so this MP checkpoints gonna consume two of them once you're done with the machine project then we're gonna get you started on your final project and so in the lab the week before Thanksgiving we'll start discussions that will have you identify a partner the goal of doing this is to give you some time for those of you who want to do a really cool final project to get some work done on that over Thanksgiving okay and you know so this is what's happening over the next you know a month and a half that we have left in class at that week of Thanksgiving there's four more quizzes one more midterm the midterm comes right after Thanksgiving break and then we will have the final project fair I need to set the date for that I will do that soon but you know this is what's happened okay so let's go back and just review our tree terminology so last time we started talking about this commonly used data structure and computer science called a tree a tree consists of a series of nodes that we organize together that we structure in a particular way such such that every node has one parent except for one node so I have a root node the root node of the tree has is the only node that doesn't have a parent every other node then tree is linked to a parent node now the node itself doesn't always store a reference to its parent but that's one way to think about is that the node has a parent parents in the most general tree that we can talk about and have zero or more children in the trees that we'll work with in this class primarily they're going to have two children it's a special case of a tree known as a binary tree so just to again review quickly some terminology so we refer when we're talking about you know we can essentially look at every part of the tree individual name we can say a node is a parent if it has children so this node has three children the children are descendants of the parent each child if you think about reversing that arrow has a reference to one parent node because these are not roots okay children have one parent every node in divine in a tree as one parent except for the root so we refer to the top of the tree in the way that will look at it of course you could invert these diagrams and they would work as well but we refer to the node in the tree with no parents as the root node many of the algorithms that we are going to use are going to start at the root in fact I shouldn't say many all of them our binary tree class that we're going to look at today and be working with up in the next week or so the only information it stores about the tree is a reference to the root node so this is sort of similar to what we saw with linked lists where my list data structure only stored a reference to the start item and then every other item was linked together as part of the list here the tree stores reference to the root and all the other nodes I can find by starting at the root I start at the root and then I find the root nodes children and I find its children's children and stuff like this it's ever so the rest of the nodes and the tree are labeled as nodes here that the nodes at the very bottom that have no children we refer to those as leaf nodes so any tree any non-empty tree has a root and a non negative you treat has at least one leaf node a tree with one node the root is also a leaf made a tree with more than one node I have at least one right if I didn't the tree would be infinite in size all right so we can talk about the depth of the tree the depth is the depth is determined by we could talk about sorry the depth of a node in the tree so the depth of particular node is determined by how many hops it takes to get from the root node to that node from the root to the node that we're thinking about so these two nodes in my tree here our children of the root they have depth one it takes me one hop to get from the root down to both of those notes the nodes down in this part of the tree higher depths because it takes longer to reach them so here if I started at the root I get here with one hop this note is that level one I get here the second hop this note is at level two and I get to this leaf node here in three hops so it's at level three the height of the tree is the maximum number of steps it takes to reach any leaf node and you guys will actually write the algorithm to compute this in a couple of homework problems so given a tree figure out the height so essentially what I need to do is find all the leaf nodes and then figure out which leaf node took me the longest steps to reach okay so now let's start looking at a recursive algorithm on tree and again we presented this last time we didn't implement it yet we will today after we get through talking about it but you know this is a good starting point it's a good starting point because you still see the recursive solution to this algorithm is extremely elegant it's simple with only a couple lines long but conceptually it could be a little tricky to figure out how this works so let's walk through how we're going to do this so when we approach a problem recursively what we're doing here is we're designing a recursive algorithm we're not writing recursive code yet we're talking about a problem solving strategy that counts the number of nodes in this tree recursively and here's our general approach for designing recursive algorithms and any step in the algorithm we need to either do one of a couple of things one thing that we can do is we can make the problem smaller if the problem is too big for us to solve then we can say well you know what I can make the problem smaller and if I could solve these smaller problems then I could come up with a solution to the firt to the full problem so that's one thing we can do once there's a certain point that we will reach that the algorithm will get to where I can't make the problem any smaller I've made the problem as small as possible sometimes that means that we reach a leaf node or we reach a yeah we reach a leaf node sometimes it needs we reach an empty tree will come back and we'll see that in action in a minute at some point the problem is so small that I shouldn't need to make it smaller to solve at that point the solution is evident and then the other thing I'll need to do is figure out a way to combine the results so if I have two smaller problems how do I combine them together into a solution to a bigger problem if I can do these things so any algorithm they can take a problem and make it smaller and then can solve a problem once it gets small enough and can combine the solutions from smaller problems together to solve a bigger problem can eventually solve the bigger problem right I'm gonna break down the problem you know in this rigorous sort of well designed way and eventually it gets so small that it's easy to solve and then I can combine those solutions to the simple problems together to make a solution into the slightly less simple problem slightly a bigger problem slightly more complicated problem and once I do that I can eventually solve the problem that I started all right so here's how we're gonna do this with counting okay so here's the big problem that we're trying to solve we're trying to count all the nodes in this tree keep in mind I don't even know where these nodes are all I do was have all I have is a reference to the all my tree has is a reference to the node with value five and that's a reference to the root okay so how are we gonna break this problem into smaller subproblems well I mean here's a proposal given a tree the size of that tree given any node in the tree the size of the tree that's rooted at that node is one I need to count that node plus the number of nodes that are in the left subtree of that node which could be zero plus the number of nodes that are in sorry the right subtree left subtree one left subtree right subtree okay so what have I done here I've actually both proposed a way to make the problem smaller because my left sub-tree and my right sub - you are gonna have fewer nodes in them then the entire tree so my left subtree is gonna have fewer nodes so that's a smaller problem my right subtree is gonna have fewer nose that's a smaller problem notice that I've already I'm also proposing a way to combine the results together here I combined them by adding I add the nodes in my right subtree sorry left subtree - the notes of my right subtree and i make sure that i count myself the node that's the current route okay so here here's the node that's the current route that's one we know how many nodes are in there and in that part of the tree just one I have no idea how many nodes are in fives left subtree and I have no idea how many nodes are in 5s right subtree but I knew if I knew how many nodes were in the left subtree and the right subtree then I could tell you how many nodes were the integra tree okay you may think I'm belaboring this but this is the essential step now we're just going to repeat this okay so I've got two smaller problems now I have to count the number of nodes in a tree that's smaller than the original tree two of them one tree here rooted at node three one tree here rooted in node 10 so if I can count the nodes in the tree routed to note 10 and the nodes in the tree root and node 3 I'm good I can solve the puzzle all right how do I do that well let's let's just let's just continue on okay so now let's examine one of these smaller subproblems how do I count the number of nodes in the tree rooted at node 3 okay well let me try applying the same strategy so I don't know how to count the total number of nodes in the tree but I know that if I could count the number of nodes in threes left subtree and the number of nodes in 3ds right subtree and add one I would have the answer now here the problem is actually getting even easier because node 3 doesn't have a right subtree okay so now you know now things are getting better now let me start again I'm just restarting the algorithm this is why it's called a recursive algorithm it keeps restarting itself pretending now that seven is the root of a tree well if seven is the root of a tree how many nodes are in that tree not a trick question I'll give you a node and it doesn't have a right subtree and a left subtree then the number of nodes is what yeah so now this is the smallest possible subproblem and I've solved it once I get to a node that has no children I'm done you know now it's like wait okay well you told me to count the number of notes in the left subtree in the right subtree there is no right subtree there is the left subtree zero zero one I know the answer all right the answer is one okay so good so now let's go down the other side I'm doing the same thing I'm just reapply the same algorithm if I'd want to count a tree and the tree has if the root node has children then I count the right subtree and the left subtree and I add one and here I go so I'm doing the same thing now again I've reached a leaf node so I've reached a problem that I can solve immediately this is the smallest possible subproblem that's what I have to solve at that point I can't keep making the problem smaller there's no smaller problem here to solve I've identified the smallest possible problem I'm gonna do this here too okay so now here's the second stage so sometimes when we write over only we win right a recursive algorithm we think about two stages particularly with trees sort of a natural way to think about it we think about it I'm kind of working its way down to find smaller subproblems because as I go down the tree right so the first thing I did was I separated the tree into a left half and the right half each one of those was smaller than the original tree so as I go down I'm identifying smaller and smaller and smaller to solve then what I do is I combine the results kind of as I go back up and that's where I start to solve more complicated problems so I take these simple solutions I merge them together and I get a solution to a more complicated problem okay so here we're here on the left side I'm gonna take the solution to how many nodes are in the tree rooted at node seven and combine it with the solution to how many trees are how many nodes are in the tree that doesn't exist with zero and now I do the same thing over here so I know how many nodes are in the tree where didn't know nine and I know how many nodes are in the tree rooted in node one now here's the so three so when we got to know three we essentially told ourselves if I could count the number of nodes in the right subtree and the left subtree I would know how many nodes are in this subtree so if I could count the number of nodes in the tree rooted at seven I would know how many nodes are in the tree rooted at three and indeed I do because seven got back mated said hey the number of nodes in the tree root into me is one and so three goes okay now I know how many nodes are in the tree rooted at three it's two same thing over here for no 10 no 10 had said hey if you could count the number of nodes in the tree rooted at no nine my left subtree and the number of nodes in the tree rooted node one my right subtree then I would know how many nodes are in the tree rooted at me no 10 and I do it's three number of nodes for the right subtree plus the number of nodes in the left subtree plus one and now so again now I'm solving more complicated problems I started off trying to count the number of nodes in a tree that we knew had six nodes and then I broke it into a problem of counting the number of nodes in a tree with two nodes and the number of nodes in the tree with three nodes and now I'm ready to finish the job so now my solutions have gone all the way up five when we started this we said hey if I can count the number of nodes in fives left subtree that's rooted no to three and I can count the number of nodes in fives right subtree which is rooted to no 10 then I know how many nodes are the entire tree so three got back to me and it said hey there's two nodes below me and the tree that's rooted at me ten said there's three nodes in the tree that's rooted at me and now five can finish the job fives the root node and it can come back and it could say there are six nodes in this tree oh okay questions about that I know it hurts my brain to explain so I'm sure that it hurts your brain too to look at okay so we can go back and forth between the algorithm in the code but let's implement this okay you guys are gonna be surprised I hope and how easy this is so let's look through this code together for a couple of minutes because this is a this is a tree structure that we're gonna use a lot for the next week okay so I've got and again this is sort of good object review I have a class called binary tree I had this new static field that's of type random and I'm gonna explain what that does in a minute okay then I have an inner class called node this is sort of like my list remember my list had an inner class called item this is a node in the tree this is a binary tree every node has zero one or two children and we refer to them as left and right so my node data structure it stores of value remember I do want to store data in this tree and we'll use that data later when we do some algorithms on trees for now we're just counting the number of notes so the data is sort of irrelevant but I have a way to store a reference to an object so I can sort any kind of data I want this tree and then I have a right child which is a reference to another node a left reference to another node and I have this constructor that I created it just sets the value here okay so now down on line 13 there's a lot of code here so we're gonna go through it together we're not gonna add much but but there's a certain amount that's needed just to kind of set up a tree and there's actually already a recursive algorithm in here I'm gonna show it to you all right so the one thing that my tree needs to know is what is the it needs a reference to the root node that's the top of the tree all the other references are stored within the tree so once I find the root I can find its right child and its left child and I can find their right and left children I can essentially explore the entire tree all right so I've got my root node and then down here here's what I want to look at together for a minute here I don't want to explain this in a great amount of detail but I just want you guys not to be a freaked out by it this is this is as simple as I could make this believe it or not okay so the question is for the purposes of running these examples we need a way to build a tree so how do we build a tree well what I want to be able to do is I essentially want to be able to add nodes to my tree I want you to give me a list of objects and I want a way to add them all to the tree and in order to make our examples sort of interesting I also want to be able to add them I want to carried a random tree so the trees that are created by this algorithm contain all the values that are in the array that's passed into the constructor but those those object values might be anywhere in the tree there's only a couple of rules about where things go that we'll look at in a minute okay so when I added and when I add an object to the tree I call this function called add so if you look here at the constructor it takes a list of object references and it adds them one by one to the tree so teeps keeps calling add add add and it calls add on the root node and adds a new value to the tree so here's how my add function works it takes a two arguments the first is a reference to the current node that's the current place where we're going to try add that note the second is the value to add that's sorry that's the current place where we're gonna try to add that value to the tree however it's possible that that note let's say I so let's imagine that I run this algorithm and I run it on the root note so the first time the root is null and so I can add a node right away the first note I add to the tree becomes the root note then I add another note so that could become the roots left child then I add a third node that could become the roots right child the problem is at that point what do I do because I'm out of know I'm out of spot right I can only reach the root node and so what I've done here is I've actually provided a recursive add algorithm so what this does and it's a little bit trickier than this so so let's look at what happens inside the add function so first of all if if the root node is null so the first time this cut gets called there's no root node if the root node is null then I set I create a root node by creating a new node but the value that was passed and studying the root reference to that note at this point the tree has one node in it otherwise here's what I do so this goes back to this random reference that we had above random is part of the Java standard library and it's a collection of methods that give me random values one of the things I can ask random for you can ask random for a random int for random double but one of the things I can get from it is a random boolean so this gives me a random yes or no value or random true or false so half the time random next boolean is going to return true and I'm going to enter the top part of this if statement the other half of the time it's going to return false and I'm going to enter the bottom half of the if statement in the top half of the up statement here's what I do if the current node doesn't have a right child so if current out right is equal to null I add the value to the current node as its right child I do the same thing down here so if random next boolean is false and the current node doesn't have a left then I add the node as the current nodes left child otherwise now here's where things get interesting I call add to restart my algorithm on either the right subtree of the current node or the left subtree so essentially the algorithm works as follows it says I'm gonna try to add the node if if half the time I'm going to try to add it to the right half the time I'm going to try to add it to the left if the node doesn't have a right child and that's what I've decided to do I'll add it as the right child otherwise I'll add it to the right subtree of that node if the node doesn't have a left child and that's what I've decided to do I'll add it to the left side of that node is this left child otherwise I'll restart the algorithm on the left subtree so this is a recursive Alvin right essentially it's making the problem of adding a value smaller every time by adding it to a smaller sub tree where there's more likely to be space okay that's this is a more sophisticated recursive algorithm than I would expect you to understand right now but I just wanted to talk through that quickly all right so here's what we're gonna do we're gonna write this and I also provided a recursive two string function you guys can look at that yourself alright so this code should work it creates trees properly I can add I'm creating in a tree with integers in it I can add as many interest as I want to this tree the two string function prints out all the values in the tree but let's figure out how to count the number of values in the tree so I want to implement this size function okay so a lot of times if you look look at the two string function so I have a public two string function that takes no arguments that calls a private two string function with the different signature and this is something that we're gonna see a lot when we work on trees when we write a recursive algorithm we're gonna we're gonna start the recursive algorithm on the root note right so let's let's use that same structure to do size we put that here so I'm gonna create a private method called sighs and that private method takes a takes a reference to the node to count them so essentially this is the root of the subtree that I want to count the number of nodes it okay and when I call size I'm essentially going to return the size started at the root right so this is now gonna still do the same thing because I haven't implemented my recursive algorithm okay well let's do this now what's the so when we when we went back here right what was the simplest subproblem that we were able to identify at what point do i have to solve the problem there's a certain tree that i should be able to count immediate how do i know that i've reached that point yeah yeah so say if current left is equal to null and current dot right is equal to null what do I do turn 0 what about me I'm at a node remember right this always gets run on a note so we're close if I'm counting and if I'm counting a tree that it only has one node has no children then the size of that tree is one yeah so here let's return one okay so this in a recursive algorithm is sometimes known as the base case this is the point where we cannot continue to make the problem smaller there's no smaller problems here I found a node there's no children I have to be able to count that tree there's no way to make there's no smaller problems there's no right subtree there's no left subtree okay otherwise so let's say let's do this so here's what I'm gonna do I'm gonna create this value and let me call it count set of size sizes the name of my function so I'm initializing count to 1 make sure I count me okay now what are the two smaller problems that I want to solve ok so again I can't count all the nodes in the tree from here but I know what are the two smaller problems that I want to solve so I met some node I know that this node has either a right subtree or a left subtree maybe both right what's one of the smaller subproblems that I want to solve this okay so the size of the left sub-tree all right so let's say count plus equals size of current dot left okay this is where for some of you your brain is going to start to explode a little bit I'm in a function and I'm calling the same function it's weird pod there's no reason that this doesn't work right now just just sort of like put your worries aside for a minute about whether or not this is actually okay I'm just the function that I called size is supposed to count the number of nodes and put a little comment above it count the number of nodes in the tree rooted at current so I can call it on my left sub child now I need to this this code isn't quite right yet can someone help me here if I run this this is probably going to cause a problem sometimes yeah I might not have a left sub-tree so let's just fix this here let's say if current out left is not equal to no then I'm gonna count my left sub-tree all right what else do I need to do yeah yeah I can't ignore my right sub-tree right so now I'm gonna do essentially the same thing I'm gonna say if I have a right subtree then the number of nodes in the tree routed at me has to be increased by how many nodes are my right subtree so this is essentially 1 plus the number of nodes in my left subtree plus oh wait sorry no that's right count plus equals so 1 plus the number of nodes in my left subtree plus the number of nodes in my right subtree okay I'm gonna change this down here to return count and let's see how how we went oh man check style it's what you guys signed up for there we go yeah seven is this right let's look at the let's look at the example I did here one two three four five six seven I'll look story let's take off a few nodes here five oh that's right okay first recursive algorithm this recursive algorithm has a book who can tell me what it is I can provide an input that will cause it to crash who can tell me what that is yeah Kern is no but how do I get current to be no normally I'm not gonna start the algorithm a current is null but there's one special case here yeah way in the back what's that okay so the length is zero but how would I get a link to be zero yeah oh only okay so let's try that so I only have a root that would be one node that works you're close we're heading in the right direction here what about this guy boom so what happened here my root is null so when I ran the algorithm here they go up here sorry let me move some things around here so that this is closer to the example code that we're messing with I'll just put the two strings stuff up here better okay so here's the problem in this example root was never set to anything it was no and so I called size root and then I started using root as if current is if it was a valid reference so let's say if I do this I'm going to put another so this will handle that case okay good all right okay so this is correct and this is the thing that most closely matches what we talked about when we went through the diagram does anyone have any questions about this I do want to go slowly here because this stuff stuff totally totally get that again like I mean I still remember I don't remember much from 20 years ago literally 20 years ago this semester when I took into a programming for the first time but I do remember recursion and struggling with recursion and being confused by it so it's not unusual to feel queasy weirded out a little bit by this type of approach okay so let me let's do something together here and this is going to be characteristic of our other tree algorithms it's gonna make this a lot nicer okay because I promised you this was going to be simple but what we have up there it works it's correct but it's kind of kind of not not as nice as we would like okay here's what I'm gonna propose what we're doing right now is we're stopping our recursive algorithm when it gets to the Leafs right so if I look at my code when I get to a leaf node this is known as my base case if the current node has no left or right child it's a leaf node and I return one but here's what I'm gonna propose let's let our algorithm not only get to the leaf nodes but get to an empty reference so let's imagine that we allow the algorithm to walk off the leaf nodes and a walk essentially into an empty tree so everywhere where I have a reference here that is to an empty tree so three has a reference to an empty trees it's right child seven has two references to empty trees nine has two references to empty trees one has to represent a tree so what's the size of an empty tree if I go to a tree if I get to a node that's null what's the size of a tree rooted at no no zero right if I so imagine if I ask how many nodes are in sevens left subtree the answer is zero right how many notes are in sevens right subtree the answer is zero so here's what we're gonna do we're gonna keep this little part in here from lines 56 to 59 what this means is that we've walked off the end of the tree we got here because we followed a left reference or the root or right reference that led us to a tree that didn't have any nodes in it at all so those trees are empty they have size zero if we do that let me show you why we're gonna do that if we do that then we can do the following okay we can say that the size of the tree is 1 plus size of current left plus size of current dot right it's gonna work let's try it put some nodes in here let's see how we go it's like it works okay so now this looks nice okay so why is this working let's just linger here for a minute think about so before that code that I deleted a lot of it had to do with avoiding know right what happens if current out left is null because I could because the problem is I couldn't call size on a no reference it wasn't safe but now the point is that my base case is if I get a no reference if you give me a reference to a null tree I know the answer I know how many nodes it are at zero so now I can write my I can write this algorithm recursive algorithm much much more pleasing way right this makes me much happier as a computer scientist it says how many nodes are in this tree one plus the number of nodes in my left subtree plus the number of nodes in my right subtree that's exactly what we had worked out together when we went through the diagram the only difference is if my left reference is know my left subtree has zero nodes in it if my right reference is null then my right subtree has zero nodes in it but my size algorithms my size is gonna handle that because if I walk into an empty tree it's just gonna say there's no nodes here all right questions about this because this is typically what we're going to do when we write our recursive algorithms the reason is there's so much nicer all right so look at what we may just go back up here you know look at what we started with all right we started with this okay so I have deleted 10 lines of code I gotta recreate this and replace them with one line of code and no again I am NOT I don't want to be here to sort of encourage you to to idolize code that's short that's actually not good I was actually reading the creator of Python whose first name is Guido and whose last name I'm not gonna try to pronounce but he apparently went to work at Dropbox for a while Dropbox is a company maybe you've heard of apparently Dropbox used this Python a lot internally I don't know why but so we know decided to go there and work because they did a lot of Python work and he is the person who created the Python language but apparently one of the things that he did that he spent a lot of a time encouraging there does their engineers to do was to stop writing such clever code he would find code that was overly clever and he would say you should make this more clear you know it probably gets longer right but stop being so cute with how you design things right you know a shorter algorithm is not always better a longer algorithm in lines of code that's more easy to understand is frequently superior however in this case this line really distills exactly what this algorithm does it counts the number of it counts me the number of nodes in my left subtree and the number of nodes in my right subtree so I I think this is a much clearer formulation so this is what we're gonna do in the future we're gonna handle null as our base case figure out what to do there and then we'll allow ourselves to essentially walk off the tree all right because we know that we can do that see any questions about this before we go on yeah yeah yeah so the question is why can I call sighs inside sighs the answer is you can you will figure out why you can later and I don't want to go into it it's complicated but essentially when I call size inside size it behaves like any other function so when I start on the root what let's let's do this it's hard to do with this one we'll come back to this later so the idea is when I call size on the root node let let let me let me make this example a little smaller one two five okay when I call size on the route here's what happens so my size function starts running it's running on the root node the root node here is value 1 then it gets to this line and it says oh I need to run the size function and it calls size on current dot left my first copy of size is now waiting for the second copy to finish so the second copy of size starts running it says um I called on no no therefore I have some work to do so it gets down here and it calls size again so now I've got three copies of size running now both and I'm about to have 4 because I'm gonna call size dot left in size dot right both of those functions are going to return right away because they're gonna get to a null reference and then the second copy of size is gonna finish my first copy of size is now going to call size again on the right and the same thing is going to happen so there's really no difference I mean if you want to think about what's happening internally fine but there's really no difference between calling a function inside a function and calling the same function inside a function it's something you can do I could call to string I could call whatever right I can call a function inside another function and the function that gets called does its work and the function that called that function waits for it to complete and then proceed so there's really no difference here the fact that I'm calling the same function is just sort of a anomaly that's due to how I structure this problem yeah why do I have to sighs methods right so the idea here is that I don't want it's a great question so see here my root nodes private my tree class is not going to expose its structure to the people that use it it's gonna say you know what you don't need to know how I implement a tree I am a tree I've got leaves I've got nodes it's all good if you want to use me I'll tell you how to do it so if you want to know how many nodes are inside this tree you call size see here I'm calling size with no arguments right so anyone outside of this class doesn't can't access the root node right internally what I do is I say ok if I want to know this number of nodes in the tree I called the size function that starts at the root yeah great question so that's why I have an overload here we're gonna do this every time all right when we do other recursive functions alright let me give you guys some advice about recursion because again this is a tricky concept it's something that can be hard when you get started it takes practice you're going to get practice you're gonna be okay so first thing here whenever you write a recursive algorithm is you eventually have to stop this process of making the problem smaller has to reach an end it can't continue indefinitely if you can't try to continue it indefinitely your program is never going to to end okay this is sometimes known as a base case that's the point where you are solving the puzzle so here our base case is when current is null that's the point where I don't call size again I'm done I've walked off the side of the tree and there's no nodes there to count okay make the problems smaller in each step if your each step of your algorithm simmer down isn't making the problem smaller then again you're never going to stop you have to make the problem smaller and smaller and smaller to eventually get to the point where you have a problem that's small enough that you can solve this is known as the recursive step so again back here I'm calling size on my left subtree that has fewer nodes in it than the whole tree that's a smaller problem I'm calling size on my right subtree that has fewer nodes in it than the entire tree that's a smaller okay and finally figuring out how to combine the results together so again I've got one line here that one line is doing two things first of all it's solving two smaller problems the number of nodes in the left subtree and the number of nodes in the right subtree and then it's combining the results together it says the number of nodes in the tree rooted at me is the number of nodes in my left subtree plus the number of nodes and my right subtree plus one to count me all right so here's so here's another example of a recursive algorithm I don't want you guys to think that these are all confined to trees so this is an implementation of factorial right factorial of a number is the number multiplied by the number one smaller than it until you get to one right so just like we talked about this has these these features so here's my base case the factorial of 1 is 1 that's the problem I know how to solve otherwise what I do is I say I know that the factorial of a number is that number times the factorial of the number that's one smaller so here I've got my recursive here's my recursive step I'm calling factorial n minus 1 and here's combining the results together all right so base case is when N equals 1 the recursive step is calling factorial of n minus 1 that's what makes the problem smaller because I'm going towards 1 I hope and combining results together is multiplying the current value times the factorial of the number that's one small all right here's the problem though I have to reach the base case remember I have to stop at some point so I'll give you guys you know last little problem before we break up today how can the code above fail so this code can fail to reach the base case yeah yeah or how about zero or negative number yeah so what's gonna happen here I'm gonna say okay I need to compute the factorial of negative four well how do I do that I do that by computing multiplying negative four times the factorial of negative five right okay how do i compute the factorial of negative five well I compute the factor over five I multiply negative five times negative six right how do i compute the factor of negus six by be the factorial maybe six by combining I would multiply negative six by negative the factorial negative seven right this is not going well right I am NOT going to get to one so if you try to run this code in the playground you're gonna get a runtime error and this essentially men means that you you never got to one you kept calling factorial over and over and over again trying to solve the problem but you weren't making the problem small you weren't getting towards the base case okay this is where we will pick up on Monday I don't really have much of anything to announce today I hope you guys have a great weekend stay warm just to the new climate good luck finishing up mp3 the third checkpoint and I will see you guys on Monday  
﻿ right back everyone so today we're going to just stop and do some recursive examples together on trees that's really all I have today we'll talk a little bit about how and when to use recursion and we'll look again at the factorial example that we ended last class with on Friday just as an example of a recursive algorithm that does not use a tree you know the danger with doing this like we're gonna do it where we're gonna get a lot of practice on trees which are in many ways a really nice fit for recursion but I don't want you to conflate the two too closely recursion is a problem-solving strategy that we can use on a variety of different problems and with a variety of different data structures on Wednesday we'll look a little bit more at recursion on non tree data structures just to sort of drive that point home but today the practice we're gonna get writing some recursive algorithms is going to be on trees all right so you guys had a nice weekend and let's get started so when were you know so again for some of you many of you I hope this is new the idea of using a recursion to solve problems and it's one of those things like I've warned that takes some practice getting used to take some time thinking about what's happening and our goal today you know my goal today is to try to help as much as I can you know so please as we go through I don't have a huge amount to cover today we're going to spend some time doing some examples together ask questions if you have you know this is something that can be a little weird right once we get started here are some strategies that we will follow and you will find helpful as you design recursive algorithms okay the first one is you have to so remember recursion as a problem-solving strategy solves problems the family of algorithms it's sort of a feature of algorithms that involve solving problems by trying to make the problem smaller that's our first goal is to figure out is there a way to take a big problem a more complicated problem and make it simpler boil it down a little bit break into smaller pieces however we have to know when to stop we have to know the point at which we've reached a problem that's so small that we need to be able to solve it when you recursive algorithm does this is sometimes known as the base case for building a recursive algorithm a lot of times in your recursive function or near recursive implementation of an algorithm it's the first thing you do you check to say okay M is this a base case this is a place where I need to stop so that's the first thing right the second one is the problem has to get smaller so if this step that you are performing that tries to make the problem smaller actually doesn't produce smaller problems then your recursive algorithm will never get to the point where it creates problems that are small enough to solve and it'll never finish it'll never get the job done so on trees every time we tear a tree into two pieces every time we look at the right and left subtree of a node what's critical about that is those trees are smaller than the tree that's rooted at the node that we're at they have to be they don't contain that node and they also you know the right subtree to us and contain all the nodes that are in a left subtree and the left subtree doesn't contain all the nodes that are in the right subtree so we know that we've essentially created two smaller problems right that's why recursion one of the reasons why recursion works so nicely on trees when we talked about recursion on lists on Wednesday we'll say you know the recursive problem makes the problem smaller because it produces it starts again on a smaller list so if I have a list with n elements and I reduce it to a problem of solving a list with n minus 1 elements that I made the problem smaller if I can continue that eventually I'll get to a list with just one element that I can solve easily and then a big part of designing good recursive algorithms is figuring out once I've solved two small problems how do I combine the results together to help me solve the bigger problem so the bigger problem is a function of the solution to these two smaller problems but how exactly do I do that how exactly do I put the results together all right so this is what we looked at last time and again this is a nice example of recursion a couple of reasons the first one is it is nothing to do with data structures this is a mathematical function that we can compute recursively since factorial factorial of n is n times I minus one times two minus two times I minus three in fact it actually has sort of a recursive definition all right the factorial then is equal to the factorial of is equal to n times the factorial n minus one and we can continue defined in that way until we get to one the factorial of 1 is 1 all right so here's a recursive recursive implication of factorial so the first thing I have is my base case remember I have to make the problem smaller here when we make the problem smaller we're actually what we mean is that we're computing the factorial of a smaller integer we're not actually computing something on a smaller tree or on a smaller list so my means smaller here we actually mean smaller number right so this once I get to one I know what the answer is my definition of factorial of 1 is 1 otherwise I'm gonna make the problem smaller so I'm gonna say ok I don't know how to compute the factorial of n but I know from the definition that the factorial of n is n times the factorial of n minus 1 and so now I've made the problem small alright so here's my base case write the case where n is equal to 1 you'll see that when we reach the base case this is an important way to identify the base case when we reach the base case there's no recursive call so you'll see if you ask me what the factorial of 1 is I know I don't need to compute it based on the factorial of some other number alright so there's no call to myself or any other function in here there's just a definition right this is the definition of factorial factorial of 1 is equal to what my recursive step so where am I making the problem smaller that's over here factorial of n minus 1 so if I don't know how to compute the factorial of n I do know that by definition it's n times the factorial of n minus 1 so now I've produced a smaller problem right I'm trying to compute the factor a smaller integer and then finally the combination of results here is the multiplication step right so I could so for example I could have a different function I don't know what maybe there's a name for it right a different function that was the sum of all the numbers from n to one and there I would replace my product symbol here with the sum but the definition of factorial is that factorial of n is n times the factorial of n minus one okay so this meets all the criteria that we have set up for a recursive algorithm it's an implementation of a recursive algorithm now remember when I make the problem smaller I have to actually reach the base case so this is another common problem with recursive functions is they may think that they're making their problem smaller but they also may do so in a way that never actually reaches the base case that they've set up and last time at the end of class what somebody pointed out here is that if I start this function on a negative number or 0 if I started on one I'm good if I start it on two it's going to be 2 times the factorial of 1 if I started on 4 it's gonna be 4 times the factorial 3 times the factorial of 2 what right so this is gonna work if I started at zero an algorithm is gonna say ok well I don't know what the factorial of zero is but what you told me to do is compute the factorial of zero by saying it's zero times the factorial of negative 1 this is also kind of dumb right because as soon as I have a zero my product I should just stop doesn't matter how many other numbers I've all to play in that results going to be zero but let's say I did negative 1 negative 1 well according to this the factorial of negative 1 is negative 1 times the factorial of negative 2 well it's factorial negative 2 negative 2 times the factorial negative 3 that's factorial negative 3 3 types of doctoral negative 4 this will never finish keep going and going and going and eventually it's gonna run out of run out of memory all right so if we try to run this let me see if this works let's put a print statement in here to see what number we're trying to compute the factorial for and I don't think it's gonna let me do this no you can see that it tried really hard right it just it kept going and going and going and it was it was really trying trying to do what I asked but a lot of time a lot of time on time and eventually what will happen is that the computer will be using so much memory to run this computation that job will realize that something is wrong and your program will be killed all right so this is a stack overflow error we'll come back and talk about this a little bit later in the class when we talk about errors and exceptions but for now you can just think about this a sign that something went wrong right I was never able to solve the puzzle because I wasn't approaching one alright so sometimes we refer to this as approaching the base case my recursive algorithm in each step has to approach the base case here I have a base case but my recursive step isn't approaching it if I start it with a negative number if I started with a positive number I'm fine right okay so let me uh let me offer a caveat here so this is one of those places you know in your training is a computer scientist where I think you actually get to exercise a fair amount of discretion and a fair amount of you know maybe some aesthetic judgment here let me let me clarify one thing right now because people people some people have weird ideas about this there are no problems that you can solve with recursion that you cannot solve using an iterative approach and there are also no problems that you can solve using an iteration that you can't solve using a recursive approach in fact there are whole programming languages that don't have any loops in them at all okay so as far as problem-solving strategies they're completely complementary you pick a problem I can find a recursive way to solve it that recursive solution may be really stupid it may not be a good recursive algorithm for that problem but in most cases I shouldn't say most in all cases you have the choice right can produce an iterative solution to the problem and you can produce a recursive solution to the problem when you're starting out we started out this semester looking at loops and looking at studying variables and things like that we essentially trained you and I think a lot of introductory computer science courses still do this you a lot of you have been raised as iterative programmers so when you would count when you encounter recursion one of two things I feel like tends to happen both of which are bad right the first thing that happens is people get scared and they're like I don't get that I'm not gonna do that that way and they tend to shun recursive approaches and they won't use all right so that's bad in one way the other thing that's bad is people are like this is so cool and I can use it to impress all my friends who don't understand recursion and they start implementing everything using recursion even in places where it's not appropriate Hey and of course you know the right place as in many things in life is in the middle ground right but that forces you to make judgment calls right recursive solutions can be difficult to understand I would argue at times whenever you solve a problem as a computer scientist your goal should always be to produce a clear concise solution and actually we have some ways that we're going to help you with that that I'll talk about in a minute on some of the upcoming programming problems your goal is to write code that is clear and understandable not that is designed to make you look good or impress people right the people out there who will be really impressed by your code will be the ones they use it and have to mess with it a little bit and are like this is really clear and very well documented and intelligible right that's what impresses people not the fact that you use too particular programming technique okay if an iterative solution is more clear use it all right if a recursive solution is more clear use that all right that's the simplest way to make this trade-off it's simple in the sense that it's an easy principle but I understand this is hard to apply this is why people tend to either be sort of all-or-nothing about recursion they're either just like I'd want to do Birol recursion all the time or I'm never going to use recursion even in a place where would produce a solution that is much much more clear okay applying this discretion here is difficult and it will take some practice and we'll take some experience right but please don't do this this doesn't impress anybody don't use recursion just because it's like oh man my function call itself so cool you know like no one cares right what they want is they want to see you solve problems in a way that's clear and that can be integrated into other pieces of code and shared with others okay here's the other thing you hear people say that like well the recursive of the Dacian is shorter I don't care you know like have you guys ever seen these obfuscated code competitions out there has anyone ever seen these so there's these competitions for like writing a piece of code that is completely understandable but does something useful right so actually I remember someone once wrote an mp3 decoder it's like one line it goes on for like thousands of characters right every variable is like one letter you know and you can't make heads or tails of anything that's happening but it decodes mp3s it really does work okay do not do this like this is not your goal right so the number of lines of code in your solution is not a measure of how good it is now if you if it takes you 200 lines to solve a problem that someone else solved in 20 lines you have a problem right but if it takes you 30 lines and your 30 lines are more understandable than their 20 lines you're the winner okay so code length is not something that we use in the programming community to evaluate our contributions clarity okay so here let's come back to factorial here's an example of another way to skin this particular cat this is an iterative approach to factorial and when you think about the differences between these two techniques I would really encourage you to put these side-by-side in your mind the tree examples that we're doing right now are very very hard to do it it can be done require some data structures that you guys haven't worked with on homra problems yet but factorial it's like I can put up the iterative factorial and the recursive factorial and we can just compare the two of them this also computes factorial it computes factorial using a loop number loops kind of nice right so what do I do here I start with the result I set it to 1 and then I go from 2 to whatever the number is that you wanted me to compute the factorial of and I just keep multiplying my result by the next number that's part of the factorial this is correct it will work the recursive solution is also correct it will also work right these are indistinguishable from each other in terms of correctness which one do you prefer let me actually just get a show of hands here how many people like this version better then there were cursive version okay how many people liked the recursive version better than this version okay I like that yeah and then one thing that's nice about the recursive one is it's more it's closer to the mathematical definition of factorial it's kind of nice right so again it really depends on the problem I use whichever one you like and and don't worry too much more about the trade-offs okay any questions about this we're about to do a little problem together so let's clear up any questions about factorial or about when to and do not use for cursory questions about this okay so let's apply our problem solving strategy to this particular problem okay so we're gonna write a recursive function together the next few minutes and here's the goal given a tree I want to print out all the values stored in the leaf nodes okay I don't want to print out values that are stored in and you know that has children but when I get down to the leaves of the tree I want to print the values our tree node store values whatever it's stored in the tree that ends up in the leaves that's what I want to print okay so let's think about how to solve this problem recursively okay so what's the first thing we need to do I mean actually we can start in a variety of different ways I'm gonna give me a step here so I want to print all the values in the leaf nodes of the tree remember there's three things I need to do solve the smallest problem make the problem smaller and combine the results together so what's one thing I need to do yeah so what's yeah what's my base case how do I know when to stop your yeah yeah the question is how do I find the Leafs so a leaf known in a tree is defined by the fact it has no children in our binary trees I store the children as the right reference and left reference so if my right reference is now all my left reference is now I've reached a leaf at that point what should I do printer right okay so my base case is I've reached a leaf and I'm gonna print the value of that all right how do I make the problem smaller so let's say I happen so if I haven't reached a leaf node what do I need to do well I need to make the problem smaller right so if I'm not a leaf node then I must have either a right child or a left child so I have a right subtree and a left subtree so what I'm gonna do is I'm gonna say hey I don't know how to print you know I don't need to print myself because I'm in on a leaf node so what I'll do is I'll just consider my right subtree and my left subtree separately I'll say okay I'm gonna restart my algorithm to print all the leaf nodes in my right subtree and then I'll also restart it to print all the leaf nodes and I left subtree if I have right and combining the results here is sort of done for us right so not every recursive algorithm needs to have this step in this case what's gonna combine the results for us is the output all right that's where we're gonna see how things work okay so let's do this together here's our starting point this is our normal tree class I've set up a print leaves function for you guys to work on right here so let's just go back here and let's kind of like do this based on our on our algorithm okay so the base case here is going to be if okay so the first thing I need to do is I need to write this private wrapper function that's going to actually run on a node so this is similar to what we did for size and this is similar to what we're gonna do for our other functions and my public print leaves function is just going to sort of reflect the function call in to the private version that starts at the root okay so now let's do the following so I'm gonna say if my if I've got no children I'm this is this is the base case right then I'm gonna print the value at this note alright that's my base case right not make that noise alright what else do I need to do so I've got the base case in there that's always a good place to start alright if you start writing your recursive algorithms without a base case they'll tend to not stop and you'll get those Stack Overflow errors that we were seeing on factorial just a minute ago so it's the base cases is always a good place to start every recursive algorithm has a base case and so getting that in place is good ok what else do I need to do here yeah yeah so let's let's well let's get there let me come back to that so I've got my base case this is if I found a leaf I'm gonna print the leaf and I'm also gonna return right because I don't I don't need to do anything else here I found a leaf node there's no tree to go down oh sorry alright so my recursive step here is to look at my right and left subtree so how does that work here this is kind of an interesting case too because this recursive function does not return a value it's just the way it outputs things is by right into the terminal okay so how do I make them so I've handled the base case but now let's say I get to line 58 because I'm not a leaf node what do I need to do we can help me out here yeah yeah so I need to call print leaves on current dot laughs that's my left sub-tree so I'm considering my left sub-tree and my right sub-tree step so essentially what I'm gonna do is I'm gonna say if I'm a leaf node I'm done for myself otherwise print all the leaf nodes in my right subtree and print all the leaf nodes in my left subtree now somebody pointed out a problem that I can have here right which is that and this is similar to what we talked about when we looked at size so let me do this a little bit differently here first so let's say if current dot left is not equal to null so if I have a left subtree let's go into my left subtree I'll put the same thing down here so if I have a right subtree so what I'm trying to do is to make sure that print leaves is never called with a null reference we don't have to do that we can fix that in a minute okay so let's run this so that looks like it worked okay now I don't know for this particular tree what the leaf nodes are because I'm building the tree randomly I know that one is definitely not a leaf node okay so I should never see one in the output and if I run this a few times what you'll see is that I'll see four I'll see three sometimes I'll see two because sometimes two ends up as a leaf node but I never see one okay so I'm pretty sure that this is correct now somebody suggested that we check for null and there's a couple things that's going to have helped us with so the first problem is this and this is the exactly same thing that happened to us when we worked on size which is that when the tree is empty and the root node is null then I get to line 55 and I start checking dot left of null and because I have a no reference these these key references blow up so let's put in a check for null here if I what does it mean if current is not what have I reached I'm not in a leaf node I'm not in a node in the tree I've reached end this is essentially an empty tree right if I somehow got to know it means I walked off the side of the tree or maybe a rootless no but the point is I've reached an empty tree and when I've reached an empty tree there is absolutely nothing I need to do there are no leaf nodes in an empty tree so there's nothing to print now when I try to print the leaf now it's in the empty tree this air is going to go away and the other thing I can do to make my function a little bit nicer is I can get rid of these checks so now because I'm handling null explicitly put some values in this tree again I have seven I can also I don't have to worry about walking off the side of the tree all right so I reach an empty tree I say I just returned alright questions about this so here on the dis label is four here's our base case this is the recursive step that's what's actually making the problem is smaller here there's no combining of results together again like I said that's happening on the output the output display is what's combining the results no so so it's a great question so the question is do you always need a wrapper function um sometimes I mean really so you might wonder why are why am I using this wrapper function right and the reason so so here's the explanation I don't want I want the root reference to be a private part of my class so remember we talked about interfaces we said the interface defines the public part of the class it defines what the other class is good to use I don't want other classes poking around at the root node of my tree they have no idea what's going on and they're they'll probably break it right if you made route public somebody you could set route to null and then your whole tree would just be gone okay so I don't want people to know where the root is I would like them to be able to print all the leaf nodes that's why I wrote this handy function but in order to so essentially in order to expose this private information right what I do is I take I provide a public method called print' leas that takes no arguments and i just use that to start this private method that knows where the route is okay but there are also cases where you do kind of want a wrapper function right you'll find like this is a technique and and you guys are gonna most of the tree functions that we write will have wrapper functions but as you go on in other classes you'll find yourselves in places where you're just kind of like I know I can use a recursive function here but I'm not sure exactly how it should work and sometimes app adding a wrapper function helps it's a great question okay other questions about this our next example here we have another one of these that maybe we'll get to later all right so let me pause and talk about a new feature of the homework problems that starts today so there is a homework problem out today I wasn't posted at midnight but it's up now and there there are tree recursion homework problems throughout the rest of the week okay and this is something that we haven't done before so I just want to talk a little bit about what this means so for the remainder of this week and as many in as many places as we can throughout the rest of the semester there is a small amount of credit on each programming problem homework problems not in the CBT F only on the homework problems it's like one point for writing what we call perfect code now look let's not get hung up on the word write perfect is taking on new connotations recently as well this is we do not know if your code is perfect I am not sitting there at night being like yes perfect yes perfect no one has looked at this your code can have many problems that are not detectable by us but there are a couple things that we are going to look at and we are going to take this point off if your code is imperfect in either one of the following two ways the goal here by the way is to help you write better code so one of the here things I hear all the time from my you know colleagues in the department is you know all this Auto grading that you guys do in these intro classes the students don't know how to write better code because you know no one ever looks at it I have to say you know you guys are like the now fourth generation of students that have used Czech style the downstream instructors are so happy that we use Czech style okay trust me they're like I used to get students and would write everything and like all unand nted and stuff like that and now they just know what to do all right so we're always looking for ways to help you guys improve the code that you write without you know having to read all of it because we don't really have time to do that so this is in this vein right this is our goal our goal is to help you develop as programmers and computer scientists by thinking through what your so there are two things that we can detect automatically and we'll take this point off for the first one is if your solution contains code that is called dead I will define what these terms mean intimate so if your solution contains what's called dead code we will you will lose this point the other thing that will cause you to lose this point is if you have produced code that is overly complex and I will explain what that means in a minute that does not mean that it's too long this is a different definition of complexity and I got I'll present this okay so what do we mean by this dead code so what code in here is dead so first of all what we mean by dead code is the code that will never be reached or code that has never reached in our tests so here's how I know this code isn't perfect there is there's a line of code here that I can take away I can delete it this is correct but there's a line of code here that I can delete and the function will run exactly the same it'll still this is correct it'll still pass all the tests this is a size what you guys did on Friday right what's the problem yeah so so that's okay that's that's part of the problem yeah yeah okay so here's the thing if kern is equal to now I've returned zero so if I get to line nine I know currents not know so I will never get into this else statement this line of code returns zero will never be executed all right so this is dead from our definition this is a standard definition by the way this is what people mean a dead code yeah do you have a question so a question here just waving there I'm okay all right any questions about this this is pretty I think this is pretty intuitive so if I can take your solution and I can remove part of it and it's still correct it's not perfect right okay second piece of non perfect code right so I'm never gonna get to this this returns zero and we can detect that when we test alright so again I just want to point out these are both correct again these are cases where this is correct code and we're pushing you to a little bit of a higher bar all right so what's wrong with this who can explain I mean the slide says what's wrong with it right but who can explain what's wrong with it tell me why what how can I make this code better there's another way to think about you know what why is this code wrong what can I do to improve it yeah yeah so great great point so I'm already checking for no here so I'm allowed to call size unknown I'm allowed to call the size of an empty tree that's zero I know what that is so all of these lines here line 10 line 12 in line 14 can all be replaced with just line 14 right so I don't need to do all this checking of my right and left subtree and stuff like that so this is this is what we call over the complicated code there are four paths through this code so I can return here I can return here here or here the problem with that little complicated code is when somebody reads it they have to think really hard about what's going to happen or if they have to think harder so in order to measure this what we do is we essentially count the number of ways that our test Suites can work their way through the code that you wrote if that's a large if that's more than a certain number more than our solution then we're gonna take off this point now let me just reassure you our solution is not like tricky our solution doesn't our solution is a solution that that you know it's provided by me that's designed to be readable and correct and minimal but it's not like doing things that we wouldn't expect you to be able to do okay the solution there only two paths so you imagine I removed that whole if statement that starts on line nine I replace it with only line 14 now when someone reads your code they don't have to think well why would I get to line 12 why would I get to line 10 why would I get to line 14 the more paths there are through your code the more someone who's reading it has to think about what would happen and that thinking that makes their code harder to understand okay any questions about these new criteria and again we'll try to use these in as many places as possible throughout the rest of the semester it's one point you're welcome to ask for help with this one point yeah No there are no points for perfection in the CBF only on the homework problems yeah one like I said it's not very many points you guys are welcome to ask for help on it our goal is to help you write better code alright and I and I think this does help actually we've had some really really good conversations with students in the past you know around how to get this point because it makes you think about what happens when the code is being executed right when you can identify dead code when you can find places that you can reduce the number of conditionals that you need in order to express a solution you're making your code better okay questions about this just don't want to spring this on you guys on undiscussed all right let's do another problem so this one's fun actually this is a this is another expansion of our abilities and thinking about recursion all right so our trees and this is also fun because it's one of the first places we could to use the values in our trees right up until this point we've been only doing things that didn't really exploit the fact that these trees store values so now let's do that okay so we're gonna write a recursive tree search function the goal of this is to return true if a value is in a tree if my tree contains particular value I want to return true if not I'm going to return false okay so how are we gonna do this okay let's talk it through so base case yeah okay so so that's great point the empty tree is part of my base case does the empty tree contain a value doesn't matter what the value is I don't even have to tell you there's the empty tree contain of any value no all right so I know I need a base case for the empty tree the empty tree doesn't contain any value so in that case I'm just gonna return false okay what's another part of my base case though actually no no sorry I think that that is the entire base case right yeah so so the entire base case here is really the empty tree ignore the slides right how do I make the problem smaller all right so in next step all right so if I reach an empty tree I know that it doesn't contain the value otherwise where do I need to look imagine I'm in a note I'm actually at a real node where do I need to look for the value there are three places what's one of them yeah itself my left subtree my right subtree so if I contain the value or if the value is in my left subtree or right subtree okay I've got three places to look and remember either all of those are smaller I'm only one node my right I'm really trying to be correct about this my left subtree has fewer nodes than the subtree rooted to me and right subtree has two your notes on the subtree rooted to me so both of those are gonna leave me in a good direction okay now here's what's interesting how do I combine the results from these searches together okay so this function returns a boolean so whenever you think about your recursive algorithms you want to think what do I need to return because that can really give you some hints into how you combine the results my size function returned an integer and that was left sub-tree plus right subtree plus 1 this function returns a boolean value somebody who have been picked on yet today how do I combine the results I picked on your combine the results together so yeah yeah perfect so as such I'm gonna use a logical or here to combine the results and actually what I'm going to do is even more clever I'm gonna do if I have the value or if my left subtree has the value or if my right subtree has to die okay cool all right so let's let's let's do this bad boy all right so here you're also saying the first case that we've done where the recursive function takes an argument I need to know what to look for all right I'm taking an argument which is a reference to an object I'm gonna use object equality not reference equality here so I'm gonna use dot equals okay all right so I'm not gonna worry about let's not worry about no for now we would have to worry about null we have to figure out how we're gonna handle that in more detail if we were doing this for real but let's just ignore that so I'm gonna write a private function called search that takes a value and a current node to look where I'm starting my search and for now let's just return false and here now I'm gonna this is my wrapper method approach I'm gonna use my public method to start the search on the root of the tree okay so now again let's go back to my algorithm so base case right so we agreed here that the base case was an empty tree so if current is equal to null then I'm gonna return false an empty tree has no values in it so automatically this is nicely gonna handle the case where the tree doesn't have any content if I haven't had any added any nodes to the tree yet the root is null and this will return false right away okay all right so otherwise I have this recursive step I need to do so let's see here I'm gonna return so if if the if current is not null then current has a value reference so I'm gonna say current dot value dot equals value so that's me so I'm saying I have three places to look the first one is me now Chuck style is gonna get angry the second one is my right sub-tree or my left sub-tree I could start either way now you current left and the last place is my the order of these we might think that the order of these doesn't matter but we're gonna talk about that sucker okay so let's just admire this for a minute before we try to figure out if it actually works all right so my base case empty tree Fu treat us entertain denotes return false otherwise I look into three places that I need to look I look at me look at my value I know how to get to my value I search my right subtree in this case sorry I searched my left subtree first or my right subtree okay so let's see if this why is it hang what's angry about oh it's over here okay all right that so that looks right if I look for four let's make sure it does the right thing if I look for something that's not in the tree okay for a couple of things let's make sure it finds the root if the values of the root let's make sure it finds a value that's pretty deep in the tree I'm gonna build a bigger tree now look for value eight okay cool it's got a fun let me ask you a question so it could be you look this this will give me some sense if that you know you guys are developing some intuition about how this works so and this also brings us back to short-circuit evaluation all sorts of fun stuff all right what changes about this algorithm if I do the following okay so let's say that instead of looking at me first I look at my left subtree first and then I look at my right subtree and then I say what happens if I have the value okay what's different about this when I just wrote let's make sure it works first doesn't work it found eight is it gonna find one it's gonna find one is it going to find something that's not an integer yeah that works too they're gonna find it integers it's not the tree that also works okay what's what's different about this from a perspective of which is best maybe that's the best way to think about it which would you prefer which one's gonna be fastest more effective more efficient there is kind of a big difference here in terms of yeah yeah so let's think about how this imagine I'm starting on the route okay so from time to time the root nodes actually going to contain the value I'm looking for if I check myself first I'm done I don't even have to look at my right subtree or my loved subtree and remember short-circuit evaluation in Java means that as soon as an or statement is true we're done so if I find that I contain the node if I start at the root and I find that I contain the node I don't search my right subtree and I don't search my loved subtree blue my left subtree let's do this let's print off as we're going it's print currently at and then we'll do current plus value so let's look let's print off the value that we're actually searching okay so here and now let me search for something that's at the root all right so look what happened even though I was looking for a value that was contained in the root node my algorithm explored the entire tree before telling me that in fact it had the note so let's let's go back to you know the other idea was just to say let's look in myself first and then I'll search in these other places so now I only look at one node so this is one of those things where if you think about it and you convince yourself that you understand why there's a difference here you will this this is a good step on the way to understand recursion questions about this before hey this is a search algorithm you guys just heard a search algorithm it's kind of cool right I mean it's a simple one but this is not in a different family than the search algorithms that you guys the much more sophisticated ones you guys use all the time okay so here's another question so we've already looked at one little tweak that makes this algorithm more efficient by stopping allowing us to stop as soon as we find the value and not look in the rest of the tree but okay you guys think of another way to make this search more efficient yeah what's that so the sued essence uses an inorder traversal so I'm not sure that's actually really gonna help cuz I still don't know where the values all right so imagine the following since we're gonna pick up on Wednesday well leave you guys with this little nugget imagine that when I'm at a node right now if I go back and look at my code I have to look for the node both in my left subtree and in my right subtree I don't know whether or not the value would be in my left subtree or my right subtree it could be anywhere but what if when I built the tree I built it a little bit differently so that I knew if I was at a particular node I always knew whether or not the thing I was looking for would be in my right subtree or my left subtree all right so that is where we will pick up on Wednesday all right so there's a couple of announcements my office hours this week will be Wednesday at one o'clock there is a chapter of coders for next week all the coders reading assignments are on the calendar now as part of the quiz all right but I'll just give you a heads up for next week is chapter eight chapter seven for today's quiz these are kind of chapter 7s kind of an important chapter I have office hours on Wednesday I hope you guys have fun tomorrow's lab is a good time I will see you guys on Wednesday  
﻿ welcome back okay so last time we talked about a race and that was exciting because a raise really dramatically expanded the kinds of data that we could work with as a computer scientist so now I can not only store single values but I can work with series of values in order of the same kind and while there are some limitations associated with Java arrays it turns out that there's a surprisingly large amount of data that we can store as a series of values of the same kind we can represent music we can represent text we can represent the human genome we can represent you know a great deal of the recorded history of our species and a lot of information about what's going on around us in the world but we didn't get a lot of practice using those so that's one of the things we're going to talk about today we started to look at some new java constructs that we use to access and work with data and array something called a loop although the loops we've looked at we made leave me talking about kind of how to set them up and how to get them to loop a certain number of times we haven't talked about you know how to use them to access data in a race and that's what we're going to do today and then that's going to naturally lead us in the direction of starting to talk about a little bit more about what all this is for you know we've been talking about these very simple and basic building blocks super important stuff I mean again all of the really interesting things that computer science is doing in the world our grounded on these foundations but there's more that we can do and so we'll start talking about algorithms we're gonna do some introduce the idea of algorithm which is a very specific way of solving a problem and algorithms in many ways are very associated with computers talk about computer algorithms and I'll show you that the usage of the word algorithm is heavily associated with the computer era so a lot of times what were the algorithm is that we divide design and develop we're really doing that because we want to run them on a computer so we'll start talking about that this is fun on Monday well actually start to talk out how we can encapsulate those algorithms in a unit of programming logic called a function let's start off by reviewing a rape so last time we looked at a lot of new things today is more of a chance for us to step back and kind of solidify some of that knowledge okay so a job array represents one or more values zero more values of the same type now again it's unusual to create an empty job at write but I can do that by one it allows me to take a series of data and structure it so this was our first example of a data structure it takes a bunch of integers or a bunch of characters and structures then it puts them in order and in many cases again you can think about a book right if I take all the letters that you need to write you know any famous book and I just jumble them up I don't have the book anymore right what makes a poem what makes a novel what makes the human genome is order not just the building blocks it's only four characters in the human genome but put enough of those in order and I get an organism something incredibly complex and mysterious and strange okay so arrays are our first chance to do that right Alice has to work with structured data in Java oh okay that's not gonna happen it's weird happen once okay well it happened again we'll see so arrays put values in order right one maybe it's one of you testing out some sort of system that you're going to use to defeat me in the future all right it works right two for two now all right so arrays put values in order and the VAT so once I put data into an array I've associated a new piece of information which with each piece of data that I've added to the array it has a position so before it was just a letter but now it has a position you know it's somewhere in the book it's somewhere in the poem and that position is important as are the positions of all the other pieces of data to the department so Java has syntax that allows me to declare that I'm gonna work with data that's stored in an array and we looked at this this is you know oh I have the same bug as last time I fixed it on last time slides but not today I'll fix it again today please don't do that all right there we go so single value a single integer value that's how I declare it on line two if I wanted to clear an array if I want to work with multiple values I use this bracket notation so on line four I'm telling Java that the variable multiple is going to store not just one but multiple values of type integer same thing down here with the character so my variable one is storing one character my variable all is going to store an array of characters now I haven't told Java yet how many I want to store in the array and here's how I do that so on line two this is similar to when I was using single various variables on both declaring on the left side and initializing an array so I'm just saying the array is called multiple it stores a series of integers I have an int and then the bracket notation and then on the right side I'm initializing that array to store eight integer values one of the nice things about Java arrays and this is going to come in handy today is that they know how large they are so this is my way down here this is the special notation that I use to find out how many elements in the right house I take the name of the array I add a dot and then I had this special word length so that will always return the number of elements that are stored in that array and I could do I can also split like I did with variables the declaration which I'm doing for my character array down there on line six with the initialization which I'm doing on line eight so I'm creating a character array called all and after line eight execute all has space to store four characters I can assign values turn away when it's initialized using this syntax this is review from last time I'm not going to go into it in detail okay so and again let me remind you about how we index values in an array so computer scientists start counting at zero it's how we operate and there's there's actually a really good reason for this that I'd be happy to explain on the forum or somebody asked right it has to do with how the data is actually stored in computer memory but this is how it works so the first value in an array is the value at index 0 and here's how to access it so here's I can both get and set the value I use this bracket notation I start with the name of the array in this case the name is a it's not a very good name for an array but that's what we're using on this slide I have two square brackets and inside I'm telling Java the index that I want so here I can either get or set the first value of this array what that means is that if I want the last value here's how to do that ok so now this is kind of interesting I'm using sort of two features of the array and using the fact that it has a length property and then this is important right so if I'm an array that has length of four what's the last valid index in that array three not four right zero is the first one is the second two is the third three is the four so don't let this trip you up if you tried to access the value of a bracket a dot length that would cause an error we can we can do that together in a minute okay so here's an example I'm initializing an array on line 1 I'm declaring an array called twos and I'm initializing it to store the first three powers of two one two and four and then I can both access and modify the values inside that array using the bracket notation so on line two I'm printing out the value of the first value stored in twos which is going to be one then I'm changing it to two and then I'm going to print off a couple of other values in the array okay any questions about this before we go on this is important try it again did it work okay well we'll look at that after plan is this I can you guys run this example is this working okay yeah we'll have to we'll have to talk later okay so how can i how can I make this make an error you guys learned a little bit about errors today in in lab this week so how do I make this make an error I can cause this to have a problem yeah yeah let's let's look at what happens if I try to access the value stored in choose choose dot length right so first of all let's put off what choose dot length is so that's gonna be four I'll put this back in okay sorry it's three and now let's try this okay so I've caused a runtime error right because the array doesn't have an index three there's lots of other indices that doesn't have as well I couldn't you know try to access the eighth value of the array and that's not going to work either I you guys will probably start to see errors like this when you start to work on MP zero in the first MP checkpoint which we're releasing today okay so and again here's this this is the same thing I was just talking right in this case the array has size four but the fourth indicee refers to the fifth value in the array which it doesn't happen so I have this part so we talked a little about this last time but I want to return to this subject which is that in Java an array it has a fixed size so how many people here have worked with Python before okay yeah great so in Python I create a list and I could just add stuff to the end add stuff to the beginning add stuff in the middle it's all fun no problem right and that's actually kind of cool and we'll talk later about similar things that we can do in Java but at some level I shouldn't say on some level on a very deep level pipe the job is actually a lower level language than pipe in the sense that job is going to expose us to some actual limitations of the computer itself so in Python every time you change the size of a list there's actually a fair amount of work that has to go on to allow that to happen in Java arrays don't do this for us when I declare an array I have to tell Java how many items it's gonna store and then I can't change that later if I want to put more things in the array I have to create a new array copy the old stuff over and then work from there but I can't change the size of the original right this can complicate our programs and that's why Java has similar data structures to lists that exist in other languages like pipe which we'll talk about later in the semester so it also has oh I gave it away it also has some interesting historical consequences right fixed size rates so how many people here just do a quick poll have a net ID that ends with the number two okay how about 300 see we're starting to get into the three what about four okay you for five all right who's got one higher than ten higher than twenty higher than thirty higher than forty tell me what it is seventy-four I won't ask what your net ID is but I have some I can guess if you think yeah all right so why okay why so so give me a like a more nor so so my name is Jeffrey challenged my net ID is challenge ID to fight a little bit to get that I think I like bumped somebody I feel bad but not so much in retrospect it's the first one they gave me was terrible anyway so what would be like a normal like a more normal identifier like how many you guys have a gmail account that ends with the number 74 maybe you were no you weren't born in 1974 oh I met old so why why is this the case doesn't make any sense what would be a more normal net ID maybe more memorable maybe more easier to share with other people and you know you're out you know at a party and someone that wants it you know it's like hi I'm T y PP 55 right hit me later you have to write that down so but what's what's a more normal way to do this who has a better proposal there's so many better ideas yeah yeah what about first name dot last name how many people have a gmail address it looks like that kind of or maybe just first last right yeah what why why not that that seems like it would work so there's a there's an interesting property that all if your net IDs have without even asking you I know something already about your NetID even know what that is yeah with that Oh No - antenna number some of you might does anyone have one that does not end in a number ah there we go okay see there's a lucky person up there hopefully it's not like a string of consonants all in a row yeah they have to be unique yeah so that would cause lots of problems right it's like who do I deliver this email to who cares I'll just listen to both of you right that will cause some interesting things to happen they're all unique I know that but I know there's a property of them that I know I can guarantee yeah they are all shorter than eight characters does anyone have one that's longer than eight characters does anyone that it's exactly eight characters yeah for some of you that too is the eighth character so why okay you just learned something about Java arrays this is not a unique property of a raise in computer science a lot of languages have this limitation so why have we why do we have to work so hard so the people who work in engineering IT actually have a special program that they use to assign these net IDs it takes your name as an input and then it produces this terrible thing that they gave you to use right and along the way it tries to do things like avoiding giving people names that have bad words in them and stuff like that right we don't always succeed there are some examples you can find on campus of people that got fairly unfortunate net IDs assigned to them right but but what what's one limit so they're all under eight characters why you you can now under answer this question yeah yes because there is a computer program is it an old computer program that is involved when you log into your email when you access certain accounts on campus and when that computer program was designed some program out there a real person and I'm sure they are probably in the witness protection program by now but they decided that eight characters was perfectly fine as a limit for the size of your username that's what it's called they made this arbitrary decision probably back in the 1960s or 70s me and we are still living with the consequences today I find this incredibly amusing right like you guys like 40 years later still have these weird net IDs because some programmer again you guys are reading about the impact programmers have had on the world here's an example someone made this decision I don't know if you go online to look around maybe you can find out who that person is all right and send them a nice note April they probably it's probably first name dot last name at gmail.com right that's probably the email address they're like I'm not living with this anyway so yeah this is this is the reason there is an array somewhere on a program that runs that handles your logins to various systems and that already has a fixed size the size is 8 characters so I can have a one character net ID I can have a four character net ID I cannot have a 10 character net ID because the array is fixed size so now you know why we've got all the twos I look forward to teaching into the generation of threes I hope to be on campus when I ask how many people have a two and no hands go up because we've used up all the tubes they're gone all right we rounded three some of you guys have threes already so we're clearly getting there so again Java has other data structures that we can use to store this type of information and are more flexible we will get to them in fact we will build some of them together and you will see how they have to work with race although these data structures at the end of the day have to store data in an array so they have to work around this limitation some time somehow there's some clever ways to do that and we'll talk about that in in a month so as we talked about last time loops and arrays are really go hand in hand when we're designing computer programs I have data an array and frequently what I want to do is I want to go through that array one item at a time and do something to it so maybe I have some music in the array a sample and I want to like modify that sample somehow to make it you know to auto tune it right or to you know adjust the pitch to be higher or lower this is how these programs work maybe the data in the array is a picture all the little individual components of a photo and what I want to do is I want to do some sort of filtering on it to make you look more beautiful or make the background look more professional or whatever right all these like cool little tools you guys have at your disposal now for your snapchat and your Instagram and whatever you guys do online so here's here's a very sorry I'm getting too excited getting ahead of myself so here's the sort of canonical way to go through the items in an array all right so I have an array then I declared online one called primes that array has seven six values in it first six primes and then I have a loop and here's how I set up the loop and again we talked about before about 99% of the loops you write are going to be for loops and about 99% of those for loops maybe 95% are gonna look exactly like this okay I am an array right here and I want to go through and I want to do something to every element maybe I want to find all the ones that are greater than the value and remove them or maybe I want to modify each one or maybe I want to print them like I'm doing here okay so here's how this looks I have a for loop I have an index variable for my for loop I started at zero I run it up to just one less than the length of the array because that's the last valid index for that array and in each update of the for loop I increment it by 1 so the first time is for loop runs I will be 0 and I'll print the first value in Prime's the second time it runs I will be 1 I'll print the second value in Prime's the last time it runs what will be the value of I think it through a little bit last time it runs I will be fine five is the last valid index of an array with six values I'll print the last prime which is 13 and I'll be done Java actually has a slightly easier way to do this this is known as the enhanced for loop I think Java enhanced this for loop back in the 90s but we're still using this term so here's so I can essentially write this loop like this so this is the same loop and we'll look at both of them in a minute but this is a different syntax for the for loop so let's slow down and look at it together so the the array is the same so I have an array called primes it's an array of integers it has six values and I've initialized it to store this first six prime numbers 2 3 5 7 11 and 13 here I initialize an index variable and I use that index variable to access the values inside the array down here what I do is I say I'm gonna declare a variable that's going to receive in every iteration of the loop the next value of the data stored in primes you'll note that there's no index here okay so the advantage of the enhanced for loop is it's a little bit cleaner the disadvantage is you don't have access to the index so I don't actually know what the index is of the value that I'm looking at and depending on what you're doing with your loop this could be a problem I was looking at the solution code for the first NP checkpoint and there's some places where you can use an enhanced for loop and there's some places where you can't because you actually need to know what index what the index is of the piece of data that you're looking at during that iteration okay but this is another way to do it alright we're gonna do some examples but any questions before we get to our art playground time good yeah yep yeah that's it so it's great that this is an important distinction so when I use the enhanced for-loop Prime doesn't get the index it gets the value so the first time this runs prime is such a two that's the first value in the array the second time it runs it's set to three the third time it runs is set to five it's not set to zero one two yeah so it stores the data inside the loop not being great question so okay so the question is for you three people that know a little bit of Python or for all of us what's the difference between a list and an array so my we'll come back and talk about lists like I said that's actually one of my more fun parts of the semester we're gonna build a couple of lists in Java so you're gonna see how they are actually implemented or a few ways to implement a list is like an array a list test a couple of extra features in a list I can add items to it so I can add an item to the end I can add an item to in the beginning I can insert an item anywhere in the list that requires changing the size which I can't do with an array all right let's typically also have other features like I can remove elements right things like that so a list in some ways is a generalization of an array it's like an array it stores a series of values but it allows me to modify it in place where an array actually allows me to modify the size where at a rate to let me try this again to perform operations that would modify the size so that I can't do I'm right does that are you will you accept that answer awesome okay yeah we'll come back and talk about lists it's a great example of how to build a data structure yeah so a raise can be faster in certain cases yeah so the question was let's the advantage of using an array and we will again there's something we will talk about when we when we implement some lists yeah arrays have advantages they're done they don't just exist because you know we couldn't do better other questions yeah the zero the index zero an array is always the first value yes this is called zero indexing so start to learn to think to start counting at zero yeah yeah yeah we can do that so the question was if I ran this code what would it do and the question and the answer is both of these loops would print all the values and we will run something like this in just a minute yeah which one's more efficient I think these are almost identical yeah these two loops I suspect that they are equivalent yeah yeah so the biggest trade-off here between the two and this is you know one of the things about being a programmer right this is a creative activity when you guys are doing this you will always be making trade-offs right there is never a right way to do most things anything that you can do that's interesting when you're writing code has many right ways to do it and one of the things you spend a lot of time doing when you start to write more complex pieces of code is at least if you're me it's thinking and worrying about these decisions like did I do that the best possible way am I gonna regret that five minutes from now right and then five minutes or now I'm like oh I am regretting it I'm gonna go back and fix it right and then you had to pixie and five other things right so here's the trade-off right the pro of the enhanced for-loop is it's a little cleaner right the syntax is a little nicer the con is I don't have access to the index right so I don't know what value I'm looking at same thing for the regular for the regular for the five access to the index con is I have to remember to index the array all over the place right so I get rid of these brackets down here right no brackets that's nice but I also don't know what is yes can I nest arrays we will talk about that next week yes job it does have multi-dimensional arrays obviously they're useful for storing all sorts of data but one thing I want to remind you remember an array is an interesting data structure partly because it maps down very directly to what's actually happening in your computer okay so your computer stores everything as one huge array of numbers so if you have a photo right that photo to you looks two-dimensional to the computer it's a single stream of numbers if you have a movie that movie is three dimension alright that's a time dimension to the computer it's a single stream of them so when we work with data that is presented to a human in a higher dimension in any programming language we always have to do something called flattening it in order to actually store it an interview but you don't have to worry about that as a program and you can work it with it like it's two dimensional or three dimensional or four dimension or eight dimensional if you want to but internally it's always stored as a single series of eyes great it's a great question so I'm glad we're doing this yeah yep ah so the question is if the last valid index is Prime's dot like minus 1 why does my loop contain this constraint can anyone answer that question what's that yep yeah so you could write it as less than or equal to prime stock length minus 1 that is not typically how it's done I just want to point that out they worked the exactly the same way but again this is the a for loop that you will be able to write in your sleep right at the end of this semester I could probably send you down to the CBT I'll put the blindfold on and tell you I've got an array called foo and you could write this loop you know but you you well I would suggest that you always write it this way right this is sort of how it's done I don't know why again somebody else made this decision it's a little cleaner right but again you will just learn to recognize this as the loop that goes through every value in an array it's a pattern all right other questions all right let's play with some let's play with some examples ok so oh wait I just want to point something out you guys are doing good we will stop from time to time for a little bit of encouragement right so I just want to point out last year's class so I'm definitely gonna pitch you guys against last year's class right like that's a natural thing to do right so they got 94 on the first quiz not a particularly hard quiz right guys you know did pretty well last spring 92% 92 so you two points down last fall but that's probably ok right everyone is no one is gonna suffer because of it but but you guys are doing well right you guys did well in the CBT OP I know for a lot of you this is a first real assessment at college so I hope it went well keep doing the homework keep keeping up with things you guys can do this class trust I have seen hundreds of students now probably thousands of students succeed at this course you guys will not be the last or the first all right so let's do some loops okay so let's let's write this together so I want to print out every character in to print and let's print them on separate lines let's use our prep okay so when you start approaching problems like this it's useful to slow down and think a little bit about what you need to do right okay so who can who can talk to me tell me a little bit about what needs to happen don't write the code just it describing a sentence how I'm going to accomplish this yeah yeah yeah I'm gonna I'm gonna loop through the array that's how I get to every element and I'm gonna print all the elements one by one so I have two ways I can do this I can use let's do it with the normal for loop first and you know one of the things I'm gonna do is just as we go through the semester I'm just gonna try to give you guys a sense of sort of how I work on problems like this right so again like this loop you know you have to be you will get to the point where you can write in your sleep a lot of times when you're writing in a loop the first thing you want to do is just set the loop up so you'll see here I've written the loop I've initialized the index I used I this is like the one place in your code where you were allowed to use a variable name that has a single letter everywhere else know in a loop it's it's traditional I if I have a loop inside a loop I use J if I have a loop inside a loop inside another loop I use K if you have more loops than that come talk to me because something's wrong but but yeah I is very you can use index but again this is the one place or I will allow you to get away with using a single letter okay so I've got my loop now what do I do actually you know I'm just getting started here so let's do something simpler let's just print I I just want to make sure that my code is actually like going through every value in every index properly okay so and this is something again when you're writing code stop dry things right don't try to write it all at once write the smallest possible piece that you can figure out how to do and then make sure that works so now at this point I know that my loop is operating properly because this array has four values and I see it print index zero one two and three okay so now I know the loop is right and now I just need to adjust what's inside so now I'm going to use this variable i as an indicee into my to print alright there it is questions about this and when you guys are when you guys are you know that computers are such fantastic condorcet's right like there they are they're so interactive right use that to your advantage one of the biggest mistakes we see particularly when people work on you know larger pieces of code like the machine project you guys are gonna start today one of the biggest mistakes we see people make us they try to do too much at once without understanding what their code is doing I still do this right the smallest possible piece and get it to work then add a little bit more get that to work and add a little bit more get that to work use print statements to figure out what's going on that's a really good way of finding out what your program is doing oh let's do this okay well let's write this using the inherence for them because this is a place where you where we can do that okay so now I'm gonna I need to change my loop so now let's do this current letter to print and then letter and again like look at examples right so if you know sometimes I forget like what's the syntax of the enhanced for-loop so I'll go back I'll find a little piece of code online they're like oh right okay that's right it's got you know a colon you know here's the here's the initialization here right I've got a variable the same type I've got the array I've got a colon in between them okay that's that's what I need to do okay let's try this does the same thing great all right I'm gonna leave this as an exercise to the reader figure out a different way to write this okay here we go so now let's let's have some fun let's let's let's go through the loop backwards okay so the first thing I'm going to suggest we can't do this with the enhanced for loop because it only goes forwards that's because going backwards is kind of unusual but let's let's figure out how to do it so let's write our original loop this is great chance for you guys to write this loop so here's what we just wrote an instant ago and we'll get that to work again okay so now I've got it going through forwards what do I need to change to get to go backwards yeah so right now I starts where well actually let's let's go and just print I again until we figure out that our indices are right and then we'll go back to using I in our bracket notation so here I'm going 0 1 2 3 so if I want to go backwards where should I start yeah bingo yeah so it starts at the last valid index for this array which is to print dot length minus 1 okay now how should I update I every time if I run this now I'm gonna be in trouble well actually I think if I run this now it's not gonna do very much let's see what happens yeah I run this town with only prints 1 okay so clearly I have some other work to do but I'm starting this right spot all right what else do I need to change yeah yeah so I've got to go down okay so now I'm gonna be in trouble right so now if I run this uh-oh okay so but but I started well right you'll see I got the right answer and then I just didn't know we're gonna stop right so three two one zero is what I want when should I stop this loop how should I stop this yeah yeah and so so typically how this is done is I my condition is as long as I is greater than or equal to zero continue because anything that's greater than or equal to zero is a valid index I'm assuming because I started at the right spot so now I'm doing good okay and now all I have to do let's go back and replace mine is right okay good all right again I think I'm gonna leave this is an exercise for the reader unless we run out of okay ah so now we have a little bit of a different challenge here first you know so so far we've just been printing stuff right okay tricky all right here's my proposal let's start by printing the values so I'm gonna write a enhanced for-loop that's gonna print every value in this array so when in doubt start with something that you know how to do okay so I know how to write in enhance for a loop that prints the values okay so what do I need to change about this I want to sum them all up okay so the answer here when I'm done is going to be what I'm terrible about 150 how do I do this okay so the first thing I have to think about is that I want to be able to print the sum here after this I'm gonna go through every value I mean me calculating and then when the loop finishes I need to be able to print the sum so where do I need to declare this variable that's gonna store the sum can I declare it inside the loop yeah so this is our first example of using you know sometimes what's called an accumulator or just a variable outside my loop okay what's the type of this variable that I need to use to store the sum why because it's an array event through a story of doubles I would use a double in this case I'm going to use an end I'm going to say sum is equal to zero I'm gonna start it at zero I should have asked you about that but when I start adding up numbers I start at zero all right I start with nothing okay now what do I do so let's print the sum down here let's just fill out that piece of code okay so now I'm probably now the values and the sum is zero so now what do I do how do I finish this very close so inside the loop the first value I see is ten what should the sum be after that iteration finishes ten the next value I see is 20 what should the Sun be then 30 so how am i modifying the sum every time yeah essentially I'm saying make my son bigger by the amount that I'm looking at so I'm gonna say sum is equal to sum plus current it's one way to do it will simplify in a sec okay so now let's print off both current and our sum we'll do that this way when we talk about string this will talk about with this the plus operator DOS with the string but in this case it's gonna print the two strings separated by a space okay write this up a little bit let's see what happened okay so the first time through my current value was 10 and my son was 30 the second time through my current value was 20 the sum sorry the hurt now he was 10 in the sum was 10 after I added it in and so you'll see that the sum is increasing every time by the right amount and when I'm done it's correct awesome so I'm gonna make two final model to clean little cleanup modifications to this I'm gonna get rid of the print statement so got the right answer which is I wanted and if somebody pointed out there's a slightly more clever way to do this which is I use this plus equals operator it's exactly the same code but this is a very common thing to do I'm taking a value and I'm increasing it by another amount so now I'm saying every time through add the value of current to sum just make sure that still works good questions about this okay so what we just did was our first example of writing something called an algorithm and this is a topic that is going to consume us for a large part of the rest of the semester I mean we will continue to come back to on some level this is the deep conceptual heart of computer science the reason you learn to program a computer is so that you can implement algorithms and as you go through our program one of the things that will happen is you'll become a better programmer but part of the reason you will and because the reason you'll want to is that the algorithms that you will be able to use will become more and more sophisticated so look when you upload a picture to your photo sharing site and it recognizes that there's a picture of your cat in the photo that's an algorithm now when a self-driving car or a semi autonomous vehicle make small decisions about how to adjust its steering so that it stays in its lane that's an algorithm when you know we reach out to students in this class they might be a little bit behind we're using an algorithm to identify this is how your lives are organized and judged when you apply for a job there is an algorithm that's going to run the first pass on your resume when you try to get a credit card there's an algorithm that is used to decide if you deserve a credit card and how much credit you should be given when you buy things there are algorithms that decide is this a legitimate purchase how likely is it that I suddenly bought you know three nights at a resort in the Bahamas this is the conceptual heart of computer scientist and what's exciting about our appeal and the way that these algorithms are implemented is entirely using these simple building blocks that we've just discussed over the past two weeks you know we performing simple calculations making decisions about what to do you know storing the results making simple decisions and doing those things over and over again that's what leads from the array of data that's in the photo to the label cat is a very complicated sophisticated large number of these calculations but at the end of the day simple I always bring myself back to this whenever I get frustrated with what I'm doing at the end of the day the computer is just a calculator that runs really fast okay and it was it will not try to fool you it may not always do what you want it may rarely do what you want but it's a deterministic thing right and at the end of the day it's running these simple things so as I said before computer algorithm the word algorithm is heavily associated with the computer era so one of the things that we're doing with computers now is we're actually mining text data to learn more about how words are used over history and what things you can find out here's the word usage of here's the usage of the word algorithm and this is by mining a bunch of texts that were collected over many years and digitized as part of you know various digital book products projects and you can see when does algorithm and start taking off 1960 what was happening around that time computers alright alright so for the next simple weeks what we're going to be doing together is implementing algorithms simple algorithms we're gonna talk about how to you know and this is something that is going to be something you will struggle with for a long time well the things I hear from students all the time in this class is you know I know how to solve the problem I just can't get it into code and so that's what we're gonna do together the problems that we're gonna solve our not hard getting the computer to do them for you is what you struggle with when you're getting started with okay all right I'm gonna let us pick up here on actually you know what hold on let's do this we have enough time okay so let's say you have three numbers and I want you to give me the maximum what is an algorithm for solving this problem so what's an algorithm an algorithm is a series of steps that I you should be able to write down that a computer should be able to take or a person should be able to follow very carefully and are used to arrive at the correct result okay so I've got three numbers what's one way to figure out which is the biggest out of all three yeah well that's how I'm gonna build my algorithm and know when you describe an algorithm neat I want to hear English I want you to talk me through the steps yeah way in the back yeah you're off to a good start right so clearly they have to compare the numbers to each other right so let's start with three okay that's over three numbers is there a way that I can eliminate one of the numbers yeah well let's let's let's imagine that let's pick one and we'll test if it's the largest so in order to be the largest what has to be true about the number let's be bigger than both of the other numbers right okay so let's take a let's say we're doing a B and C and I'll take a and I'll compare a to B and see if a is bigger than both B and C then what do I know about a it's the largest number if it's not what do I know about a it's not the largest number okay so now I took a and I compared it to both B and C if it's bigger than both a is I'm done a is my winner if it's not how many numbers do I have left to compare to because a can't be the biggest so now what do I do look at B and C pick one of them compare it to the other side say it's be bigger than C if B is bigger than C then it's my maximum if not what's the maximum value C this is a series of steps and you can actually do this with any number of numbers right so again I'm going to determine it first it's the largest by comparing it with all the other numbers if it is I'm done otherwise it's not the largest therefore I don't ever have to think about it again I made the problem smaller just compared to second in the third so I will leave this for you guys to do because I have an important announcement to make all right so we are in the process of releasing mp0 in fact I'm going to do that like right now while we're talking all right so that'll be up on the website a minute so this is a big moment for the class I want to take a minute to talk about what's about to happen your lives are over no I'm just kidding so if you haven't seen something like this before so you're gonna check out you're gonna you know some of you would be very excited to start this and I hope you are because I hope you actually take advantage of office hours this weekend to get going all right you have just over two weeks to finish this the first checkpoint now some of you are gonna get this code and your brains are going to explode okay there is a lot here it is complicated it is frightening if you've never seen this stuff before this is normal okay the homework problems in this class are the little bite-sized pieces that are designed to make you feel comfortable and build you up slowly but surely the machine project is the big gnarly piece of stuff that's designed to make you feel uncomfortable it is not that much harder when you are done with the first checkpoint you will be astonished at how little code you wrote okay it's like 20 lines total I did it last night but you will be frustrated by how much digging and searching around you had to do throughout what we're about to give you define what you needed to do and that is normal for this part of the class these MPs can be intimidating when you get started but don't freak out come to office hours ask for help on the forum you guys will do this trust me and this is really exciting because this is the beginning of a journey that we're gonna go on for the next couple of months all right we're gonna give you a little help with this in lab next week but please get started this weekend we have office hours today we have office hours Saturday and Sunday okay one last thing I wanted and this is important so this is our chance to talk about this we have a minute okay some of you have noticed in the syllabus we're doing something new this semester which is that every and part of the NP there will be two deadlines half of you how many people here have labs that start before 3 p.m. raise your hand okay you guys are I can't remember what the what the names of the groups are you guys are either the blue year the I think you have Sunday deadlines from now until the until the machine project is over how many people have labs that start at 3:00 p.m. or later all right you're the orange group you have Monday deadlines from now til the end of the semester okay calm down let's talk about this I'm gonna explain to you why we're doing this the number one reason that we made this choice I'm happy to talk about this on the forum I'm happy to talk about it on reddit wherever right the number one reason we made this choice is to provide you with better support office hours get really crowded around deadline time and by dividing you in half it means that everybody is going to get more help when they need it but this is not something again I'm happy to explain this I'm happy to discuss the implications of it but this is how things are going to work from now until December all right I will probably not be here on Monday in fact I will almost certainly not be here on Monday I have some family business to attend to I think either we will post a video lecture or Ben will be here but I will probably see you guys again next week enjoy the MP and have a great weekend  
﻿ okay all right welcome back so I promise you that I'm working on fixing this I have new hardware arriving I think when you guys come all in and sit down you guys fraud the Wi-Fi pretty hard so it just takes a few minutes for things to stabilize so sorry about that welcome back so today what we're gonna do is there's not a lot of new content today we have a couple of things to talk about that are kind of clarifications or additions to the knowledge that you already know though the things that we've already presented at least but what we're gonna do that's fun and exciting is we're gonna work on some problems together so that's kind of the what's gonna consume us for the second half of class I have a few things to talk about now again more clarifications a little bit of additional information about a couple of things that we've been working with that we need to explain a little better and then we'll do a couple of problems together and get some practice doing that all right so and this is sort of our goal throughout the rest of the semester we're getting to the point I think of this class is layers so we're getting to the point where we're kind of like we put down the first layer of information that you guys need to know this is something that once we start talking about objects in a week you guys will start to refer to as imperative programming that's what we've been doing basic building blocks of oh it's doing this again okay basic building blocks of computer programs and then what we're gonna do when we start the second unit of the class is we're gonna continue to work on developing our problem-solving skills but we're going to start to include and introduce some new tools objects which is a new way of structuring data and then we would get to the third half of the class will actually start diving even deeper into some algorithms and data structures so essentially the stuff that you've seen so far we're gonna keep practicing throughout the rest of the semester so if you're a little bit if you're struggling a little bit with some of the homework problems or in the CBT F on the quizzes that's ok this stuff doesn't go away it's the foundation on which we build everything else that we talked about in the class all right so before we get to the problems I want to talk a little bit more about functions because technically I was here on Monday but actually first before we start that I want to take a moment to just see how people are doing this is the end of the third week of class I hope people are okay you know again this is maybe the end of your third week in college which is kind of exciting does anyone enemy general concerns or questions that they want to ask you know we're getting to the point where the MP starting to np0 is starting to heat up which is awesome I see a lot of people working on that which is great we have office hours today the weekend office hours this weekend obviously can be really important anything you want to ask any concerns yeah when will the official MP grader be up so that depends a lot on how much free time I have between now and Sunday night or Monday night I'm working on that we're close we've decided for some reason to rebuild this part of the class this semester and we're not finished yet so I apologize for that once it's so so just let me make something very clear the MP grader performs the same operation that you perform locally when you grade your MP so when you run the grade intellij configuration when you hit the shield on the plugin if you've installed it that's exactly what we do when we grade your assignment official the only thing we do is that you know we we copy over some of our test suites and stuff like that to make sure that you haven't made any changes so for example we're not going to grade your assignment if all you've done is taken all the test cases and have them returned you know pass whatever right so we do a couple of things to your submission to make sure that we trust it and then we run the great task but if you haven't made any changes to those test suites and you're running the great task locally that will do the exactly same thing that it does when we run it efficiently this is really important to us I want you to have confidence that when you submit something you're gonna get the scored that you think because let me point out something else even once we have the auto grader up and running and I have like a whole fleet of machines at my disposal here particularly around deadline times stuff backs up a little bit right you might have to wait half an hour an hour to see your official score on a submission so you really need to get to the point where you trust that vocal greater and in order to allow you to do that like I said when we officially grade your assignment there's no tricks we don't have any hidden test Suites we don't do anything differently we essentially run the same tool that you have you know within your IntelliJ installation so you can do the same thing that we do so when you see the score it's like I got 40 you got 40 again as long as you didn't monkey with the test Suites or do something weird right the whole goal of giving you this grater which is another piece that that we build been built this version of it but I built the original version of it a couple years ago is to allow you to have confidence in your submission all right we don't want you submitting to find out what score you're gonna get will tell you and again as long as you haven't done something weird you will get the same score efficiently it's a great question yep eventually there will be so once the greater works when you push after a few minutes or longer depending on when you push and how many other submissions we have to grade you'll see an official grade on the grades page yeah absolutely that was working until we decided to break it again this semester but once it's working again it all should be working a lot better you guys won't notice you know they care how the stuff works but having to maintain this stuff we do care how it works and the changes we're making are going to help us yeah you can submit as many times as you want look I will do nothing at this semester to prevent you from practicing I promise you that that's a commitment I will make to you you don't loose credit on the homework problems you don't lose credit on the mp4 so many multiple times we will grade every single commit that you push and you will get the best score out of any of those commits okay so there is no penalty for trying all right that's how you learned this I don't I'm not gonna penalize that it's some point you run at a time okay I'm not giving you an infinite amount of time to complete these we need to keep you on track right we need to keep you moving forward but yeah there's no penalty for push good question question or stretch it Russian yeah is there a visualization what would you like to see about so a video showing you what what would you like the video to show you yeah so the question is is there a visualization about how the game works I'll I'll ask Ben to see if he wants to do that right you but you can I don't know if you saw this in the MPC or instructions but if you want to you can build a fully working version of the game right now with the code you already have you have to change this configuration file but we've given you solutions in a compiled obfuscated form that you can't use to figure out how to do the NP but we've given you essentially the solution to the NP that's already included so if you want a fully working you want to see where you're gonna get over the next two months you can build that right now but that may be a good idea me ask Ben if he wants to put together some sort of screencast give you a sense of how the game is supposed to work once you're done yeah yep so so this semester you're you are working on this project until Thanksgiving yeah we've broken it down into specific pieces so you know not this weekend but next weekend once you guys are done but the first checkpoint will release a second checkpoint and that'll have more things for you to work on right so yes we're basically you are going to be Finn you're going to be completing this app in stages right over the course of the next few months and and that's actually something that you know I hope you guys appreciate because it allows us to do some really cool things so some of the staff have pointed out like oh the first like these functions you guys were writing are terrible they take like eight arguments they're so gross you know and part of the reason for that is we haven't taught you how to use objects yet once we do that I think you're actually gonna go back and rewrite some of this code to use objects and you'll see how much cleaner it is how much nicer it is but you don't know that yet so the only thing you can do is work with an array of doubles that represents latitudes or whatever right you guys will see how much objects help simplify some of these parts of the MP once we teach you them and have you used them on a later MP check so this is actually a really neat thing about working in the same project over a long period of time and again this is something that is you know in the future when you're a software developer you will do I do this myself I find out something new about something I'm doing and then I go back and I rewrite parts of the code I'm working on to reflect that new knowledge right so this doesn't stop with this MP or any of the checkpoints on it okay any other questions yeah nope nope so we've recorded every one of your pushes we just haven't done anything with them yet yeah so so once the and and you know what I'm gonna make you I'm gonna make a prediction we may mess this up a few times right so the first time we run it the grade might be wrong and then we may run everything around it and rerun it but we have everything we know when you pushed and we know what you pushed so at some point in the future there will be a correct grade for that motion right so as long as you push before the deadline we have noted it somewhere you know when you submitted the code and so you don't need to worry about pushing your gun late yeah good question any other questions it's been great okay so let's go back to talk about functions again so on Monday we talked about functions and one of things that Ben told you this is nice this semester because I get to get away with this one things that Ben told you was that two functions couldn't have the same name so this turns out to be not true and you know so I went I I've always liked this article so this is you know now ten years old but you know here are ten warning sides of a bad professor right the professor is boring I don't consider myself to be that boring but who knows I'm now I'm turning off the lights in the back so some of you guys may be sleeping back there professors bummed out doesn't give out a syllabus a professor assigns an undoable amount of work I may be guilty at that sometimes petty rules can't fill the whole class period well you know if I keep rambling and running music five minutes in the class that's on a problem there's but there's no like lies on this right that should probably on the list like professor Deano directly lies to you so here's an example so again I told you that the two functions couldn't have the same signature and here's an example of that not being the case so if I run this code there's a snippet of code I'm declaring two functions first one is and and like we've done in the past just ignore that static keyword that's going to make more sense in a few minutes but for right now what do I have declared here I have two functions on line one I've declared a function called sum that function takes two arguments that are both integers and returns their sum so I have my return type which is an int the name of the function open parentheses I have a list of arguments separated by commas every argument looks like a variable declaration has a type in a name so that says if you pass me two integers I'll return the sum but then in the same spot I have this other function called sum okay so it's the same name it also takes two arguments but those arguments are in this case doubles and that returns a double and it turns out that I can use both of these in the same piece of code so in the first case I'm adding two int and in the second case I'm adding two doubles and just so you you know you might think well maybe the second one overrides the first one or something like that right but let me show you that that's not the case so if I comment out this second function I'm gonna get an error right the error is being produced so we'll talk about why this is happening in a minute but the air is being produced because I need this second sum function nor defy code work problem so what's happening here so the first thing we might wonder is you know before we were saying we need to have a name for the function so that we can use it in our code so if I have two functions named sum which I do right here how do you think Java tells them apart so these functions have the same name but there is something different about them yeah okay so that's that's one question is there return type right so one of them returns an INT one of them returns a double turns out that that's okay so let's let's experiment with this hypothesis let's say I'm gonna return an int I also have to do this which I'll explain in a second oh this doesn't like this okay let me try this okay I'll explain what I just did in a minute but I'm just want to show you so again we're just messing around here right but it turns out that I still have these two functions they still both seem to work even though they have the same return type so that was a great hypothesis but it's not doesn't look like it's correct let's just put a print out in here so we can convince ourselves that both of these are in fact running and they are so how is okay so that was one how about this is good I bought this is not not correct what's happening yeah so it's the type of the arguments ah okay so now this this okay so now I have another hypothesis which is that I can declare multiple functions for the same name as long as their arguments are different so let's experiment with this hypothesis let's declare let's change our second sum function to take two intz and see what happens okay so if I do that now I get this error from the compiler saying that I've already defined a method called sum and it's actually really interesting because look at how the compiler identifies this method it says method sum but it just doesn't use the name it also includes the argument types so essentially what the Java compiler is complaining about here is that I've already defined a method called sum that takes two integers as arguments and so in Java what we when we define a function Java actually uses what's called the method signature to identify it when we try to use it the method signature contains not only the name but also the arguments and their types the number of arguments and their types so if I want to make this different let's say I want to make a second sum function that also takes in sand returns an end what do I have to do to make it different I have to do something to distinguish it so I already have one that takes two int yeah I could change the name that's true right so I could say another sump right now now I had this different problem here let me just get rid of this guy right okay so that that works I'm not calling this one right what if I wanted to use the same name what could I do yeah I could add another argument or another parameter yeah so let's do this let's just say and I can remove these casts which we're gonna talk about two seconds say first plus second plus third so now I have to sum functions one sums two arguments second sums three yeah so something about the combination of the name of the function and the arguments and their number of arguments and their types has to be different in order for Java to figure out which one I want to use so when this code runs or actually when it compiles what happens is Java says okay I can see you're calling a function named sum and I can see that this is a function named sum that takes two arguments that are integers okay well I know about that you told me that that function existed up here and you implemented it so I know what it does same thing down here it's okay well now you're calling another function name sum but this one takes three integer arguments and again you told me what this function does so I know how to to call okay so this is something that's known as method overloading and this turns out we will come back and mention this again later because this turns out to be connected with a really powerful and interesting feature of the java programming language okay for now we're just gonna kind of talk about how use this but this is actually a type of polymorphism right which we will get to later big scary word that we'll talk about more when we talk about objects so Java uses both a function name and a list of argument types to determine which function to call combining those together we refer to as the function signature so again if I remove this function and force the compiler to print an error message you'll see an example of a function signature right this is a function signature it's the sum and then the types of the arguments Java doesn't care what I call them that doesn't help it so for example if I change the name of one of the parameters I still have the same problem right the names are for me right the types are for job if I change this parameter to a double it would work or if I added a third parameter there was in it it would work right but this is an example of a method signature okay awesome so this is how Java figures out what function to call it looks for a function with the right name and then it looks for a function that accepts the parameters that I'm passing right so it needs to take those arguments in the right order with the right types okay all right and and Java will also do type conversion to try to find a match as long as there's no loss of precision now what does this mean let's come back and talk about this in a minute well actually we're gonna talk about it right now apparently okay so I can run this code and I can see that it sums instance sums doubles now before when I removed one of the functions I was very careful about which one to remove so let me do this again let's remove the one that sums intz all right so that still works huh it's interesting what's going on here it looks like on line 11 I'm calling a function called some that should take two integers as arguments not to double so what is happening here what is happening here remember I could do remember remember this let me jog your memory a little bit here remember I could do this I could say double D is equal to 10 that works fine 10 is it it D is a double why can I do that yeah yeah so there's no information that's lost here I can't do the opposite I can't take an INT can't type an INT I can't take an INT and and add and and save a double value to it but I can do the opposite so as long as there's no loss of information Java will do this it will convert things for you so it can take an integer value and it can cast it automatically to a double we're gonna see how to get it to cast things when there is loss of precision or loss of information in a minute okay so what happens here when I call this function on line 12 the first thing Java does is says do I know about a function called some that takes two integers as arguments and the answer is no I have not defined that function I commented that function out so now it goes through a process of trying to figure out okay well I know that I could take an integer and I can I can use it as a double because I'm not losing information so let's try that let's try to take this and use it as a double is there a function called sum that takes you know any combination of types that I can that I can convert these to and so eventually it finds that there's a function called double the takes sorry-sorry some that takes two doubles so what will do is it converts those integers to doubles there's no integers can't save a floating point component so there's no loss of information and then it calls the function sum and you can see which one it's using not only because I put a print statement in here because the result is is also a double okay all right so now let's start to talk about and this is something that you know you guys are gonna it's really gonna come in handy on the upcoming homework problems and on your MP so let me talk about you know this is really something that is not a rule it's something we sometimes sort of as a design pattern it's a best practice for how to write a particular piece of code or type of code and one of the things that you will have to do when you write function so pretty much throughout the rest of this semester most of the homework problems and the NP are gonna consist of you completing functions you're already doing that for the first empty check point you have a couple of functions three functions that you need to work on okay when you start implementing a function one of the things that is useful to do is to try to figure out if there's any problems with the arguments that you've been passed this is sometimes so it is input validation or parameter validation so for example if I wanted to make a function that summed all of the numbers in this array I'm passing you an array of numbers one of the things I might want to do before I start doing any work before I actually start implementing my algorithm is check to make sure that numbers is saying that it's okay there's a there's at least one serious problem that arrays in Java can have I'm gonna show you that in a second all right so let's let's not let's not do this for now okay so here here's what can go wrong let's say we skip this okay I don't know how to do that I'll just put that in there and so now I'm gonna just implement my sum function I'm gonna take all of yous an enhanced for-loop to take each value from number and I'll return that some okay and then let's see if this works so to print win sum of one to five oh I need to do this you int alright so I'm gonna create a ray of inch right in there it works okay so I feel like I'm feeling good here feel like I'm done right but here's the problem there is an input to this function that will cause it to crash I'm gonna tell you what that input is in a minute but there is a way that an evil person or as you guys are finding out in this chapter encoders on bugs just like you know a user that didn't understand what you wanted them to do right somebody put you know the wrong input in a text yes their phone number and they put their email address right you asked for their email address and they put died computer code you know like who knows right people do strange things so let me show you this special so actually one of the I think somebody asks this while ago which is like what's the value of an uninitialized array so before and I initialize an array what value does it have is it empty no so in Java we have this special value called no and I wish I mean I could you could give an entire class talking about no no is a fascinating topic it is you guys go and Google around you will find all sorts of articles on no there are people that refer to no in Java as the billion dollar mistake because it has caused so many problems with software this empty value this value that means that something doesn't exist and I'll show you why it causes problems in a minute but in job I have this special literal value called null once we start talking about objects let's make a little bit more sense but essentially no means that an object reference doesn't refer to anything yet so here I've declared an array but I haven't used the new keyword to create an array that this array variable refers to and so it's just no it doesn't exist it's like it points to nothing okay so so and this is the special value of Java and again like I would encourage you because it just this a slide can't do it justice but this is so interesting right there are one of the you know so one of the languages that we've started to use a lot as we develop tools for this class is a language notice column and one of Collins big design principles is null safety it tries to make your code safe from problems involving this special value so this weird null absence of stuff turns out to have deep implications for your code okay so no is not a valid object array or anything it has no properties or methods so any attempt to do anything with it is going to fail fail spectacularly okay attempts to use know are going to result in a runtime crash which is terrible that means your app that means when you deploy your app to the App Store or to the Play Store people get that you know fun app has stopped working like that's the message that they see is not good okay all right so let's let's go back and I'm gonna show you what happens here all right so let's say that you know I'm a user and I just want to see the world burn boom there it is I have created a problem I have crashed your coat you know and you know I hope that this happens when you run your chest as opposed to when you're you know out in Silicon Valley pitching to some VC showing them your brand new you know cool app and it crashes not good ok so again the fact that there's an input that I can use to crash this code is not good and this is why we want to do something called input validation so again I'm going to get the same problem here oh it doesn't like this at all does it ok all right so I have this you know again I have a problem with you know I have I've crashed your program right if I if I say let's see here new int 0 then it's fine right now this is a little strange I'm gonna get rid of this because this doesn't make sense yet but it has like zero so that's ok so I do want you to understand that in Java we distinguish between an array that's empty and this special null value that refers to an array that doesn't even exist ok this causes a crash this is okay well would be okay second a minute to run yeah this is fine all right what do you think the uninitialized value of the array is going to be I think it's me zero oh you guys are so hopeful this is so hopeful I like that nope oh and now it's mad at me okay well anyway I have to initialize it to something right so it turns out in certain cases when you when we start creating objects I don't have to initialize this array and it will be known the default value for an array for any type of object in Java is no that's one of the biggest problems with this value in jump okay so let's go back to our example how am I going to fix this I want to make sure that this code does not crash what can I do yeah yeah so let's let's try this so null is a value that I can use as part of a conditional statement so to check for now all I do is I say if numbers is equal to No so if numbers is this special empty array that hasn't been initialized yet what should I do now here's a good question what's the sum of an array with no elements in it I think zero is a pretty okay thing to do here at the towards the end of this semester we'll start talking about errors in Java and this would actually be a good place to generate an error because this function should never be called with the null array like whoever called my function messed up and I should let them know that they made a mistake but in the meantime before we know how to do that let's just return zero that seems like a reasonable value okay now if I do this oh don't do that now if I do this I'm good so again here's my pattern at the top and once we start to write more complicated functions this will get more complicated but the general pattern is at the top check my inputs to make sure they're saying until I know that numbers is not null I can't iterate over it down here doesn't matter whether I use an enhanced for loop or a normal for but I can't go through this array until I know that it's not know okay now you might want to check for some other things like for example the array is empty what should I do I could this code still works if the array is empty so if I pass an empty array let's do that down here okay so it's coming out this guy just go pass an empty array this is gonna work fine that's okay it just never goes through the loop but what if I wanted to handle that up here I could I could say if number is this equal to null or numbers dot length is equal to 0 return 0 ah okay so now actually we've seen one of our first fun examples of the the power of how Java evaluates conditional expressions because the question is why can I do this why is it okay you know in general in tight like if I try let me let me do this this will be fun let's do this in the other direction okay if numbers dot length is equal to zero or numbers is equal to null and then I'm gonna try my no value again oh now I have a problem so I can do remember we talked about short-circuit evaluation this is safe to do get rid of the end this isn't gonna crash the reason is because of how Java evaluates this conditional expression so if numbers is no it's never going to evaluate the right side of this and so I'll never get a null pointer exception because I'm never gonna try to get the length so by the time I get to the right side of this conditional expression I know that numbers is it known therefore it has a length problem every array has the length problem so again this is an example of that short-circuit evaluation coming in handy as I promised you it would okay great let's finish this okay so this is one of those places where unfortunately Java as a programming language shows its age a little bit and here's what I'm going to teach you feel a little conflicted about this but here's what I'm gonna teach you in this class we are not going to use any fancy advanced methods for avoiding null in Java those exist okay we're not going to use those that we're not going to use those consciously right I know they're out there and we could be using them but I think at this point in computer history it's still useful for you guys to get a feeling for how to work with null because it's out there in the world it is still haunting us we have found better ways to work around this so again if you go on and you use programming languages like rust or Haskell or Kotlin or whatever you know modern programming languages have a bunch of ways to avoid having to deal with this problem but Java has this problem okay so I'm gonna teach you to be defensive about this when we give you a function to write that can take a value that might be no we will pass you that no value and you are expected to make sure that your code does not crash does something sensible we will normally tell you what to do if you get a no value particularly on the homework it'll say if such-and-such parameter is null do the following thing so we'll tell you how to do it but you need to implement the defensive logic can I be the only person talking in here whoever is doing that I can definitely hear thank you just talk quieter alright so let's talk you know what people do this I'll do this quickly okay so if I want to force so we talked about the fact that job will automatically convert into doubles because it's not losing any information it won't automatically convert a double to an int because there's that fractional component that won't be preserved but there are times in which I want to do that and you know this comes up in certain places I'm gonna show you how to do this quick right if I want to force Java to do a conversion that might lose information I have to use what's called an explicit cast or an explicit type cast so for example on line one I'm declaring a variable called ID it's an anti initialize it to ten I can set a double to be that same value because no information is lost okay but I can't do this here if I try to set I back to the value of a double the compiler will complain it won't do this for me it's gonna say hold on you you need to tell me that you know what you're doing the way that I do that is by doing this so here's a typecast you'll see a type inside parenthesis what this tells Java is you know what I'm the boss and I know what I'm doing so let me take this double value and convert it to an end how is that gonna happen well we can look at let's play with some examples right okay so you'll see here that line three fails if I pull out line three everything is good and I'll print out the result just so that we know that something happened right so again I can force this to okay so how do you guys think this works do you think Java rounds yeah yeah well let's let's find out let's let's perform the experiment okay so I'm gonna get rid of this I'm gonna use a literal so let's try ten point nine nine nine nine ten okay oh oh right okay I no longer have my int so let's do this yeah so what happens here is that the decimal is discarded Java does not round for you there are functions a job you can call to get it around but it will not round when you do a cast it just tosses the decimal point says hey you told me this is what you want it right and so off it goes all right so let's do a couple of problems quickly we don't have as much time as I would have liked I also have a couple of announcements interspersed in here and maybe I should do those first actually cuz they're kind of important we'll come back and and do this in a sec okay so like I said this course works in layers and believe it or not we're actually in the third week you guys have one more quiz next week and then a midterm quiz the following week all right so as we go and particularly for those of you that have some background you know whether it's Python or a little bit of programming experience here's what's gonna happen like you're gonna be okay for a couple weeks and then you're gonna get to one the quizzes be like oh my gosh this suddenly got really hard the beginners in here are already there right they've been doing the work since day one but some of you this is going to catch by surprise all right you know if I would if I said something about the difficulty level the quizzes I'd probably say that it goes up until it hits the midterm and then it comes down a little bit once we start objects and it was up again so it's sort of like a sawtooth function that keeps going up and to the right but when we start the suckit unit of the course and we start talking about objects things get a little simpler for a couple of weeks so these next next week's quiz and the midterm are hard you know so let me tell you how to prepare for these quizzes not hard go through the lecture slides the lecture slides are the source of information about the multiple choice questions all the multiple choice questions we ask are drawn directly from class they're not tricks there there was something that appeared on a slide okay then what do you do you go to the hoenn 25 practice problem set those are the old homework problems and the old quiz questions I'll start to release the old quiz questions we still have a couple of people that haven't taken the first couple quizzes but once we get them through the system probably next week definitely by the midterm I will have all of the old quiz programming questions as well that will be available for you to practice so go do some of these and then do them some more and then do them some more this is really the best way because it's those programming questions that are gonna get you write the multiple choice questions it's like you know fine right not worth that many points the programming questions you have a small problem it can really slow you down the other general piece of advice I would are I would say is don't get stuck you know I've had people that like got jammed up on one of the programming problems and they lost all the points because they just couldn't like they couldn't finish it and they felt like they were close and they just kept spinning over and over again and like you know thirty minutes went by and they ran out of time don't do that right you get stuck move on to the next problem you might get that one right away you might get the next one right away and then you can come back to the one you're stuck on and maybe with a fresh set of eyes we'll see the problem went away but you'll also have whatever time you have left just bang on that problem right so don't get stuck okay yeah I do that do that great I put up a little algorithm here in pseudocode for you guys if you want to figure this okay so let's do this oh okay other thing I want to talk about just just quickly because again so we have a very I consider a very generous dropped grade policy in this class it's on the syllabus but therefore every course component except the machine project there is a number of drop grade so you can drop like ten homework problems three classes three labs three quizzes you can't drop the midterms that's the other component it's not drop okay the the I don't I think people misunderstand what these are for if you're on a sports team and you need to miss class that's what this is for if you've got to go home for a funeral that's what this is for if you've got sick and couldn't attend class that's what this is for these aren't like I get to skip some class and then when something happens that causes me to miss class I need more drops that's not how this works we give everybody the drops and the result is that we don't give exceptions so I'm not gonna excuse your absence in class just don't come and you'll consume one of your drops some of you you know are gonna use all your drops cuz you got sick one week I'm sorry about that it sucks to get sick in the middle of the semester some of you are gonna get to that in the semester and stopped coming to class for the last week and you didn't get sick you know so you know life isn't fair that way but by doing this right this really allows the core staff to not have to deal with this and it gives us a lot more time to do other things that are more beneficial to everybody okay so do not contact me about missing class I'm just gonna send you a link to the syllabus that says don't contact me about missing class this is you know the policy you're gonna use one of your absence right so everything is covered by this right if you have to miss more class than this that I'm worried about your ability to succeed in the class that's why we the drops are calibrated to achieve this result okay so again please don't email me about this you know I know you guys are gonna use to this that's okay still getting a few of these it doesn't take too much of my time but you know in general it's it's fine you don't you can't come to class don't we expect you to try to do everything we understand that there are some external forces that might intervene okay so I'm out of time unfortunately if you guys want these to see some of these problems done let's start up a conversation on the forum as a reminder first MP checkpoint is due this weekend on your deadline day whether that's Sunday or Monday depending on which group you're in I have office hours today in SIBO in my office - - sorry - two to seven now Oh 403 I'll be in my office from 1:00 to 3:00 have a great weekend I will see you on Monday  
﻿ all right welcome back everybody welcome to Friday it's nice end of the week okay so today we're gonna continue talking about objects and one of the topics I have to introduce today is one of the stickier conceptual bits that we're gonna have to learn about objects this semester so bear with me this is a concept and a key word it causes people a lot of problems a lot of confusion but I think that by introducing it and by making sure that you understand it you actually are going to end up understanding something about objects that you wouldn't necessarily understand perfectly if you didn't understand static so that's what we're gonna go okay so I apologize for last time the slide playground is up and running again it should work fine today as a result of that I'll slow down a few times today and we'll go over some examples more carefully because I know we didn't get to play with things last time but as a reminder for you from this point forward we're not gonna run loose code or loose methods that are defined outside of a class so all of our examples like this one are going to run they're gonna start executing in the main method defined as part of the example class okay so if you don't call the class example it's going to get angry if you call the main method something else it's going to get it's gonna fail if you stick loose code in here it's also not going to compile okay again this is more similar to how Java actually works we are sort of taking away the training wheels that we used for the first month that allowed us to write imperative code more easily because now we're dealing with objects and at the end of today's lecture you're actually going to understand pretty much everything there is to know about this static main method which is right now still a little bit mysterious but when we run these examples they start running in the main method that's defined on the example class the classes don't have to be in any particular order so well you usually put example at the bottom but we can put it I think find out we can put it up here too again normally what we'll do is we'll define classes that we're working with and we're experimenting with up at the top and then we'll have our example class at the bottom and the main method will contain any of the code that we want to run okay awesome so first thing I want to say is you guys did really well on the midterm congratulations give yourselves a little round of applause here that's actually a very good score you know and again some of you are coming from places where it's like you got an 85 and you felt bad about yourself but don't you know this is a good number it compares well with prior classes so on Monday we're gonna talk a little bit more about the midterm and I'm gonna kind of go through some of the questions with you and we'll talk about how to interpret your score because again this is almost entirely a diagnostic tool for you it's not punishment it's not something we do because we're angry with you it was something we did so that you can assess your own standing your own progress in the course you know for some of you this the midterm result that's going to indicate that you know things are going great for some of you you may need to tweak a couple of things for other people or we have some serious concerns and really what it has to do and you know this already so I'll say this right now so you can maybe start to chew on it over the weekend what I care about on this exam more than anything else is how you did on the programming questions you bombed most of the multiple-choice I'm a little confused by that but okay if you did the programming questions be able to do the programming questions you were confident about those and you did well on those and again somehow you bomb the multiple-choice questions I'm still a little confused about how that that's possible but then I'm cool you know if you were not able to do most of the programming problems on the midterm I am concerned about your future in the class because that's kind of the baseline that we're establishing that we're gonna build on as we go forward so that's the kind of imperative code that you need to be able to write so that you can just work on some of the object-oriented concepts that are gonna come up over the next month okay so again we'll go we'll talk about this why Monday but overall I was I was satisfied with the performance of the class any questions about the term exam anything else up to this point yeah yeah so the question is why release the programming questions for the midterm the answer is yes I need to double-check and make sure everybody's taken it but assuming that's the case probably next week what's not there yeah absolutely I mean we want you guys to practice okay good so let's go back to Wednesday so we've started to learn how to design our own types in the java programming language up until this point we've been working with these primitive types but they're limited they don't allow us to store very much information so now we're using one of Java's built-in features which it's a very clever idea it said look we don't know about all the different kinds of data that people are going to want to work with in the future so in addition to giving them some starting points these building blocks the primitive types intz Long's characters we're also going to give them an object system that allows them to create their own types that can represent other pieces of information other data it's really what objects are about I really want to draw this connection very strongly for you because I don't think it's made enough objects are about data the object system in Java when you define a class you're establishing a new kind of data that you can work with in your program again in this case I'm defining a person class that has a name in an age that's sort of canonical but we can do some examples later where you pick something that you want to work with in a program and we'll do an example where we kind of design a class that brings together various pieces of information about that thing that you need to store in order to work with it as part of your program alright so last time what we start where we added to our classes which are already themselves kind of exciting was this ability to hide information this ability to control access to various pieces of data that are part of our class so up here I have a class declaration for a person class this is telling Java that I'm going to create a new type in the language called person that's gonna store as its name suggests information about a person and here what I've done is no classes as a review combined State and behavior data and algorithms so every instance of a class stores the data that you specify that it should and it also provides methods that you can use to access that data and to do useful things with it so here I've got a person class and I've decided that my person is going to have both the name and an age last time we introduced these public and private access modifiers and those are Java keywords that allow me to restrict access to parts of my class and I can apply those both to variables and also if needed two methods the two we looked at our public and private and those are probably the most useful so so a public variable so let's start with variable so public variable can be accessed by anybody anybody can directly set or retrieve the value of that variable and one of the things where we left off last time was one of the things I told you that's interesting that is evolved about the java programming language is it's very very uncommon to have a public variable as part of your class normally me is a different town but I'm showing you this just so you understand that it's there if you want to you can do this I can also create private variables now again a private variable doesn't mean then that variables inaccessible that wouldn't be very useful instead what it means is that only the methods that you define that are part of the class only the methods that you associate with that class can access that variable and those methods can both read and write about so public anybody can modify it anybody can retrieve it private only the methods you defined on the class can modify or retrieve the value okay the function access modifiers public and private work very similarly so when I apply the keywords to a method what this means is that public anybody can call it private it can only be called by other methods the same class and these are these are important because here's the way to think about it when you're designing a class particularly when you're designing the methods that are part of a class we'll talk more about interfaces in a couple of weeks that's a kind of a neat topic that comes up naturally when we start to talk about objects but one of the things you're doing is you're determining what other people can do with that class if you mark a method as public anybody can call it and you should expect people to call it if you mark a method is public you will probably need to explain to other people how to use it you might have to add some documentation this is what Java doc is for right so when you look at the documentation for for example the string class what you're seeing is information that was generated by Java doc from comments that are actually in the code a private method on the other hand it's very different it can only be used by the class so really the only person who can use it if you're designing a class is you you can call it from your other methods and stuff like that but you don't have to worry about somebody using that method who didn't write your code right maybe you and some friends are working on a on a project together and maybe you're gonna publish this as a library that other people can use and if you mark the method is private it's invisible to anyone outside of your group so you guys can use it but no one else can call and that means that a lot of times you don't have to provide documentation for it you know it's it's it's private right it's only something that's useful to you all right Java has two other access modifiers and actually only one of them is visible so one of the things I don't like about Java ok so there's something called protected again we will I will cover these at some point when we talk about packages which is a organizational concept for software that comes up in Java that we don't talk about yet and then there's also something called packaged private what's confusing about Java ok let me just let me just point this out so let me get to a playground here ok one of the things that's confusing about Java is that the default setting so you might wonder what happens let's let me do a different to find a different example okay here we go let's do public name string all right so now if I create a person I haven't rubber I have a default constructor that doesn't set either of the fields so what I'm expecting person dot name to be as novel hmm oh I've got things backwards so I've been writing a lot of Collin recently and my course developers have been teasing me they said you're gonna start messing up in lecture because in Collin the name and the type of reverse was a first mistake I made because of that try not to make more all right so let's set the name and then let's print it again just make sure that this is 14 the way that we expect because we marked it as public and so there we go okay good now if I don't mark this as if I if I omit the access modifier it still works the reason for this is that if you omit the access modifier the default is something called package private and in many ways package private can fool you into thinking that it's public because it works for you a lot of the same way it's not the same as public so if I gave this piece of code to somebody else they would no longer be able to set the name the only reason that main can set the name is because it's included as part of this package that we're working with the group of classes that are bundled together okay so just to make it a little bit more confusing there's no explicit package private modifier so there's nothing like package private that doesn't exist okay but if you omit the access modifier that's what you get okay great so let's talk about getters etc so when I point it out and this isn't interesting okay so this is an interesting example of the evolution of a programming language alright so Java comes out man when did Java come out Michael look this up a tease cross fingers okay the only thing I always remember about Java is that it came out one like a few weeks after JavaScript which is interesting anyway Java comes out and has this feature says I can make variables public and you know on some level this seems like a useful thing anybody can modify the value of the variable okay so I've got this access modifier for variables nobody uses this anymore it is considered to be bad and Chuck's file will yell at you to mark any of your class instance variables as public instead this is what we do we create a private instance variable so before I had a public and age or a package private int age instead I create a private variable called age I create two special functions with very very you know mechanical syntax like I said there's a feature in IntelliJ where you can get it to generate this code for you it's boilerplate sometimes people joke about Java the Java programmer is like being paid by the line of code because a lot of the code they write is like really formulaic right like this okay so you can imagine I could write a piece of code to write this code that's what IntelliJ did okay so I've got a private variable then I've got two functions I have a function called set age and a function called get age this is a setter and a getter set age takes an argument that's the same type as the variable in this case an int and it sets the variable to whatever you pass so this is how you modify the variable get age returns the same type as the variable takes no arguments it just returns the value of the variable so notice here that my variable is private these functions are public so essentially what I've done is rather than allowing anybody to set the value of age director instead I'm forcing them to call these functions set age and get age and again this has become so canonical in the Java community this is how everybody does things right and some of the languages that have appeared after Java that are Java like will actually do this for you okay so this so essentially we never mark variables public any now here it seems like no again I'm a Java programmer and I'm being paid by the line of code I like this because before I had one line of code public int age now I've got seven so I've multiplied my my payout by seven but there why am I doing this so right now this accomplishes nothing okay it's equivalent to just having a public variable but what can I do now that I couldn't do before it turns out this is one of them so this is interesting right it's kind of a fun observation this design patter unlocks all sorts of cool stuff I have just really sort of dramatically changed the semantics of what I can do with my variables as part of my class I've got a bunch of new stuff that I can do so give me an example so again right now what I have is equivalent to having a public variable but there's all sorts of new things I can do here give me an example of one what can I do some new things someone who hasn't contributed yet today yeah yeah so every time you set the age you're running code that I wrote so I could take my setter for example and I could validate that the age that you passed is something that actually works as an age right a negative age doesn't make sense so maybe if you pass me a negative age I'm gonna do something about that maybe I won't change the age because I figure you said you set an invalid value later in this semester when we talk about exceptions we'll have some things that we can do that'll cause the person who made this mistake to realize their air okay what else can I do so I can validate my inputs that's good yeah yeah yeah I could do some auditing so for example let's say I want to keep track of how many times the age of a person has changed right I could do that I gets their code in there to do that I create a counter that's associated with it and every time that function is called an incremental counter so I can I can actually create a read so it's sort of interesting right Java has public and private public anybody can modify it or retrieve it private nobody can modify or to retrieve it what if I want to have a read only variable that is set in the constructor but then it's never modified how would I do that here I can accomplish that with this pattern let's say I don't want to have a variable that you can only read but never write with that only write together I don't have to provide a setter if I take away the center you cannot change the value of the variable all you can do is retrieve it and there are times in which that's really easy okay so by using this design pattern and I know this code got small and we'll uh we'll look at it together I can do all sorts of all sorts of things all right so here's another example right here's an example where a single setter is being used but then I have multiple getters to retrieve pieces of information that I can kind of extract from that one variable so here's a person that has both a name a first name and a last name and I know you know I used to you know when you deal with data from a course you realize that you guys have all sorts of weird names some of you only have one name so I'm have four right so I'm have like weird parts hanging on to the name that I understand but let's pretend for now that dividing your name is as simple as finding a white space and splitting it into two parts first name and last name I know that this is not true okay but we're just gonna say this for now so now look at my setter when you modify the name I actually changed three variables that are part of the class I changed the name the name just gets passed to - whatever you passed but I also do some work right I have some code in here I split the name a court a law in the first white space and I take the first part of that say that's your first name and the second part of that is your last so here's another here's an example where essentially now I have three variables that are part of the class that I can retrieve I can get the name I can get the first name and I can get the last name but I can only set the name when I set the name those other variables are automatically populated so let's let's look at an example of this okay so let's design a class together that we're going to use to store a certain number of integers okay so I have my storage class that I've created and I've gotten us started by saying okay well I know that I need to store a certain number of integers so I'm gonna create I'm gonna declare it's part of my class that every instance of this class has a variable that's an array that's where I'm gonna store the integers that you provide okay and then I'm going to provide a get and a set method that's gonna allow you to modify the integers that are stored in this the storage class now you might think why am I doing this this is like kind of really similar to an array and it is that's okay but we can add a few things too okay what's the first thing I need to do here okay so this is our this is our class design exercise for the day that's the first thing I need to do yeah yeah so I yeah so I need a constructor and actually that's a great point I could do this a couple of different ways I could have a constructor that takes an array and sets my array to that array and populates it with those values could do that what a lots of things simpler though I definitely want a constructor right at minimum what does this constructor need to know about this class when it's created yeah the number of elements I'm going to store okay so let's create that constructor right remember when we create a constructor we named it after the class and I'm gonna take a variable called size what I'm gonna do is I'm gonna use that to say storage is equal to new int size okay what can go wrong here yeah yeah what happens if size is a negative number so I can already kind of crash crash my code here which is not good so let's say storage there's equal to new storage okay so first of all obviously I can't do this anymore notice this because I've created a constructor I can't use the empty constructor which is good okay let's make sure it works with the value that makes sense now let's try to pass a bad value and now I've got this runtime error that's been created negative array size exception not good okay so what can I do about this I can solve this problem again you guys don't have enough tools to solve this problem correctly we will come back in like a month and I'll put a new tool into your toolbox and then we'll know what the right thing is to do the problem is the constructor can't fail yet but what can I do let's say you pass me a negative number what can I do to kind of work around yeah so I can check to see if the size is less than zero okay and if the size is less than zero what should I do no there's because there's several options here someone suggest something I definitely don't want to create the array with the negative size that's not working yeah I could print an error message yeah I could do that but I have to go to the pro here's the problem with constructors I have to return a value so what could I do yeah yeah I could create an empty storage object that seems reasonable I mean you messed up here so here's what I'm gonna do I'm gonna give you an empty storage object which is super unuseful and I'm also going to print that error message because I like that idea I'm gonna tell you let's do this it's a system dot error so you can also print if I print to system dot error and I'll print the size value that you there we go okay so now this I didn't crash okay that's good again this is not the right thing to do it's not terrible but it's not really the right thing I keep in mind too when we work on code together in the playground these error messages are kind of useful but when you're like working on your Android app if you call system dot out dot print Lin where does that go anyone know it goes into the output logs for your app do you know who doesn't read those the user yeah like there are other ways to communicate with user but writing to the output is not going to be seen by you but this is good for us okay all right good so let's do that for now all right so now if I wanted to store for integers I can do this so okay now what do I need this class isn't very interesting yet I need some I need to add some methods what would I like to do here so I've created an array it's empty initially ideally I'd like to be able to do what with this I mean I kind of making something then acted a little bit like an array I can kind of make it like a safer version of an array what do I need again this is not super exciting yeah what do I need what would I like to be able to do with this yeah that well let's how about it like get an element from the array if I get the array then this is acting a lot like just like an array right but yeah okay so let's write let's write a let's write a method here so it's gonna return it int mmm good okay I'm gonna write a get it's just sort of a getter although it's a little more complicated than the gutters that we've seen so far let's say I want over to retrieve a particular value from the array so what I need to know is I need to know what the index is let's say get into index and then we'll say return storage index okay so that's gonna work first time get 0 let's print that value okay who who knows what this is gonna print what's the default so I never I haven't set any of the values in the array yet the default value if Ana Reyes and initialize for int is food so the array value would be no but I set the array what's inside the array int and what's the default value for an int zero yeah you're close if I hadn't initialized the array in that constructor you'd be right yeah all right zero good okay so now let's do something okay so now I've got a problem I can stick a negative value not good okay so I would like to avoid this problem so what can I do remember this is like I'm trying to make this like a safer version of an array meaning that I don't want this to happen I don't need my code yet I could just use an array and I could have the same problems so how do I avoid this I can't avoid it right I do not this does not have to happen any what can I do I know that you guys know the answer to this question someone who hasn't contributed yet today yeah yeah so I've got code right here that's running right I know what the value of the index is that you're sending in let's just have this return zero for now so I know that you're giving me a bad index so what can I do about it so I can say if index is less than zero then I can't return the value in the array what should I return instead so I'm like I don't know this is one of those places where there's not really a right answer here I'll return negative one okay so now if you give me bogus negative indices I'm good what about okay is this perfectly safe yet what about if I do ten okay so now I've got a problem on the other side of the array because I'm only checking to see if it's less than zero what I really need to do is say if it's greater than or equal to the size of my array I get this bad value and you know what let's put that print statement in here as well so now at least know that something bad okay all right so this is kind of cool I guess I have like a safer array except there's one problem here what's wrong with my what's wrong with this code nothing wrong with it it's not very useful yet well what would I'd like to be able to do so far I have a function that will return zeros not very exciting what do I need to be able to do creating my storage class yeah yeah I won't be able to set values in the array so let's write a Sutter okay so my code is going to be very similar I'm going to set set index but I also need to take a value well let's explicitly mark these as public - all right so an I said code looks a lot like my get code checks the index now there's a problem here which is that I don't want to return negative one because this is a void function so I'll just return I check the value to make sure that you're not giving me a bogus value check the index if you're not giving me a bad index then we're good so let's try this first dot set three to five and then let's grab that value okay good I liked let's just just for fun just quickly before we move on I like that idea earlier about the other constructor that was kind of exciting let's do that all right so let's create a constructor that allows me to to provide an array now I could just say this and that would work the problem is and this is going to make more sense to you when we talk about object references in a week or two the problem is at this point my array and the array that was passed in would be sharing the same content and I don't really want that instead what I want to do is copy the array so let's do that instead so let's say our storage array is equal to a new array that's the size of whatever you provide me and then I'm gonna say go through I'm gonna go through the array that you passed me and I'm gonna say storage I is equal to values so this is just an array copy I create I initialize my array to be the same size as the one you gave me on line 12 and then the loop that starts on line 13 just goes through all the values and and prints them off and let's make sure that this works so do new int 1 2 5 and then need to change these two - oh yeah textile doesn't like this well okay so now I can ditch alized this with an erase ball any questions about this it's kind of fun so this is you know I wouldn't say this is a canonical example of a setter and getter because I'm actually setting and getting array rather than a value on class right so let's actually let's do this let's do this quickly let's do another example let's to a person example let me get rid of this code and I'll just show you I'm just gonna show you a really fast example of kind of a canonical way to set up a class like this and then I have a public string get name okay right so now I can say you don't get name yeah but there is no way to set the value of your name after you've been created yeah it's private access so this is an example of creating a read only variable by not providing a setter if I wanted to allow you to set the name I create my method that returns void it's called set name takes ah right now I have to use that function to set the name yeah all right questions about centers or gutters okay and actually let's do another let's do this here I want to drive something home here before we go on so one really important concept with objects that's difficult to wrap your head around when you get started is that every object has its own state man let's print another at the bottom all right cool so what happened here I created a person a person object on line 15 I initialized it with one name I created a person object on line 16 I initialized it with another name then I modified the name of the first person I created a variable called you when I got to the bottom I printed both you dot name and another done name and another dot name did not change that's because that's a separate object that has its own name I think I just did something very similar to this any questions on access modifiers or setters or gutters before I start the process of confusing you ten minutes before the weekend all right it's all making sense I hope yes in a Class B private that's a great question okay can a Class B private the answer is No an outer so we'll talk more about this later what we've been working with so far just a very small digression is something called an outer class an outer class is not inside of another class outer classes have to be public I can create in Java something called an inner class we'll come back and talk about this later and I'm not trying to just scare you guys before the weekend that'll work that's valid Java code the classes that I stick inside my classes can be pry the outer classes themselves cannot any questions all right so let's talk about the oops sorry right here the ones that are inside can be either private or public again we'll come back and talk about them I don't want to go too far into OtterBox okay so in our game of Java keyword bingo you can now cross off static we're gonna talk about another keyword in Java and again I bring this up with a fair amount of trepidation and we will talk about it more on Monday because static I feel like causes more confusion than any other concept in the object-oriented programming part of this course okay so when you mark something as static methods can be marked as static variables can be marked as static what does that mean up until this point the variables and the methods we've been working with the variables for example so if I look if I go back and I look at this example that I did both you and another both had their own name they have separate name variables that are stored separately they're accessed separately they're modified separately once I stick static on something that variable or that method no longer belongs to an object instead it belongs to the class okay what does that mean so a instance variable so so what does this be from a practical perspective okay so for example we have so we have some new syntax to think about right so here I have marked the method print name static up until this point I could not call an instance method if I didn't have an instance of that class in in an instance of the class in order to call the method now I'm relaxing that restriction right now as long as I have the class I can call the method so this will actually work I can call this method by using the name of the class followed by the name of the method something I can do only for static methods I can also call that method if I have an instance of the object so for example now on line 11 I've created a new instance of type course class course I can also call a static method with an instance but I don't need an instance ok up until this point there was no way to do this if you try to call an instance method without an instance of the object it fails that's why it's called an instance method a class method or a static method can be called only by using the class alright so a static method can be called directly on the class they can also be called on an instance now here's something that's important about this particular type of method because it can be called without an instance of the class it can't use the this keyword remember this this refers to an instance of the class that's running the method but with the static method there's no instance of the class not necessarily so for example here I am an instance variable again I know we're almost done it will come back to this on Monday but I really want you guys to look at this and think about it over the weekend because this is confusing one of the reasons why it's so confusing just as a brief aside is that static is one thing in Java that makes a huge difference to how things work it's a small keyword it's only you know six letters or whatever but if you put it in the wrong spot everything will stop working and then if you get rid of it everything will start working ok so I am an instance variable if I don't use static that variable every instance of the object every instance of the class has its own copy of that variable so every course has a name my method is static so there's only one copy of it and I can run it on the class but I can't access the name as part of the method because the name is part of an instance and I couldn't use this dot name either static variables so again I can have a static method static methods are typically the most useful but I also I'm going to show you that I can have a static barrier when I have a static variable every instance of the class shares that variable so any changes that they make are visible to all the other instances and I can also access it without an instance of the class so here I create two courses and then I increment the counter course count which I can access using the course class because it's a static variable then at the bottom I print count both of these can access this variable and both of those statements are going to print one okay let me prove this to you all right good all right so again here's here's why this is confusing well first of all this won't even work right because now if I change it from static to non static I can't access it that way on line 15 but let's imagine that I'm using this to track like someone suggested before how many course instances have been created so that's kind of nice every time I call the constructor I increment this counter but again the counter is shared by every instance of course so again here's one of these places where if I take that off it doesn't work anymore because now it's an instance variable and I'm increased it from 0 to 1 if I put static back here it's a class variable and now let me make sure that this is really explicitly put another print statement in here I'll get rid of this one so now after I create one course the value of count is one after I create two courses its value is two all right we will pick up here on Monday I hope that I've confused you just enough for you to enjoy the weekend so one quick announcement some of you have wanted to do this like interview for an LA s-class or something like that I'm doing gonna do those once today at 2:00 p.m. in my office as part of my office hours so if you want to do one show up if you don't you're not there at 2:00 I'm not going to do them again they get repetitive I have a great weekend I will see you guys on Monday  
﻿ all right welcome back everybody happy Friday it's getting just a case or not as weather aware as I am it's getting cold today so some of you I see like this guy here I'm not ready for that you might want to go home and change out of those shorts because there might be some cool temperatures today so but what we're gonna do today is fun warm the goal today is to connect what we talked about on Monday with what we talked about on Wednesday and I'm hoping so you know one of the pleasures of teaching a class like this a couple times is that you start to realize you know deficiencies in what you've done before don't tell any of the ca's this they all think that you know 125 was a perfect class that was handed down no directly from own the mind of a god or something like that but there are things the past that I happen always explained as well as I could and one of those things is the relationship between Java references and polymorphism and this is something actually that allows both concepts to make more sense so that's our goal so we're gonna do a little bit of a review to start off just to set the scene go back talk a little bit more about what polymorphism is we'll be a little bit more specific about it now and we talked about you know we're gonna stop using these Wiesel worlds like objects can morph into other kinds of objects that doesn't really make any sense instead what we're gonna say it's more accurate which is that if I have an object of a particular type I can get a reference to that object of that type or of any of its super types and which way I refer to an object has implications that will try to tease out as we go along okay so back on Monday we talked about the fact that you know and this goes back and is a little bit of inheritance review as well so in Java every class extends another class except one capital L object is the ultimate parent of ancestor of every Java class but every one of the new types that we add to Javas type system through this class declaration syntax inherits from something even if we don't explicitly extend another class we implicitly extend object and so objects up there at the top everything object is up there by itself at the top everything in Java extends object and then here was an example of how a particular subset of the Java class hierarchy might be organized and the idea is as we go up things get more general and we'll talk about this again at the end of class when we talked about how polymer physics so the idea is that object is supposed to only contain capabilities that Java wants every single object in the type system to have so for example two string is something that's provided by an object I want it's useful to be able to print off any type of Java object for debugging and for other purposes and there's a couple of other methods that we an also inherit from capítulo object equality so every class is expected to have some notion of equality what it means for two instances of that class to be equal that's something that we need to assign the class you get to provide right so object has all this general stuff and then as we go down the tree what's happened is things are getting more specific so we're breaking things into smaller and smaller categories so there's some subset of Java objects that we can think of as representing characters that's a pretty small subset actually there's lots of different types of Java objects you guys are working with someone on the machine project those have nothing to do with characters they've got all the different types of data all the different types of entities that we can represent in our computer programs characters have a tiny tiny little subset ok so already by going one you know level down the tree we're talking about a much much more specific set of things but even among characters there are divisions there's different kinds of characters so I'm dividing these into digits and letters right and you can imagine that those different characters might have different capabilities so for example every character might have a certain type of capability but digits and letters might have different ones and then I can further sum divide letters into vowels consonants if you're talking about a particular language system other language systems might have different subdivisions here so again as we're going down the tree you know we're breaking things into smaller and smaller categories Java's classes in this categorical everything is an object but then some objects are characters and some are not right and if there was another like a string over here right some objects are strings and some are not okay some characters are digits and some are letters according to this diagram those are your only two options now again that may not be exhaustive you may need to have other classes over there and then some letters that are not digits or other vowels or consonants again that may not be fully exhausted but as we go down we're splitting things to just smaller and smaller categories and I'm gonna come back to talk about the city in the class but one thing I want you guys to notice is as we go down we know more about the object that we're talking about putting something into a category means that we understand something about it right once I took a character and I determine whether or not it's a vowel or consonant mother knots a letter or a digit that requires knowing something more about that character so as we go down we're obtaining more information about the object that we're working with but we're working with the smaller and smaller subset of the overall object tree so again some tiny fraction of Java objects or characters some fraction of those characters can be considered to be consonants but those consonants themselves represent a tiny fraction of Java objects so as I go down I gain more information and I can be more specific as I go up a game or generality but I lose information when I get to the object level I don't know anything about that Java object it could be a character it could be a stray or it could be a pet it could be one of the main activity classes you guys create for your MP who knows all I know about it is just a couple things I can call to string and call hash code I call equals there's a few of those methods that everything has okay so as a reminder some of this I'm gonna go through quickly if I don't extend another object.extend object everything extends object and so there's this small number of methods that every object in the Java object system is going to have and again go back to what we just said these are methods that have to work for any kind of Java object any type of data that you can think about working with any type of you know entity in your program that you want to represent using a Java class has to have these features and so whatever we put on object has to be extremely gentle okay everything has to be able to support this there are certain things that objects and we'll come back when we talked about interfaces and look at certain things that Java objects don't provide because not every class can support them right but the things that are on Java objects are things that everything has to be able to do so every Java object can return a string representation of itself we've seen the fact that that string representation is not always that useful it can do that every Java object can compare itself to another Java object by default that comparison is not very useful but you can make it more useful by overriding the method in your class and there's this thing that will become a lot more fun once we get to maps at the end of semester every job object can return an integer that's supposed to be a unique representation of its contents we'll see why that's helpful in normally the default versions of these that are provided by capital object are not very useful and so when we design a class we override them we override to string we override equals with our right hash code and we make them work in a way that's appropriate to our class so when you design a Java class you could decide what it means for your class to be equal to another class another object sorry for two instances of for an instance of your class to be equal to something else what does that mean it's up to you you get to write that method okay so when so this hierarchy is used by Java when it tries to find variables and methods to either access or to call so when you use dot notation this is what's happening Italian Java you know look for a method or a variable with this name and the way this works is Java starts and we're gonna we're gonna see this in a minute so Java starts at the type indicated by the reference that you are using this is what's important this is the connection between references and polymorphism and we're gonna make this a lot more clear in a minute so it starts with the reference type and it says does the class have a variable or a method with that name if it does that's what gets used if not I look in the parent class this whole search and I this is a little bit inaccurate this whole search it's also guided by these visibility modifiers so if you have a private class name to string it doesn't get used when I call object to string that has to be public so that I can call it outside of your class so the visibility modifiers also guide this search and essentially I just keep going until I either find a method or variable with that name or I don't in which case it fails and this is a compiler this is not a runtime error the compiler will actually tell you you know your code didn't compile because you told me to call this particular method using dot notation and I couldn't find it right it didn't exist on your class or in any superclass right so you know and we talked about this before so here and and now we can be more specific about this so now I'm creating an instance of my sweet old dog class here and I'm saving it in a reference variable called chew tube that stores references of type sweet old dog all right and then I essentially print shoot you and I don't you know I don't explicitly have to use to string here I can get rid of that this is going to work the same way print will call to string for me so what happened here so when I called to when I call to string when print 'land called to string on this object reference it started in sweet old dog and it said the sweet old dog provided two string method no and it looked an old dog and it looked in dog then looked in pet then I looked in animal and finally an animal it found that to string method and of course we remember that if I got rid of this two string method or let's just mark it pried up actually so if I mark yeah okay that's gonna be mad at me let's change the name instead now I don't get that method that I just defined because it gets skipped I'm not calling any using the right name so now what I'm getting is the default object to string method which is not very helpful right okay good so polymorphism we talked about was this ability for objects to act differently depending on the context in which they're being referred and this is something that makes a lot more sense once we start to talk about references once we understand references because references are what determines the context in which I'm using a particular kind of Java object so what's really you know what it's really we're gonna talk about interfaces next week an interfaces in Java are actually really cool it's a nice extension of the Java class system that I hope will make it more clear exactly what we're trying to accomplish when we organize our objects into a hierarchy like we do in Java okay but in now here I'm being more specific okay then I was the first time we talked about this so I want you to see this can be referred to so essentially what this means is that in every if I create an instance of an object in Java for every object other than capital L object I can use two different types of reference variables to refer to that object one is the type of the class itself so in this case if I created a pet I can save that in a reference variable of type pet I can refer to it as a pet but I can also save it in a reference variable of type object and refer to it as an object and how I referred to it has consequences in terms of what I'm allowed to do with that reference which methods I'm allowed to call okay so every pet can be referred to as an object every dog now if I extend another class then I'm adding different ways I can refer to that particular type of Java object so a dog can be referred to as a pet or as an object okay so here's so and and when I when I take a Java object and I want to use it as one of it I want to save a reference to it that requires casting up the tree so for example here I'm creating a dog and I'm saving it as a dog I'm carrying a pet as some same in his pet but when I pass them to print anything I'm print anything has taken an object the job is doing that fork that me automatically okay this is probably a better let me show you it this way okay so I can do this so now on line 9 I have a reference variable of type dog called choo-choo and it's storing a reference to an instance of type dog that I created on the right side okay then on line 10 I'm creating a reference variable called ziz of type pet and I'm using it to store a reference to a new instance of type pet when I pass those to print anything Java is automatically taking that reference and casting it to an object reference now both of these classes extend or extend through inheritance object everything extends object and so that's okay so that can happen automatically so again this is sort of equivalent to let's let's draw this out a little bit better object Chuchu as object is equal to Xu Zhu object object X equal to Z's I can call in this way as well give the spell this will work but okay now one thing we pointed out about this example last time and I know I know we're going through these a few times that's okay it's a slippery stuff like I'm not you guys to see this a few times have a chance to ask questions so this can start to solidify in your mind cuz this is tricky you know from a programming perspective this is hard no it's not this is one of the this next week I would argue is probably one of the trickier conceptual parts of the class we're thinking about objects the relationship to each other how we refer to them has implications for how we use them in things like this this is this is tricky stuff so even though the code doesn't look hard there's no algorithmic challenge here there's a conceptual challenge going okay so what am I doing here so on line 9 I'm saving a reference to an instance of dog in a variable that saves a reference to dogs and then I do the same thing on line 10 except with pets and then on line 11 12 I up cast those references to object so I'm creating a new reference variable called choo-choo as object and I'm using it to store a reference to shoot you now that's going to be the same reference as it's gonna it's gonna refer to the same object there's only one dog that I've created remember if I don't see new life and created a new object so I've only created one dog okay I've only created one pet but now I have four different references choo-choo is a reference of type dog pet is a reference this is is a reference of type pet and then I as choo-choo as object which is a reference of type object and I have this as object which is a reference of type object now I'm passing those object references to my print anything now that's essentially what happens if I call print anything and I just pass it you know choo-choo ins is directly so this is sort of what's happening behind the scenes okay and again I should get rid of all these Spurs to string calls that's gonna work fine but here's the thing to remember even when I pass a reference of type object to this method clearly Java still remembers that choo choo is a dog it knows what class the object reference actually refers to a noses the class type because it's finding the two string method that I overrode in dog so this is the thing that's tricky the reference determines we're going to see this in a minute the reference type determines what methods I'm allowed to call but the instance type is still used when resolving those methods so even though I have an object reference here I'm not getting the default object to straight implementation for dog for the dog reference for the object reference that I passed that actually refers to an instance of dog okay all right and again this is sort of what this slide says instances retain their types I still know what type okay so then we talked to you know that I just want to point out that I can also down casts instances so on line nine I'm creating a dog on the right side but the reference that I save it into on the left side is a reference of type object but Chuchu still refers to a class that has type dog and so if I want to later I can downcast to two to be a pet or sorry yeah downcast so I could I can create a new reference over here called choo-choo as pet that's a type pet this is a reference variable and I'm taking my object reference and I'm down casting it so the up cast will happen automatically I don't have to do an explicit cast the down cast does not happen automatically I have to put an explicit cast here on line 11 and the reason is that this can produce a problem this can produce a runtime error if the down cast is incorrect right so let's see let's make sure this works if I do you know so I created I have an object reference on line 9 I downcast that to a pet I can do that because juju is still is a dog and so he can still be referred to as a pet and then on line 13 I down cast all the way to a dog which I can do this to true is the dog okay so let's change this a little bit what's going to happen now so run the code in a minute but let's just think through what's going to happen here on line 9 I'm creating what what type of object is being created here okay remember when you ever you ask that question you look over here you look at what's to the right of new that's the type of object that's being created I may refer to it in a variety of different ways but the type of object that's being created is a pet it will always be a pet it's never going to change I've decided to refer to it as an object on line 9 so that is doing an automatic upcast is taking what is returned from the constructor which is a reference to a pet and it's up casting that reference to refer to an object which I can do because everything extends object okay now on line 11 I'm down casting that to a pet so I have my object reference and I want to refer to it as a pet we'll talk about in a minute why I would want to do this is this going to work is the object actually a pet it is still a pet that's what was crate down line 9 where is this going to fit yeah yeah so right down here this is where I have a problem so up till here I'm fine but now I'm trying to refer to this pet as a dog and I can't do that because dog extends cat so I can't create something that was created as a pet and referred to it as a dog okay let me let me give you an example of why let's imagine that my dog method has a comeback and see this later let's imagine that my dog class has a method called wolf which prints to the console okay all right and now here's what I'm gonna do let's call choo-choo as dog woof okay so I added this method this wolf method to my dog class pets don't have a wolf method not every pet can wolf only some can okay so now let's go back and replace this with a pet and see what happens as promised I get this runtime error a class cast exception and it's being generated by on line 16 when I perform this cast because I can't take something that I created as a pet and now cast it into a dog one of the problems with doing this in this example is that my pet objects don't have a wolf method so I can't call wolf on they don't know how to woof only dogs questions about this before we go on the kind of places where things start to get a little slippery okay let's go on so Java so you might wonder how do I do this safely right I just saw an example where or something broke Java provides a way for you to test whether or not a class is of a particular type so I can say instance of if you know to choose an instance of you know it's inside will tell me essentially if that and it's a particular type of class okay now one thing I want to point out all right let's replace this I did this last time okay yeah so this is a compiler because the Java compiler is actually smart enough to figure out here that Chuchu was created as a dog even though I'm referring to it as a pet but Chuchu has no relationship with strength so the compiler will actually fail here so the compiler is still helping us the compiler can actually suss out certain relationships between classes I don't want to go into this in too much depth because it's it's subtle but but in this case I'm actually getting the compiler which is what I want right now if I use dog I'm gonna it's gonna work properly the idea is if the compiler knows that choo-choo can never be an instance of a particular type it won't even compile my code it'll just you know generate that error message and force me to fix it okay so we've been using this terminology but again just some quick review of reference variables so we're going to now we're going to refer to these variables in Java that store objects as reference variables because what they actually store isn't the object itself it's a reference to the object references and again this is reviewed last time but these are it's like this is probably the worst day of the class conceptually right this is tough stuff so references are a way to get to something but they are not the thing itself so we talked about some examples of references last time one was a phone number the phone number is not the phone I can make lots of copies of the phone number I don't have more phones every one of them refers to whatever phone rings when you call that number hey street address you know which might refer to a house I only have one house I think about lots of copies of my address the addresses of reference the house of the physical location is reality same thing with GPS coordinates you guys been working those are a reference you know like this spot on earth has GPS coordinates it's the GPS coordinates are not the spot they're just a way of referring to it they allow you to get here they don't you know and also there's a bunch of different ways of referring to this spot I could use a different coordinate system for example social security number so you guys are aware of these I mean your life is now sort of in many ways defined by some of these references you guys have an email address I have an email address is a way that people can send you mail that email address is not you it just refers to a particular email account all right so now here's what we're gonna bring these two ideas together polymorphism and references because now we're gonna be really crystal clear about what's happening when we're creating Java objects and saving references to them in that statement so if I look at the statement on line five okay dog Chu Chu is equal to new dog it's a new sound how many types do you guys see in that state we started to learn how to recognize Java classes they start with a capital letter I've got a couple of class declarations right up top I think this is the heat coming on that's just good okay it cold all right in the statement on line five how many types do you see who can point them out for me yeah what's that okay where's the one that you see well but where does how many times this dog up here yeah sorry so so there how many times do you see something that looks like a type on line five right so I see dog twice I see dog on the left side of the assignment that's the reference type that determines the type of the reference variable that's going to store a reference to whatever's created on the right side then on the right side I see nu and then I see something that again looks like a class name or a type now in this case those two things are the same but they don't have to be here's an example where they're not on line six so now on line six let's talk about what's happening so now I'm creating a dog I'm creating a new instance of type dog the instance type is what follows new it's on the right side of the assignment and if you don't see new we didn't create anything so I've created a dog but I'm gonna refer to it the reference type is an object okay so the reference type is on the left side here so this statement says I'm creating a variable called choo-choo as object and that variable can actually store references to any Java object which is anything except for those eight primitive types right any job object what I'm initializing it to is to store a reference to this new dog that I've created on the right side again now we can be very precise about what's happening I have an instance type which is on the right that determines what kind of object I've actually created and then I have a reference type on the left and what that does is it actually determines what types of objects that variable can refer to so choo-choo can only refer to dogs or anything that descends from dog choo-choo it's object can refer to objects and anything that descends from object so anything okay so now I can I don't have to create a new you know we were talked about reference variables we said we could copy references I don't have to create a new object in order to create a new reference variable so on line seven I'm now creating a new reference variable called pet that reference variable can store anything that's of type pet or its descendants and so it can store choo-choo because Chooch is a dog that refers to it the dog that I create on line five and then I can also down castings if I'm doing things proper so now choo-choo on line eight so choo-choo is a reference variable of type dog cat it has to refer to something that's a dog the object reference variable that I created in line six actually refers to something that's a type dog and so here I can do this safely oh sorry I don't know what happened here that's supposed to be on the comment so this is choo-choo is equal to dog so I'm down casting this reference variable and that's the reason that the down cast is unsafe because it's possible that that object reference could store a reference to a string at which point I wouldn't be able to do this it's going to fail okay so so again now we're being really precise about this and I think this is going to help us instance type the thing on the right side of the new keyword that's the kind of type of object you actually created it does not change ever reference type is the type of the reference variable that we're using to refer to a particular type of object and that can be the instance type so if I save to save something into a reference variable that actually the object that it actually refers to has to either be the same type or a descendant of that type so if I create a reference of type object in the Java object system I can store anything any Java object okay so here's so here's where this comes into play with polymorphous because a job but what happens it's the reference variables what actually determines what type of instance variables and methods we can access you might be wondering like carrots like well here's where this gets cool because again when I create a reference variable of a certain type the type of the reference variable is what's determining what methods I'm allowed to call all right so let's see let's see an example of this okay so this is from this is actually from the cover slide right all right so let's go through this slowly this is no this is a this is kind of designed to be you know hopefully a good motivating example for this okay so line 18 something that looks very familiar I create a reference variable of type dog and they use it to store a new instance of dog now actually sorry I need to go up and review what's happening up top here so I've actually added some appropriate capabilities to my classes here so my pet class talked about an abstract in a minute my pet class has a gun owner method so every pet has an owner seems reasonable to assume my dog class adds a bark method so it inherits good owner but also as a bark method because dogs can bark I can't class ads in the a method because cats go meow I'm still the example but there it is alright so now down here so on line 18 I create a reference variable called choo-choo and I create a dog there is only one object that we're working with through this entire example and it's created on line 8 and it's a dog sorry it's scared on line 18 and it's a dog okay let's keep that in mind choo-choo never stops being a dog throughout this entire example the only thing that changes is how we refer to you okay so on line 18 I create a variable called choo-choo that is referring to treat you as a dog the reference variables have typed off with that reference variable I can call methods they're defined on dog like bark I can also call methods that are defined on any of my parent classes so I can call get owner and I can call to string which is what's gonna happen when I run line 21 print Lin so just in case you missed this print Lin calls to string internal so I can call to string before I call print Lin but if I don't print them we'll just take the object reference a call to straight for so I don't need to do that okay so so far so good this hopefully is something that doesn't you know is starting to make sense now right I can bark because that's to find out dog I can call get owners that's to find on pet which is my parent and I can call to string this that's to find out object which is pets parent and so my answers alright so again there's only one object throughout this entire example now on line 23 I'm creating a new reference variable called pet it's called choo-choo as pet it's a tight path choo-choo is still a dog the only thing that's changing here is how I refer to choo-choo so because I referred to choo-choo as a pet I can still call get owner okay and I can still call to strength but I can no longer bark if I refer to choo-choo as a pet using that reference I can no longer call bark you can see this example is going to work fine if I try to run this now it says cannot find symbol which is weird again should you still a dog ever stops being a dog there's one object working with thread this entire example but cuz I refer to choo-choo as a pet I can no longer call bark why is that well let me show you what if instead of just getting a using a different reference to refer to my same dog object I instead have my pet reference and now I should change the names but I'm not going to do that choo choo will be offended that I'm referring to that he's a cat for a couple of lives but he'll get over it my pet reference variable can store a reference of type cat his cat extends pet but cats can't bark alright I can't call wolf or bark on a cat now I can't call me out here either even though my reference variable is a cat sorry my object is a cat because my reference variable fruits to pets so the only things I can do with my pet reference variable are things that I know I can do with any kind of pet and that stuff that is either defined on pet or inherited from whatever pet inherits so in this case that's to string and other things okay so let's get rid of this broken one and now let's look at the final instance of this where I referred to I now I take choo-choo who is still a dog who just never stop being a dog but now my reference variable choo-choo is object is of type object and now I can only call methods that I know I can call on any object so I can't call bark because not every object to bark I can't call get owner because not every object has a good owner method I can only call to string equals hashcode those kind of things okay and again you know if I try to put one of these back you're gonna see I get the same problem the reason for this is the same as it was a minute ago let's say create a string so instead of my object reference storing a dog it now stores a reference to an object that's actually a string strings can't bark strings don't have owners I can't print so that's all I can do okay any questions at this point before we go on again if there was you know last time it got to the array reference example and I said this is what you need to understand to convince yourself that you've got today this is what you need to understand to convince yourself that you've got today right but again hopefully this brings these two concepts into closer relationship with each other let me pause here for a minute like I've stunned people into submission questions about this before we go on all right so we've put a lot of cart in front of our horse today but let me talk a little bit about why we do this why does do Java's reference variables and work this way and why does polymorphism and Java work the way it does someone came to office hours yesterday and asked this question and Wednesday in essence question it's a great question okay okay so here's why and this goes back actually to Liskov Villisca off substitution principle so the ancestral relationships I establish in Java essentially allow the descendant classes to modify behaviors they inherit from their parents but they can't lose those behaviors okay one of you no one has noticed this yes but in Java I can override a method then I inherit from my ancestor but I can't get rid of it if you were a Java object there is no way to get rid of to string you can override it you can make it do something totally stupid you could return like null or something and be really unhelpful but you cannot get rid of to string your object will have a two string method tough like I said you can break it you can make it stupid you know you can like equals for example you could have equals return false I'm never equal to anything ever is that useful no can you do it yeah can you get rid of equals can you opt out of the equals program no can't do it but what polymorphism allows us to do is essentially write methods in a way that's as general as possible and we're going to take advantage of this later in the class so when we get to the last part of the class which is a huge amount of fun and we actually start designing some simple data structures and algorithms we're gonna for example build a couple of container classes you guys were frustrated by the limitations of arrays will actually implement something called a list that's a generalization of an array and we'll do it a couple of different ways to show you some of the trade-offs about how things are actually done internally when we do that the cool thing will be that our lists will be able to store any kind of Java object so anyone you know someone doesn't actually have to you could take your list implementation and you could publish it somewhere and someone could use it you don't have to know anything about the objects that are stored inside that way okay what polymorphism is really doing you know we talked about is we go up and down the tree and I want to come back to that idea here this is an incredibly you know if I think about the kind of trade-offs that I have to make all the time that people work in computer science experience often developers make all the time this is one of the biggest ones its generality versus capability so are you building a system that's going to work for everything in which case it doesn't do very much very well or it's hard to do everything very well or if you solve one specific problem at which point you might be able to build an extremely extremely good system for doing one small thing but maybe it's not doing enough so this trade-off just comes back over and over again so the higher on java's object hierarchy we go the more types of objects we can work with but remember as we go up every time we go up a class we're losing capabilities when we took choo-choo and we refer to him as a pet we lost the ability to bark because Donna be pet can bark maybe I need the ability to bark to write my cool new program when we refer to juju as an object we lost the ability to check to choose owner because not every object has an owner if you were implementing a dog walking application that would be a problem like how do you get in touch with the owner in case you know the dog walker is going to be late or something like that so the more general I can make my methods the more powerful they are but I lose all these capabilities in the in the you know most extreme case I'm working with Java objects and I only have a couple of methods I can call now it turns out that those methods are actually useful enough to be able to build some cool things which is what we're going to do later in the semester as I go down I pick up more capabilities so every time I go down a class in the tree those classes are adding things right that's added the owner property or the ability to get an owner dogs added a bark method cats added a meow method so as we go down the objects we work with they're getting more powerful but the number of objects that we can work with is getting small ok so again this is like this instance of a much you know a deeper trade-off within computer science and I would actually argue within within your life in the future in general I have a good story about this in a minute but I'll come back and make sure to be good all right so just a last little bit of java buzzword class bingo so abstract what does it mean to mark a classes abstract it means that I cannot instantiate that class I can extend it but I can't instantiate it so an abstract class could never be on the right side of new so here I've marked pet is abstract I can't create actually create a pet I can only descend from this back class this turns out to actually be pretty use yeah yeah yeah so the question was have an abstract class defines methods can I use those yeah absolutely so in answer our class works just the way a normal class does if I extend it I inherit all of its behaviors and stuff like that I just can't ever create yeah no you can create an object you want to do that we've never done that before it's kind of fun let's see let's create an object as an empty constructor there you go it's not super useful you cannot create math that's a good question so math is I think both abstract and final yeah yeah so I can't actually run the constructor it's private access all right oh okay I mean we might talk about this on Monday but so someone asked about this before I want to just mention it quickly so private classes so I'm gonna ask can I all these classes because you guys just sort of got used to this hopefully you're getting good at typing publics public class whatever but I create a private class so and the short answer is no you cannot create a in Java in Java a class cannot be private okay because you'd have the following problem right how can anyone use a private class so in order to use the class I have to be able to create one in order to create one I have to call one of its methods the constructor specifically and if the class is private I can't call any of its methods okay now here's what you can do and this is not what we're actually going to use inner classes a little bit in the future so you will get comfortable with them but just it's a little bit of you know mind-blowing stuff before the weekend Java classes can define classes inside of them so here's an example I have a dog inside that dog class I have a definition for a dog food class within my class I can use that dog food class I can create it just like it's any other class this works fine and I can also mark that class as private if I want to so for example if I don't want anyone else to use my special dog food class a market private and this works ok any questions about oh okay I am tired after talking about this I can only imagine how you guys feel after listening yeah so the question was how do static methods work in polymorphism well let's find out all right so where do we go that's my example let's create a public static I'll just call public static void oh it doesn't like this this is my math example okay so now the question is where can I call whatever this is a static method so let's see if I can call it here that seems to work let's see if I can call it here that seems to work and let's see if I can call it here can't do it so pretty much exactly the same way yeah great question other questions yeah yep so you can excite you can extend an abstract class and then you can create a new instance of the extended class that makes sense so here Pat is abstract but dog is not I so I can create a new dog I can't create a new pet there's certain so you might you know lay I should just save two more words about abstract before we wrap up you might wonder why why is this here so there are certain cases where you actually want classes that store common information about a lot of other classes but you don't actually want to be able to create them so a pet might be a good example of this right a pet would store common information across all pets but to create a pet I actually need to tell you what kind it is all right I will see you guys on Monday have a fantastic weekend I think I had an announcement of some kind nope there it is remember that we have office hours today till 8:00 p.m. and no Wednesday office hours from this point four I'll see you guys on Monday stay warm  
﻿ [Music] all right back so it turns out today is actually Friday it's good I have a weekend coming up beginning of Homecoming weekend I guess which I noticed this year they're more signs up than they were last year so that's kind of exciting who's the game again does anybody know what's a uw-madison okay might have a chance all right so today we're going to finish up talking about this is the last class where we're going to talk about objects last lesson about objects and the different object features on Monday will be almost exactly halfway through the class and we will start talking about algorithms and data structures which is the topic that will consume us for the rest of the semester now of course as we go on and talk about algorithms and data structures that will give us a lot of practice with both imperative programming which you may remember from a long time ago then involved like loops and conditional expressions and doing that sort of thing to solve problems and then also the object design principles that we've been talking about for the past month and then from time to time we'll introduce a couple new wrinkles here and there when it comes to objects but this is really kind of the last big chunk okay so the video lecture that I recorded Wednesday sort of gave you the ramp on into interfaces and what I want to do did is just really mop that up so you know I don't have most of all we're going to talk about today's review we have a couple of problems that I'll work through and could they learn the homework problems that you just finished maybe if we get to the end there's we can go over one of the homework problems that you actually have a sign for today and tomorrow but you know I'm you know I realized that you haven't had a lot of chance to ask questions about interfaces and this is also a topic that is tough you know it's it's conceptually difficult and I suspect it will challenge you one thing I want you to keep in mind you know particularly given where we are on the semester is that I bet I was looking you know at the quiz scores and this is what happens every time we start kind of a new unit in this class first couple use on objects pretty basic you guys are doing well and then the scores dropped steadily steadily probably more for those references that was rough interfaces next week I can't promise that it's gonna be any better but you guys are doing fine in fact you're doing quite a bit better than last last semester so you know hang in there once we get to algorithm and data structures things will jump up again a little bit and overall the scores for the class were really good so I'm happy about that alright so let's go back to the top 4 interfaces so you know and I'm gonna go through this you know kind of kind of quickly right if you've heard this several times on Monday and then on Wednesday as well it's so interesting this like happens once at the beginning the class knock on wood and then never again so an interface is a place within a computer system where two things come together where there's a boundary between two things this is sort of like a border alright a border is actually not a bad way to think about it right because just like a border there are two separate entities on each side of the border that have their own systems and then come up with some way to navigate that shared interface that border that they share and decide ok how are we going to communicate across this border what are the rules gonna be for how things move across it and things like that right where we need a lot of agreement at that interface so it's a boundary or a border across which you know two parts of a system communicate and there were lots of different places where we can identify interfaces in computer systems this is one of the reasons why I think it's so important to cover this topic at the end of our unit on objects because the idea of an interface is general and appears in many many different places so if you understand an interface and what it implies and what it requires of the different parties you can apply that knowledge to interfaces that exist between humans and computers to interfaces that exist between no two different pieces of hardware right you guys you know we come back later we'll be talking more about the specifics of Java interfaces but it's it's helpful sometimes to actually map this back on to some other Peter interfaces that you might be familiar with so for you know so we'll talk about how an interface establishes a contract to set of expectations between two parts of a system you guys have those expectations when you interact with your computers through the human computer interfaces that you use even if you're not aware of it so for example when you use your apps on your phone you click on something that looks like a button and you expect something to happen you might have never really thought about this or sort of you know thought about the process of expectation building that apps create when they show you a certain layout and there's something that looks like a button and it looks like it can be clicked and there's a word on it and you click it and you expect something to happen if the app doesn't do the thing you expected sometimes that can be really jarring right you might be like it's broken or it's weird or hard to use or whatever I'd so you know even when that contract is implicit like it is with these visual interfaces that we use it's still there all right and so you know and one of the most important things about an interface is that it's a place where we have to have structure agreement documentation and if we do that then two parts of a system can operate independently so again think about it Apple made this computer logitech made this little USB thingy there's an interface between them this is an interface between two pieces of computer hardware there's software that runs on both sides of it but it's up you know it's a hardware interface the reason why I can do this the reason why there's all sorts of different devices that I can plug into this laptop is because there's a standard and there's an agreement about how that interface works so if you look up USB see there's like a document and a specification for how the how it works what shape the connectors are how the devices communicate over those connectors etc so this is all laid out in gruesome detail right way more than you'd ever want to know and the reason is now Logitech can go off and make its dongle thingy and Apple can go off and make its laptop and they can become confident then in the future when some weirdo like me decides to plug the two things into into each other it'll work okay so here's another example of an interface interfaces in Java take this form so we looked on Wednesday at how we actually declare an interface in Java code an interface of Java means something very specific and that meaning is related to the broader meaning of what an interfaces in computer systems but it's still a little bit more constrained so here's how I declare an interface public that's my visibility modifier vary this starts off looking very similar to a class definition right I've got public instead of class I have interface I give it a name the names follow the same convention that I used for classes they're capitalized and then I open up a block inside my interface definition what I typically have and this is what we're going to focus on is this looks a lot like a method declaration so it's kind of like I shouldn't empty objects isn't really the right the right way to think about this interfaces look like class declarations with only methods but where the methods have no definition so there's no method implementation here there's only a signature okay so this interface says that at this particular boundary there exists one function that function is called add it takes two integer arguments and it returns an integer okay remember the interface doesn't specify the names of the arguments just that the in order to implement this I have to provide a function called add and it has to take two integers as arguments what does it what does this not say about add and again don't let the name fool you imagine add was called foo okay let's say I had an interface called foo that you know had that provided one function called foo that took two integer arguments in return injurer what's missing here from the center base yeah yeah what is this supposed to do right what is this function actually supposed to do now here's the thing this is where interfaces are cool if I knew exactly what the function was supposed to do I would implement it I wouldn't have an interface but the idea and we'll see this more when we look at comparable which is a great example of this that we're gonna use in a bunch of examples when we work with interfaces the idea here is that an interface is a good place to put things where I know that I need to be able to do them but I'm not sure exactly how they should be done for every class so and is actually a pretty bad example because I know how to add two numbers so I don't need an interface called add right I know how to write this function but when we look at making objects comparable what we'll see is that different object classes are going to implement comparable differently even though we can agree on how it's supposed to work at a high level so we provide a high level description of how an interface works then every class that implements the interface is allowed to implement it differently so interfaces can declare more both methods and variables I just want to point that out for completeness we will never really utilize this variable feature because essentially if you put a variable in an interface declaration it's like you made it public static final it's such a constant interfaces can't store variables in the way the classes store variables so that's really not the right way to think about okay so when I declare an interface what I've done is I've sort of established the contract that I'm creating between two different parts of this system those two different parts of the system don't exist yet so here's how I create one of them if I want to implement an interface what does that mean a job I mean it's that I can do the thing that the interface you know says I can meet the interface contract okay in this case again we're using the silly example of add but what the outer class is saying is hey I know how to add two numbers okay you said there's this interface and this function called add and what I really should have is some documentation here that says returns the sum of the two numbers an interface is going to declare sorry adder is going to declare as part of its class declaration so this is again new syntax that it implements ad when I declare that I implement an interface I'm required to provide implementations for all the methods in the interface declaration so here there's only one there could be more than one you know sometimes there are multiple that you have to provide here there's only one and so in order to implement ad I need to provide a method with the same signature and then I actually have to implement it okay so I'm separating here the method declaration and also the method semantics so we'll come back and talk about that in a minute from the implementation that's the power of of interfaces we'll see why that's so useful more towards the end of class okay so again interfaces don't do anything by themselves all they do is allow themselves to be implemented by a particular class and and multiple classes can implement the same interface and actually an interface usually isn't useful unless multiple classes implement so again that's why this is sort of a silly example now I have an implementation of add I don't need ten different implementations of add they're all going to work the same way but when we talk about comparable every class can implement comparable and every class should implement comparable differently in a way that's specific to that particular class okay but this is the syntax for doing this all right any questions about this so far again it was this review from Wednesday but I want to give you guys a chance to interact with this since I know but for pretty much everybody here I think this is a new set of ideas so any questions about interfaces or the Java syntax tree yeah that is true yeah so the question is I can implement multiple interfaces we're gonna get to this in a minute but I can only extend one class so in Java every class has one parent if I don't extend a class I get object it's my parent if I do I get the class I extend essentially what you would do is you would say public class add er extends foo implements and then you put any of the interfaces that you want I don't I think that's the right order try it if Czech style yells at you then it's the wrong word so I think extends comes first and then you put the interfaces you implement afterwards yeah great question actually let me just keep going because we're gonna we're gonna get to this in a second okay so so now and actually I think this is in this example it is okay so remember and this is actually a great review of polymorphism and references remember when we had an object when we had an instance of an object we were allowed to get a reference to it that was the same type as the object but was also the same type as any of the objects ancestors so I can also always for any job object I can get a capital object reference to it so it turns out interfaces worked the same way once a class implements an interface I can get I can declare an a reference of an interface type and use it to refer to that class so that's what I'm doing here on line 12 okay so again let's go through this carefully the right side is creating a class called adder a new instance of that class the left side is declaring a reference called lowercase ad that's of type capital add and add here is an interface so this reference can store a reference to any class that implements add and this turns out to be actually really useful particularly when you start to work with some container types that will work with later so I'll just run this okay so here what's wrong with this code I haven't implemented and yet in my adder class so let's do that quickly just as an example I'm gonna implement the add interface now once I declare that I'm gonna implement ADD now I get a different compiler this is all stuff the compiler can check for me so the compiler says okay you said that you're going to implement the ad interface but I don't see a method called add that takes two integer arguments so let's provide that public and AD and first and let me just make make this clear - I do not have to use the same names as the interface declaration okay great so now that works now let me let me show you why these interface reference types are important so let me do another class here called broken adder that's also going to implement add it's gonna do it wrong and so now I can say I can change my reference which is a reference to anything that implements at add to refer to broken a door which also implements ADD and now when I run the add function I'm getting the implementation provided by broken it okay so because small add is I should really use better variable names for this stuff because small add is a reference variable of type big add it can refer to anything that implements at so adder implements add broken header implements again here's another place I want to make something very clear there is no way for the compiler to know what a function is supposed to do okay this is where it comes down to those human beams that get involved in this stuff right so let me write down in my interface I'm going to say should add should return the sum of the two numbers okay doesn't matter like the computer doesn't understand that the compiler doesn't know how to read so the broken adder class which is doing something totally dumb it implements add four as far as we're concerned right so I don't want you to think this is magic there is no way for the compiler to tell whether or not you implement an interface correctly all it can check is that you provided a function that matches the signature that it was expecting so again I can do anything here I can just return zero over and over again I mean you know whatever you know I there is no way the compiler to check to make sure that I have actually implemented an interface correctly that's up to you okay so you as the programmer now here are responsible for the fact that you read should return the sum of two integers and you decided to return zero instead yeah let me let me oh okay ah okay so the question is why do why implement the interface so the idea here is that well actually let's try this let's go down here so here's all I'm gonna change here it's gone I'm gonna get rid of the implements add part of the class declaration I didn't remove the function right so let's try it let's see what happens here okay so now I have a problem the problem is that I can't get a reference to this of the interface type because it doesn't implement the interface so you might think well that's not a problem just change the adder interface to add an a reference to an adder right whatever you know why am I being so silly about this that works fine why implement the interface because the interface then guarantees to other people that you have improved that you have implemented the interface and you have that method so let's get to the end of class where we're gonna do another example with comparable like we did on Wednesday and then I hope this will become more clear because by implementing comparable what a class declares that I know how to compare two instances in myself and then anything that needs to use that feature knows that that class has that capability right I could just implement the function but then I wouldn't be sure right job wouldn't be able to be sure that the class implemented the function by declaring that I implement add implements what I'm allowing the compiler to do is verify that my class implements the interface as needed and that allows me to use interface types when I refer to it again let's come back and talk about this later I think it'll make more sense it's a great question okay all right so I'm gonna just I think I'm gonna just sort of breeze through this very quickly I covered this on Wednesday so in some level this is very similar to inheritance that's sort of what it seems like right and it turns out to be even more similar than you might think right so you might think the interface is essentially like the parent class implements is like extends there is like a there's sort of a mapping here between these concepts okay providing your own nipple petition is sort of like overriding a method that was inherited from your parent or your parents parent and so the question is what's different here and it turns out that it's even more similar than you think because remember that we could have abstract classes abstract classes for classes where I couldn't instantiate the class I can only extend it well it turns out just because it's fun let's point out the fact that Java also has abstract or in this case AB tracked nothing so a method in Java can also be abstract what does that mean a abstract method you can't provide an implementation for why would you create a method like that because when you create an abstract method what you do is you force the anyone who extends you to implement that method so ad doesn't extend doesn't implement add now what it does is it says if you extend me you have to implement this function okay so let me go back to this example we did here oh not that one and let's actually let's actually change this a bullet so let's make this an abstract class and we'll say public abstract int will say extends and we'll say extends and that works interfaces are gone I just took them totally out of picture here just converted this to the identical example that uses abstract classes in abstract now now let's see what happens if I decide that I'm not going to implement a tour let's say I implement add with the wrong type signature right what's going to happen let's say I take three arguments I get a very similar error the compiler is able to tell me hey you extended the add class therefore you have to provide an implementation for this abstract method so again this starts to look very very similar to a feature that we already have as part of the language and so the question is why interfaces right what what need are they meeting so here's the thing there are two is some good way to think about these is traits there are traits or capabilities or features that some classes can provide and other classes cannot provide and some of those don't organize well into Jabez type hierarchy and again we're going to come back and talk about this a little bit when we talk about sorting and compare so there are certain things that some classes might be able to do that don't correspond to their inheritance relationship in the tree and so if all we have is inherent it's an extends it means that for example every class that implements add has to inherit from one parent but what if there's some other capability that it also has that parts of that tree don't have so this gets this this gets unpleasant and impossible to subject right and so the real thing that you can do with inheritance that you cannot do with Java's classes is a class can implement sorry the big thing you do with with with interfaces is you can actually achieve something close to what's referred to as multiple inheritance so this is not valid well sorry okay I'm a little bit of brain fog let me back up in Java we said that every class extends one parent capital object if you don't declare it otherwise whatever you declare is part of the class declaration you cannot extend more than one parent class you can implement more than one interface here's an example again kind of a silly one it uses math examples but I have two interfaces add and subtract subtract says the class implements a method called add that takes two integers and returns to internet or the subtract method says that the class implements method call to subtract that takes two integers and returns an integer and my math II class which is now getting really capable of doing all kinds of cool math implements boat so to implement add it had to provide the function declared on line eight to implement subtract it has to provide the function declared on line 11 okay so interfaces give us more flexibility in terms of how we allow classes to expose things that they can do that might be useful right and again we're gonna get to a good example of this in a minute all right but let me let me back up for a minute and talk a little bit more conceptually for just a sec so again one of the reasons my interface is such a powerful idea is that an interface represents a contract between two parts of the system sometimes we refer to these parts as the user of the interface and the provider of the interface now this is a place where people get confused a lot so let me try to make this clear a class can provide an interface without using it it can use an interface without providing it it can sometimes do both obviously you can do neither right so the provider and the user of an interface I would say frequently are not the same class there are different classes a class provides an interface it implements an interface when I implement an interface I provide the interface so I implement interfaces so that I can then my class can be used by another class the users of the interface are separate code that lives somewhere else so we're gonna need homework problems we've been having you do this is something that people get really confused by a lot of times they'll think okay well he told me to work with comparables so I have to implement comparable no not necessarily if I told you to make your class comparable in a certain way then you have to implement comparable but if I told you to find the maximum of of an array of comparable objects then you don't you're the user you don't have to provide you so these are separate concepts but they're they're really inextricably linked because the interface represents all the information that the two are supposed to need to work together alright so now let's let's get to comparable all right so comparable is a great example of this way better than my stupid math examples so here is the comparable interface and this is this is a real interface in Java it's not something I made up it is incredibly used all right so comparable same in the interface does what it sounds like it has a single function called compare to and what compare to does is it returns of value that allows me to determine what order two objects should be put in so by implementing compared to you allow one object one instance of your class to be compared with another instance you get to decide how you do that that's up to you as part of implementing comparable now there are some cases where comparable doesn't make any sense so for examine for for example imagine that we have a bunch of pets now I know that we can come up with arbitrary orderings for those pets like we could order them by weight we could order them by age we could order them by any number of their traits but are any of those orderings really fundamental I would say no the fact that there's multiple of them as a problem right in other cases we have things that have like a canonical ordering numbers for example we order from small to big that's just how we do it it's a fundamental property of numbers we have lexographic orders that we apply to strings so when you pick up a dictionary your ability to find things in the dictionary is predicated on you understanding the order in which the words appear in the dictionary if the words appeared in a random order you would have a hell of a time with that dictionary right so there's some day there's some data in the world that has a natural ordering and again we can debate what this is this isn't like a hard and fast concept right you might claim that it's completely natural to order pets by the species that they are or something like that I would probably say that's a little weird but whatever you know so reasonable people can disagree about this but there are certain there are certain things where again every dictionary out there unless somebody's a joker and decided to make I mean maybe you guys should try that right as a little sort of hobby project put together a dictionary where the words are in random order right some people might buy it just as a prank right but every dictionary I've ever seen has the same order and I suspect this is true in other languages as well all right there's a well-established way to order things so that I can look up stuff same thing with numbers right so we have certain things where we can agree there's an order now if your class has a natural ordering what you need to do is you need to tell Java what it is and it's really interesting actually so it turns out that all you have to do to establish an order is to tell me given two instances of your class what order should those two be put in which goes first which goes second sometimes it's a tie and there's no ordering between them they're essentially the same so in that case this this comparative method returns zero but in other cases one goes before the other and it returns one or something positive in the other case the other goes before the other right so if you if if I take two words out of the English language I can we have an agreement about which goes first in the dictionary if I take two numbers out of the integers we have agreement about which goes first on the number one okay and all I need to know to put any number of those objects in order is how to order any two of them and then we'll come back to this we're actually going to do this is one of our algorithms so why would you so the question before was why would I do this why implement comparable so it turns out there's all this other code out there already waiting in Java that knows how to work with classes that are comparable because it turns out if you tell me how to put your class at order I can then do I can I have code already waiting that can do some really cool things so for example I can sort any number of instances of your class you give me a whole bunch of unordered data like let's say you're trying to produce a dictionary you give me a whole bunch of words I'll put them in order right and the order that you've that your class is expressed you have I can find a maximum or a minimum value again this is predicated on the idea of an order what is the maximum maximum is the item that ends up on one side if I put things in order the minimum is the item that it's about the other side so if I can put two instances of your class in order I could find the maximum or the minimum I can there's also some pretty cool data structures that we're going to talk about starting next week that I can build if I have the idea of how to order things so there's something called a binary search tree that we'll talk about when we talk about trees that allows me to efficiently search through a bunch of data items looking for something and if you tell me how to put two instances of your class in order I can then build a binary tree from that data okay there's a bunch of other things on this list too okay so here's the and again let me try to drive this home this comes down to the barrier the two sides and the contract so there I said before there's all this code out there in the world that uses comparable in Java that you don't have to know about so there's code in Java written that can sort things that are comparable that's down here that's the user of the interface that code doesn't have to know anything about your class it doesn't have to know anything about your class it doesn't have to know what data is stored inside of it it doesn't have to know whatever as long as you tell it how to compare two objects you implement compared to all the code down here starts to work the sorting code the maximum code the minimum code the binary tree code it all starts working immediately as soon as you implement compareto similarly when you implement compareto all you have to do is focus on how to compare two instances of your object you don't have to write the sorting code you don't have to work the binary tree code you don't have to write any of that this is an interface so waiting on the other side of that interface is all this cool stuff all you have to do is expose it from your own class and you get all of these cool features all right so with that said let's do a problem together okay so I'm going to so this is a version of the Java it's pretty much is the Java comparable interface but we're gonna use our own version here for a minute okay so this was the Homer poem I think yesterday so your job is implement class called string length now normally strings in Java and we can we can verify this in a minute are if strings in Java implement comparable but they implement it lexicographically so they implement an in dictionary order all right we're going to implement it based on the length of the string now you can think for a minute you know what would happen if I tried to build a dictionary that was ordered from shortest words the longest words would that be very useful and the answer is not necessarily like imagine you get into the area where the four-letter words are and they're all in random order and you're like I'm gonna spend a while in here you know so that's not super useful but we can still do this okay so your class is gonna wrap a string it's gonna store a string internally and it's going to implement comparable okay and it should implement comparable by using the length of this string alright so here is yeah so this this was the mistake I made on the homework hopefully people figure this out is from the documentation will get this right starting starting next week all right so the comparable the compare to function returns an integer that determines which item goes first out of the two that are provided the function only takes one argument but the other item is the one that you're calling it on so you have an instance of a string you call compare to you're comparing the string you called compare to on and whatever you pass as an argument to it so we're gonna do negative one if the other is less than the specified object or no or something that's not an instance of string length there are better ways to handle this that people talk about in a couple weeks but this is the best we can do right now they're better ways to handle the case where the thing that's being passed is not actually a string link something else zero the two lengths are equal and negative one one if other is greater so other it's a longer length all right so let's do this so and again I can actually I'm just going to pull this off because we don't need it this is built into Java so the first thing let's do this let's get our class to work right this is review but I think it's worth doing we're gonna store a string and we have a constructor that takes string argument that we're gonna use to initialize our class okay so that knocks off the strings like wrap the string that should provide a constructor that takes of string as a single parameter which is stored internally okay so every class when I create it a string length that pass it a string it stores that string internally source of reference to it in a variable called string so that my constructors done now what I need to do is implement comparable so now as soon as I do this remember Java is now expecting me to provide a method with the given signature because I've said I'm going to implement compare that method is called compared to so this is so now I'm gonna implode simplement compared to so I'm gonna have public int compare to and it takes I'm gonna call this Oh for now let's just return 0 so let's just return that the two things are the same all right and now trying to think of let's let's write a little bit of let's write a little bit of code using this to see if this works okay so let's write it let's actually write a little maximum routine here so let's say I'm gonna take a comparable max is equal to well it's create an array of values first so we're gonna say comparable values is equal to new string length I'll do new string length test so this will be an array that has one value I think I'm gonna get into some trouble with chuck style here yeah okay so that works and now and now let's let's write and again this isn't a perfect imitation of let's write a maximum routine here let's say comparable max is equal to values 0 will do for in I equals 1 first value I is less than values length I plus plus if values i doc compared to I know I can call this because I always get this backwards but it will fix it later okay then I'm gonna do system.out.print Lin max right now this only has one value lets override to string here so this is a little nicer let's just return the string that we have saved okay and now let's put another string in here new string length me and here I'm because of how I set this up I'm always going to get see if Jax I allows me to do that nope there we go because of how I set this up I'm always going to get the last value right because my compare to method isn't working yet let's create another string length and now I'll get tested okay alright so now we have a little bit of code that's using this and we have our comparative method doesn't do anything useful yet so let's let's get this to work properly all right so what's the first thing I need to do here who can help me out you guys all did this yesterday I think yeah yeah so the reference type that's being passed to this method it's an object but I can only really start to do anything useful with it once I know it's a string length and so the first thing I'm going to do is check and I'm also going to check for null I'm gonna check to see if o is actually a reference to a string length if it's not what did the instructions say to do they said to return negative one okay okay so that's helpful now what that's the next thing I want to do I want to be able to access the string that's inside this so at this point I know that this reference is actually referring to something that is a string length or that extend string but I want to be able to get at that string an instance variable so what I need to do before I can do that yeah oh yeah actually that's a good point all right you know what I'm just gonna cheat and make this public all right I would have had to advocate or had I had it probably actually know what I don't even need a I don't even need to get her here do you know why because the methods defined on the class so I can access my variables and the variables of any other string yeah that's why it's a good concern but again well let's try this let's say okay let's try to write a if ODOT string that length is less than length return negative one else if ODOT string length it's greater than string dot length I don't know if this is correct but we'll figure it out a minute return one else it must be the same return zero what's going to go wrong here it's not gonna compile why not good review review what's the problem here yeah yeah I don't have a reference to a string-length object I've reference to an object so Java you know I can't use this reference to an object to access any methods or variables that every object doesn't have so every object doesn't have a dot string variable so what I need to do is I need to say string length other is equal to downcast string length oh and now I need to go through and replace other with string length now it's mad at me again maybe I do need let's let's try making this public let's see if that helps nope ah length is a function yes thank you guys are so nice all right I'm not sure that's correct yet but we're gonna figure out I I had this I had a professor for math in in high school he was a it was actually a great guy people were very fond of him but when he would get stuck man nobody would help that guy out you know like who'd just sit back and laugh sometimes he we could so stuck that he would just have to give up and then you know we we got to end class a little bit early but so I appreciate when you got to help me out all right so now this is looking maybe correct let's try it with some other values here let's try test me okay so this is supposed to return the maximum and it's looking correct to me in the sense that if I put a longer value at the beginning I'm gonna get that one okay so this seems like it's working okay any questions about this yeah right yeah remember the reference type this is good review about references it's the reference type that determines what methods and variables I have access to if I have an object reference I can call to string I can call hash code I can call equals but I can't I can't access string because it could refer to something that's not a string line right so I have to cast it down to a string like reference first and I have to do this if you guys generate this method in IntelliJ it's gonna do almost the same thing the code that we're writing here is very easy to generate all right I check for null I check for instance of string length or instance of whatever the type is and then I downcast to it and now I can do things with it the reason yeah great question any other questions about this okay so this code so it's currently so one thing I want to point out here is the currently string length is the provider of the interface string length is using sorry string length is providing compared to it implemented comparable and it provided an implementation for the function the user is example the main method in an example class example does not implement comparable it doesn't need to it's using the fact that string length implements comparable and where is that happening so you'll see right here this is another case of up casting remember when I implement an interface I can cast an object that implements an interface to a reference of the interface type and I can do the same thing with an array so on the right side let me brief format this so totally a little bit easier to a little easier on the eyes okay and Plus work about to change it so on the right side of this assignment I'm creating an array of string length objects the reason I can cast them to be comparables going back to your question from earlier is because they implement the comparable interface if I take this out now I have a problem here okay so again I kind of want to I want to finish here with making it really clear about why we're doing this all right so let me put that back but now let's do something fun so let's pick something else that implements comparable and the other thing that I'm going to choose that implements comparable is string so string implements comparable and as I said before string implements comparable differently than and it looks like okay sorry I've got this I need to fix this this is backwards all right right so how is string implementing compared to its implementing it Lex geographically it's putting things in order alphabet order so the maximum string an alphabet order would be something like this right now it's wants to see if I want to put accents on my these no thank you right this will always come last right and if I need to add more Z's I can okay so this little subroutine that we wrote down here if you look starting at line 30 this is all done with comparables nothing here knows anything about a string a string length a number or anything else that implements comparable again this is the power of implementing interface I've got code right here and again this is kind of a silly method but whatever you know it's nice to be able to find a max without having to write the code every time it's nice people to sort without having to write the code anytime sorting is actually really hard we're gonna talk about sorting for like a week different sorting algorithms that are performance and there's some really sophisticated ones that you might want to use particularly if you have a lot of data okay so by implementing comparable I have now unlocked this whole other world of code that can operate on anything that implements comparable whether it's a string length a string an integer a double hang this is this is the trick okay cleverly I have not left myself time to do today's homework problem I promise that wasn't intentional you know so you know again did you know by just doing this one thing I'm now able to accomplish all this cool stuff all right so we are done for the day it's a beautiful day outside I hope you guys go and enjoy it enjoy Homecoming weekend good luck wrapping up NP to the next checkpoint will be released to the blue team on Sunday night to the orange team on Monday and everybody else good luck with finishing up MP two I will see you guys on Monday have a fantastic weekend  
﻿ [Music] all right everybody welcome back so today we get to continue the fun part of the class just so you understand what we're doing for the next couple of classes so today we're going to keep talking about lists we're gonna look at portions of an implementation of a list remember last time we introduced this idea of a list the list is a generalization of an array a list as a data structure that like an array brings order to its elements but unlike java's built in arrays has some useful features that can change size I can add things to either side I can add things to the middle I can take out elements I can get and set the way I can with the normal right but I'm gonna add some other features on top you guys are working on one part of an implementation of our simple list interface for the homework problem we'll go over the other parts today in class we'll look at some of that code together and then we're gonna talk about a different way of implementing lists that is going to so the first way is kind of a nice review there's some parroted programming concepts in there but also some interfaces and then the second way is even more cool because it's actually going to draw on some of the things that we learned about when we learned about objects so we're gonna have some inner classes going on we're going to see use of object references in order to provide structure add structure to data and so that's what we're doing today on Monday so next week you guys have the second midterm in the CBT F starting on Monday after class so what we'll do on Monday is will review objects so that'll be the day that we'll go over some problems together you guys can ask questions try to get you ready for that and then on Wednesday we'll come back and we'll continue with our work on lists you guys still have some homework going on next week you know people have been pointing out maybe the MPs are getting a little bit easier maybe that's okay because the homework problems actually gonna start get a little harder so you know don't worry we have plenty to do for the next month in half all right so let's review a little bit from last time because though one of the reasons we work with list is it also gives us a great chance to practice our algorithm analysis skills so this is something that we're gonna start practicing when we look at both the data structures that we start to build together and the algorithms that we're gonna build on top of them because as a computer scientist as a programmer you care about getting something to work as a computer scientist you care more about how it works and understanding how it works under certain conditions under different conditions given different inputs under different you know situations now how is this thing going to perform right that's one of the things that sets you apart from someone who can just you know grab some code off the Stack Overflow and integrate it into their project it's not a bad thing to do that's the way to get some useful work done from time to time but you know you guys are studying this at one of the best institutions in the country right so we want you to come out of here with a leg up on your peers and this is one of the places where you're gonna have that is the ability to not just implement things which is super useful and fun but also understand them and be able to make good choices when you're faced with trade-offs lists it turns out presents an actually really interesting performance trade-offs even in though they the two implementations of the same list interface that we're going to produce between today and next week are actually gonna have different performance characteristics for certain operations we're just really interesting alright and then usually you know again when we talk about algorithm analysis we're usually interested in talking about it when problems get very big not only so that's kind of what reveals the fundamental underlying behavior of the algorithm some algorithms might have like a big setup phase right so imagine my algorithm has like a big phase where it has to do all sorts of like small pre computations and things like that and then it goes into this massive loop right well if I run it with the small input all that stuff that it does first might end up taking up a lot of time but as the inputs get larger and larger and larger if that loop is looping through the entire input eventually more and more and more time that the program spends that my algorithm expense is going to be in that loop and it's going to reveal itself to be an O an Elgar right so at the beginning that might be fooled by the fact that there's some constant time steps but once I make it really really big then I see the limiting behavior of the algorithm it becomes more clear what kind of algorithm I'm looking okay good and then the the way that we're going to do this for now you guys will you know be exposed to more sophisticated approaches to doing this in the future but what we're gonna do in 125 this semester is try to put things into categories based on how their performance is related to their input right and to do this we use this idea of Big O notation right so essentially Big O notation allows us to categorize okay to put into categories the limiting behavior of a particular algorithm right as its inputs get really big right then here's our favorite graph where we look at the different types of limiting behavior so you know essentially slowness you can think of slowness is on or the time it takes the algorithm to complete is on the y-axis and the size of my input is on the x-axis and again you see huge differences here right you know I've got algorithms down here like constant time algorithms which I'm not very realistic but you know all log n algorithms can sometimes solve problems but it depends what the problem is right they're way down here they're barely growing at all as the number of elements increases whereas you know the o n factorial algorithms are you know taking off like they're going to Mars right taking off like a spaceship so they get very very slow very very quickly these algorithms down here the nicer ones get slow much more slowly so you can imagine you know again think about the think about the difference in height so imagine I take a problem of a certain size imagine I'm Google and I have some massive amount of data that I've collected about you that I want to sort or something like that right and imagine that I can move it from being oh and log and oh and or from Oh N squared 2o n log n the speed up is going to be the difference at a particular point between these two lines right so even for 20 elements you can see I'm already seen over a factor of 3 speed up between an O n square and an O n log n algorithm looks like a factor of 4 right so it made this really does make a difference no this is the difference between you know something on your computer taking you know running like that and it being the kind of thing where it's like well you better go out and get a cup of coffee you know the deep learning algorithms I was talking about before that have really benefitted from recent advances in algorithms they still take a long time to run right so you read about people training these datasets it still takes hours and hours if not days on really fast machines and this is with the better algorithms so imagine how long it took with the slow algorithm all right it's like oh I'm gonna train my deep learning data set I'm gonna go on vacation while it finishes I'll be back in three years right it's not that useful right it's like what are we doing this for so that we can identify a cat in a photo ok maybe it needs to run a bit faster than that to be useful all right so well we started having you guys work on the homework problems this is general data structure called a list and this is a great starting point for us when we talk both about data structures and algorithms ok a list builds on top of something you already understand you've already seen arrays remember arrays are a data structure arrays put items in order right every data structure adds structure to data I had a bunch of unordered objects I put them into a list now they're in order right now there's this additional piece of metadata the index that I've associated with every element right and he's an arrays are tremendously useful but Java arrays had these irritations particularly if you've programmed in Python or JavaScript or languages that make it easier to work with order data so a lot of those modern languages have a data structure so it's a list so a list is like an array except that you can you know you can get in set values and it just the way you do with an array and the notation is the same now in Java the notation is not the same okay in Java we're gonna have to use get and set on a list object and this is due to limitations that Java has with the language I didn't sleep all spots I think you can do operator overloading maybe can you do that in C++ with the bracket square brackets does anybody know this anyway maybe you can but the point is that in Java the syntax for using a list is going to look a little different rather than using my square brackets to access an element I'm gonna actually call a function I'm gonna do dot get and then I'm gonna pass the index if I want to set something I can't just do array bracket notation index equals whatever I have to say array dot or list dot set passed the index and the new value okay so it's a little bit more explicit what's going on here these are functions that I'm calling right but I can also do all this other cool stuff right so for example I can add and remove values from any place in the list so I can put values in the middle I could put them in the front I could put them in the end right and lists are tremendously useful so here's an example write a practical problem that becomes extremely irritating to solve with an array but it's trivial to solve at the list so imagine you're reading data from the file do you guys know what a file is anybody's still heard of a file anyone think they know what a file is I'm not being facetious like yeah yeah see I'm not sure you know what a file is either well a file is something that stores data on your computer right somewhere on your computer you when you turn it off there's a piece of data it has a name and inside that file there's a sequence of bytes right and you can interpret those in different ways let's imagine that we're a torpid nimis as a series of lines of text and imagine that file has data in it like about the population of champagne in each given year going back to 1870 or something like that and imagine I want to read that file and then do something like compute the average size of champagne or how much the population has increased or what the rate of growth bend over different time intervals or whatever but here's the thing when I open the file and I start reading in lines I don't know how many lattes are in the file right so in Java with arrays what we would have to do is you have to say okay I'm gonna read everything in once to count the number of lines in the file and then I can create an array of the right size and now I'll actually read my date in but that's really that's really irritating what I want to be able to do what I can do with the list is just create an empty list and then start reading data in from the file and every time I get a new piece of data just push it at the end of the list so this is something that's actually really useful and this is one of the reasons why lists are now a feature that's built in to a lot of new programming languages and be something that's being added to existing when you guys could 225 you guys will do a lot of work with vectors which are basically lists different name but they're very similar behavior okay so and and this is also a chance for us to see trade offs here because again we're going to use the notion of an interface which we just introduced right we're gonna create two different implementations of a list that behave identically okay they're gonna implement the same interface so if I give you one you don't even know which one it is it could be one kind of list it could be another kind of list it works the same way but behind the scenes what we're going to see there's some really interesting trade-offs here right lists are where we're going to start looking at this we'll come back and look at this idea again later okay so there's really two different types of Lists that we're gonna look at okay first one that we'll look at you guys have been working on the look at some code for today is something that in Java is known as an ArrayList how many people have used ArrayList before and John okay pretty common yeah we've taken ap you've probably worked with with ArrayList so array lists are a list or an ArrayList as a list and internally an ArrayList stores items in an array well you guys have been implementing on the homework is an ArrayList it's not the same as the way that java implements it the one that you get for free with the java standard library but it's you know it's not too dissimilar okay an array lists have the following trade-offs so in an ArrayList it is fast to look up an item so get and set are fast and I'll show you why in a minute we're going to look at the code for them and you can see exactly why they're fast because they utilize this property that if I have a fixed size array looking up an item indexing that array is constant time okay so constant time lookup --sf or my ArrayList but adding removing to an ArrayList is slow this is o n in the size of the list so modifications and access constant time I can get in set elements constant time in an ArrayList if I once start adding stuff then things become more complicated now I can get to Oh n behavior and I'll show again well show you why you guys are writing this code right so you can see exactly where the N and the o n comes from you can see the loop that you have to write in order to get this to work at the end of today's class we'll go over another way of implementing lists that uses linking object references to linked items together linked lists not only take up more space than ArrayList which is not something we're going to talk about at length but they have different trade-offs so looking up an element in a linked list can be slow that can be a wet but adding items to a linked list particularly adding them to certain positions the general case of inserting an item into a linked list is also o N but there are some special cases that are constant time and those special cases turn out to be significant because those special cases turn out to match common ways that we use lists okay so this is our big trade-off again same interface right so if I give you a list you can use it identically regardless of whether it's a ray list or a linked list has anyone ever used linked lists in Java before ok so there's actually a linked list class in Java a lot of people don't use it and a lot of people don't understand how to use lists and Java to the point that I've had colleagues be like oh why I was just using array lists reference and I'm just like thinking you should take my class right because that's not the way to do it because there's lots of different ways to implement a list okay well that'll make more sense in a minute alright and again these present a little bit of different memory usage trade-off as well the linked lists are less efficient when it comes to memory okay so here is the actual Java list interface okay now I do not want to frighten anybody well okay actually one thing that we can see here right is that whenever you look up an interface in Java doc it'll tell you all the classes it knows about that implement that interface and we can see some of the ones we've just been talked about so here's an ArrayList and here's a linked list there's also something called a vector in Java right there's something called a filtered list I don't know what that is there's a copy-on-write ArrayList that sounds interesting so these are all different implementations of this interface meaning that if I give you a reference to a list you can use it identically this is what's so cool about interfaces regardless of whether it's a stack you know a ArrayList a vector or whatever okay all of these classes are implementations of the list interface now there's a couple of problems with with Java's list interface the reason why we're not using it you guys can read about it actually there's a lot of useful stuff in here right but the java list interface has a lot of convenience methods in it that i don't want to implement okay it's also what's called a generic interface when you see this syntax we will come back and talk about that in a couple weeks right now that's not going to make a lot of sense but we will talk about generics and Java that's the third kind of polymorphism actually that we're gonna look at this semester okay but that's not gonna make a lot of sense for you for now so here is our list interface the simple list interface alright and this is what you guys will be working with on the homework if there's quiz questions on this which there will be and in class okay so and this really is sort of like a distillation of just the minimum things that a list has to be able to do to be used okay so let's go over this together so I have get and set right I promised like I said because lists and Java are objects I can't use bracket notation okay the bracket notation in Java the square brackets I can only use for a raise other languages you know relax that limitation but in Java if I have bracket notation I have to have an array it's too bad because if I could I could force my brac my lists to look a little bit more like a raise then maybe be more useful or they'd be easier to transition to but the fact is if I want to use a list I have to replace my bracket notation with get and set ok then down here I've got so yo get takes an index and returns an object I'm gonna create this list so I can store any type of object in it and then I've got my set method as well ok so nice at nut that takes an index and an object reference now this is another time for us to kind of review a little bit about references right so why do these take and return an object reference this allows me to store any type of data in my list my list can store strings integers I'll remember those primitive type wrappers we quickly talked about last time any type of Java object I can stick into this list which is kind of cool ok all right so so I've got getting set those are the methods that I pulled over from the array and then the two things that arrays don't have an in size right sizes the other one that arrays have here size is a method not a proper right so it's more like a string but dot length here are the two ones that you know are are more interesting for lists this is what lists add to an array I can add an object and any index okay and I can remove an object in any index so I can stick a new element into the list which causes the size to increase by one and I can put it at the front I can put it in the very end I can put it anywhere in the middle okay and then I can also remove an item from the list when I add an item I need to pass a reference to the object that I want to add when I remove an item I receive a reference to the object that was removed I don't have to use that maybe I just want to throw the object out of the list entirely but as a convenience the remove method passes back the reference to the object that was removed ok all right so let's look at a little bit of the starter code that we gave you guys for for the homer problems and I think this actually has a solution to the one of the Homer promise you guys had to do yesterday okay it doesn't have add on here because that's what you guys are working on now but it turns out remove and add are quite similar alright so this as I promised so here's my interface right and here's my implementation this class is called simple ArrayList this is our first ArrayList implementation and as promised it stores the objects in the list in an array here is the array that I'm going to use internally it's a reference to an array of objects now I haven't created it yet because I don't know how big it has to be all right but this is the internally the reference that I'm gonna use to an array to store my my object and you'll see getting set right well how do they work right I've made this private because I don't want somebody else to access and I'm gonna force them to use get and set to access the items in the array so let's look at the gettin set functions here first since these are the ones that are easiest to understand okay so I've got some checking here right where I'm basically checking to make sure that my index is valid okay so if the index is negative or it's greater than or equal to the length of the array remember an index that's the equal to the array dot length is 1 past the end of the array a last valid index for an array of length n is n minus 1 okay so if I've got a but if you pass me a bad index I return no that's true for both get and set now set doesn't return anything so if you pass me a bad index such as doesn't do any this is not really the right way to handle these problems but we'll talk about this again later when we talk about exceptions but for now you give me a bad index on add on get I'm gonna return null if you give me a bad index on set I'm just gonna fail silently okay so that's just these are just input Chucky Robert always check your inputs make sure your inputs are sane so by the time I get to line 23 your line 29 I know that my index is good and then it's one line of code right here I'm just going to return whatever reference is stored in the array at that index here I'm gonna change the reference in the array at that index to whatever reference was passed okay I can store null references in the array if I want to if you pass me a set index I element null and the array has at least one element and that's going to succeed okay but this remember trade-offs here between the time it takes to complete these operations for these two lists so this if you remember last time we talked about constant time operation so looking up or changing an element in a Java arrays constant time okay so I've got a constant time check here then a constant time operation a constant time check here in a constant time operation what I have are what I can see here by looking at the code is that get and set are constant time operations with an ArrayList any questions about this before I go on so what do you have their hand up here and then maybe they were just stroking your hair all right all right so this makes sense okay let's go down now and look at well let's look at the constructor here okay so what is my constructor do my constructor takes a reference to an array okay so this is a way to create a list from an array you give me an array this could be empty you could have references in it you give me an array of references to objects and I will create a list and so what happens here so essentially what the constructor does is it says okay my array let me scroll up a little bit here my array needs to have the same size initially as the array that you passed so here I'm gonna set my array to be an array of object references it's the same size as whatever array that you pass I put this under a check to make sure that a raise not no all right which is I need to do to prevent you from passing me a bad bad input again there's better ways to handle this but we'll get there now I go through the array that you pass and I just copy the references over so when I'm done my array has the same references as the array that you passed okay now again my erase private you can't get at and in fact if you're the user of the list you don't even know that there's an array in there right I'm gonna show you you know again later today or on on Wednesday a totally different way to implement lists where there's no array but for now we've got one we have a private array this is an array list it implements lists by storing things in array what kind of copy am i doing here by the way I'm probably two different types of ways to copy things you're giving me an array of object references what kind of copy am i doing yeah it is in fact a shallow copy so I'm copying the references from your array into my array so if you make changes to those objects later my array is gonna reflect those changes you and I have two sets of references to the same objects but there's no new do you see new being called if you don't see new or if new is not being called somewhere or no new objects are being created if no new objects are being created I'm usually doing a shallow copy to do a deep copy I'd actually have to figure out a way to clone or copy all of the objects that you pass it's not what I do okay any questions about this before we go on and look at the good stuff okay so so far this is pretty basic yeah yeah yeah so the question is when I ever give you a quiz question where you had to re-implement the entire list interface there sorry an entire ArrayList what do you guys think sounds like fun actually we should just do a whole quiz just this question now I mean we may give you like one of the functions implement yeah but we never give you the hope it's too much yeah all right so let's look at remove okay so now you can already see here right I mean look at remove you know add was sorry get was four lines of which 3 were error checking Sat was four lines of which 3 were error checking remove is not four lines removes got some meat to it so let's go through this care for okay and here's where arraylists start to the array in the ArrayList starts to cause a problem okay so so here's what I here's what I need to do okay and I'll just try to use analogy here to help you guys out imagine I have a row in this auditorium that's full of people and I want to take somebody out of the middle now because of how my arrays work I need to essentially because of how I'm storing the list in order to finish the job I need to end up with an array that has one fewer element and that means that I'm gonna have to ask everybody in the row or half the row or some number of people in the road to shift down all right so if I mention I take somebody out of the middle I take the people to the right of them and say can everybody move to the left one seat they all have to do that and now I've created some space at the end and I can essentially copy my array into a new array that has a size of one smaller right let me ask you another question why couldn't I just leave the null reference there so here's another way to implement remove let's just instead of removing the element and actually making the array smaller let's just set that index of the array to know would that work here I mean maybe it would and then we could get rid of all this Cobie stuff to deal with ad but at least removal would be a little bit easier who can tell me what is a problem with that so again I'm gonna get rid of this code all I'm gonna do is whatever you pass in is the remove index I'm just gonna say let's just do this you know again this is like way too much work let's say array remove index is equal to null return it seems like it's a lot easier what's the problem here what did I what did I essentially do I haven't really implemented remove what if I implement yeah yeah so null is a value that I'm allowed to stick into my right okay I can put no values into my ArrayList let's go down here and go back to let's look at the example code here so my example code is creating a new list of integers let's put a null value in there I can do that nulls are a valid value to insert into my ArrayList so if I if instead of removing the value I set it to null I'm essentially doing a set right there's no difference between remove and set at that point I'm just changing the value of that index right so so in order to get removed to work I actually am going to have to shift everything right this also makes sense right so imagine that I remove a value right imagine I have this array and I remove the value at the first index and back let's do that right okay so now it's two simple lists remove zero and then I'll go through and I'll print it again they put a little statement in here just to separate the two so we can see what's going on okay and actually let's for fun let's put put a put the index in here so we can see what the value is at each index okay so this is this is what we want remove to do if you if you read the official Java list documentation and this is how our Lister works as well remove should actually take the value out and the result is that all the other values shift over okay so I started with a list where the first element was one the second element is now the third element was two I removed zero so not only is one gone but I've modified the indices of these these values so everything shifted over to the left all right so now know has value 0 and 2 has sorry null has index 0 and 2 is index 1 okay so this is what I wanted to happen so now let's go through how remove actually works one of the reasons I'm doing this is because similar to app you guys are working ok so what do I need to do for remove so the first thing I'm going to do is I'm gonna check my as always I'm gonna check my inputs so I'm making sure that my remove index is valid ok now this is a place you know so so people usually when they implement ad they will use remove as a starting point that's fine but it is not the same there are some subtle changes this is one of them I'll just call this out just in case people get stuck here this check is a little bit different when you're adding a new value and you might want to think about why okay let's remove it's fine essentially I can't remove an item unless the index refers to an item that's already in a list okay so and if again if I don't if you give me a bad index I'm just gonna I'm just gonna fail and not do anything alright so let's see here what happens if I remove index four nothing happens right I move index negative one nothing happens okay if I remove the valid index now something happened okay so the first thing I'm gonna do is I need to get the value out so I'm going to return a reference to the value that's being removed and so here I just grabbed that right away okay so now I've got it and I have a reference to it and I don't have to worry about what comes next right this is what I'm going to return all right if you go down to the bottom here I'm returning this value called to return here's where all the interesting stuff happens though okay is in between so the first thing I'm going to do so remove is going to reduce the size of the array by one so my array referred to an element to an array of size n the new array that I'm going to move the elements into only needs to have a size of array length minus one so I create a new array and now what I have here and this is tricky you know you guys should ask on the form we can we can talk about this this is essentially a two a two index loop I'm keeping two indices one index is in to the array that I'm copying from that's the array that's the part of the object class that's Donna ray the other index is into new array so original index is to my original array and new indexes to my new array okay here's the thing I need to copy if my original array had n references in it I need to copy n minus 1 of them into my new array the tricky part here is figuring out which one to skip because there's one than I need to skip because that's the one I'm removing so I go through here and here's my Chuck I basically say if the index that I'm about to copy is the index that I'm trying to remove bump my original index forward one okay and you can think about why this works okay so it's like when I get to the point where I'm about to copy something that I want to skip I move my original index forward one here I just keep doing a copy so I say new array new index is equal to array original index and I keep doing let's put a little bit of code in here just so you guys can see how this is working so let's do original index I'll do it in the same order as it is below okay so here's place where I'm doing I'm actually doing my my work okay so down here in my remove step you can see the first time I come through the loop I copy 0 to 0 that's because that item is ending up in the same place the second time I come through here I'm copying 1 to 2 sorry 2 to 1 so I'm skipping one why am i skipping 1 because 1 is the index that I was asked to remove if I made the array longer let's put some more items in here right now you can see that that pattern continues so until I get to the index I'm just copying things over in the same position that they were once I get to the index that I want to remove I jump forward in my original array and now I'm copying from one past the position into the newer ok so again my original array looks like what I would expect with the no value removed all right any questions about this or we I know you got Smee looking at objects for like a month and haven't seen any code like this for a while so I suspect your brain is probably hurting but here we are it's good stuff any questions about this before we move on okay so you guys good to do a variant of this today or yesterday some of you probably already done but let's go look at our code so again we want to what we're going to be doing between today and Wednesdays we're gonna be comparing these two different ways to implement a list one using arrays the other using linking let's go back and look at the code so get n set you know I'm not saying that you should always look at code in order to answer this kind of question but if you have some code to look at you might as well start building an association between features of the code and the complexity classes so in get and set I've got no loops all I'm doing is doing an array lookup that in Java is a constant time operation so these two operations are constant time now look at remove okay so now removes a little bit more interesting right I've got a check here it's constant time this is a constant time operation where does Oh n come in here Y is remove o n yeah I've got a loop yeah exactly so starting on line 43 I have a loop and the loop goes through the entire array there are no break statements there's no return you know I'm always regardless of where the element is I'm always copying the entire new array all right if it's at the beginning I skip something at the beginning if it's the end I skipped something at the very end but I've always have to go through and essentially rebuild my new array by copying everything from the over when you guys can finish add you're gonna see that adds quite small all right so these are oh in alright now I just feel obligated to point out the fact that they're all this is the simplest possible version of this okay as befits the class that you guys are in there are all sorts of cool clever ways to make this stuff faster and a lot of them essentially trade-off performance for space so imagine I instead of so here's a problem here right the problem is that every time I remove I essentially have to allocate this new array and then copy everything into it right it turns out that particularly if I can make ads faster by just keeping an array that's bigger than I need and then I don't need to do that step of allocating the new array right so essentially and this is how some implementations of Lists work right when you start out even if the list only has four elements it has space for like 32 and then when you get to 32 if you add a bunch of new elements it's like oh okay well now I'm gonna get like 100 space for a hundred twenty eight and then when you get 220 it's like oh wow things are getting bad now I'm gonna get space for a thousand dollars of 24 you know it might keep doing this right so this this helps this doesn't mean that we did some have to copy things around internally but not having to reallocate that the memory is going to help because that takes time to job okay so any questions about ArrayList done with ArrayList I'm going to briefly introduce linked lists and then we'll come back on Wednesday but any questions about a list that stories values in an array yeah yep yeah so the question is if you've used a radius in Java you've been able to tell job of what type of object is supposed to go in that list we will get there okay this is kind of an advanced feature of Java that don't feel super comfortable talking about into a little bit later in class but we were gonna talk about generics and we will use them yeah so by the time you guys are done you will be able to build a list that only is it can only store one type of object essentially and that's useful in a lot of places because it allows you to do better error check yeah so this is Java generics this is one things I don't like about Java is that when you when you if you want to use something as simple as a list you have to kind of essentially mess around with generics which are which are somewhat complicated but there it is yeah well we'll get there great question other other questions okay so let me introduce our second competitor in the list competition which is something called a linked list so again array lists are useful a lot of people use them they're built into job up at linked lists or also useful linked let's get used all over the place it is deep in the bowels of the operating system that runs on your computer they get used in a lot of really performance critical application so they're really interesting to think about okay so remember my goal of the list is to take items and put them in order that's the structure that a list brings to data an array allows me to do that because an array allows me to index it and by using that index I'm bringing order to things right I put things in order but here's another way of putting things in order okay here's an example class called item this class can store a and this class stores two things it stores a reference to any object okay that's the data and then it has one piece of structure it knows what the next item in the list is okay only two things here right a reference to an object that's the data just like an ArrayList had a array of object references a linked list has items that can store references to objects that's good and then I have a reference to an item this is actually our first example of a recursive data structure where the data structure definition depends on a reference to itself okay so and then I have a reference to another item and the reference is called next that reference is to the next item in the list so an item in a link in this type of list does not know what its index is it only knows two things here's my piece of data and here's the next item in whatever list you're working okay and here's how I can use this to create a list so essentially I can start off by creating a list I hold I'm holding a reference to an item that's a reference to the start of my list okay and at the beginning I create a new list by basically putting an integer into the list and setting the next item to no so this list now has one value okay it has this item that has a reference to know if I want to add an item to it here's how I do that all right that's good this gets true this gets tricky okay so here here's how we're going to talk through the right side of this expression I'm creating a new item the object that the item holds a reference to is an integer eight and the next item is whatever items points to when this starts to be evaluated so when I started evaluating this items pointed to the item with value zero when I finish evaluating it it holds a reference to this newly created item so again now I have two items that I've put in order and I can keep doing this alrights and I have three items that I've put in order I have a reference to the first item in the list that item has the reference to the next item in the list that item as a reference to the next I mean list none of these items knows where it is in the list there's no index as part of my item class it just knows two things here's my data and here's the next item in the list if there is one if there's not a next item in the list if I'm the last item then my item my next references no okay and so what we're gonna start to do on the homework you know next week is start to work with this class okay so here's one thing I want to point out our implementation of the simple link list class is going to use this inner class feature we talked about this really briefly I just want to make sure this doesn't scare anybody okay my class simple linked list that eventually is going to implement all of the same methods that are part of the list interface that my ArrayList class implemented internally it uses a this this class called item now this is not a class that anybody else needs to know about it's only used by the simple linked list implementation and so rather than having it in a separate file or at the top level I'm gonna put it inside my simple linked list class declaration this is something called an inner class they don't work any different than other classes in Java except for the fact that other classes that might try to use my class don't necessarily okay so again I can do this you know this is an inner class it's not scary you know it's just like another class it just happens to be declared in a different place right okay oh and I can also so inner class methods have so okay so this is this this is important an inner class method can access variables in its enclosing class even if they're private so if i have code inside my item i can access private members from the simple linked linked list class okay so this is kind of a kind of important alright so okay so let's talk about you know and and this this code works fine right in our playground you know there's this will compile and run and we and we can do stuff with all right okay so now let's let's start looking at some actual code for different operations that we might want to do on a linked list alright so again this is gonna be this process is gonna be more incremental right working with linked lists we're introducing them today you guys gonna see just a peek at it we'll come back and talk about these on Wednesday you guys will see them on some homework problems next week but I recognize that this is I think I think a more complicated concept for people to deal with mainly because it involves linkage and working with references in ways that are going to strengthen your understanding of references even if they're gonna feel a little bit unfamiliar and strange at first okay so and the other thing is - it's actually going to take us a little while to get to the point where we can implement the full list interface we're gonna have to start small so the first thing we're gonna do is we're gonna implement something called add front alright add to front does what its name implies this is a special case of add eventually you guys will do the full case of add and remove but the special case of add at the front of the list is easier so that's where we're gonna start okay so let me go back and look at my list interface so the only thing so this is the thing that's cool about my simple linked list remember my ArrayList stored an array of object references internally the only thing my simple linked list needs to know is where does the list start so internally the only thing that it stores it defines this new class that it's going to use to wrap the data that gets put inside of it but the only piece of information that you need that the class has to maintain is this one piece called start start as a reference to the first item in the list because if I could find the first item then I can find the next item and if I find the next item that I could find the item after that this is the beauty of linked lists I don't need an array to store a reference to every object in the list instead I store the structure within those objects themselves so every item stores part of the list structure it stores the next reference so imagine you know I talked before about you know the ArrayList is sort of like a bunch of people sitting side-by-side you know in one of these blocks of chairs the linked list would be like if I gave each person or every person that's part of the list the name of the next person in the list so I could start it somewhere in the auditorium and I could say okay you know who's the next person on the list you give me a name and I would find that person maybe they're up in the balcony I would go to them and say okay who's the next person I can do that and I can use that to create a list with as many items in it as I okay all right let's come back here and start up here on Wednesday I think this is a good stopping point even though I didn't get it's quite as far as I wanted to that's fine so the mp3 earlier deadline is this week and good luck with that on your deadline day whatever that is and I will look forward to seeing you guys on Monday have a great weekend  
﻿ welcome back everybody so I'm just gonna blast off to Dick's we have a lot to do cool things to look at so today we're gonna implement our first sorting algorithm we're also going to go back and look at a last little glimpse of trees before we move on from trees for the manor with this bester there's a new feature of jobs a javis type system that we're gonna introduce today so it's gonna be it's gonna be fun alright so let's start by doing a little warm-up problem on trees so this is remember I said before that you know when you start to learn how to write recursive algorithms I mean we're Chris dog herbs are very cool right I mean there's that there's a real high degree of elegance that you can achieve sometimes when you choose to approach a problem in a recursive manner break it into smaller pieces solve the smallest problems combine the result together but it's important to remember that there's no problem that you can solve with the recursive algorithm that you can't solve with an iterative algorithm and there's no problem that you can solve an iterative algorithm that you can't solve with the recursive algorithm pletely complimentary to each other so I think a good way to convince you of this is to essentially flatten a tree so we use a tree to store a bunch of values and in some ways some of the programs that we've written that run on trees like if I'm looking for a value say I'm searching for a value in a tree I can write that program to run on a list as well and so you might wonder like why am i storing the values in a tree well we started to look at binary search trees we see ok now I've got some additional structure in the tree that allows me to get log n performance for search which is kind of cool but let's let's just demonstrate to ourselves and anything I can do with the tree I can do with the list by actually taking a tree and converting it to a list and this is pretty similar to a homework problem you guys did on Wednesday alright so here's what we're gonna do as usual we're going to design a recursive this is a tree traversal algorithm so this is going to visit every node in the tree and add it to a list when we're done we're gonna have a list that contains all the values that were in the original tree and then it's possible that we could use that Liss to do other things like let's say we want to find the smallest value entry or the largest value in the tree we could take the tree put all the values into a list sort the list and then we would know the answer to some of these questions okay all right so the base case here is you know as usual I've reached an empty tree if I reach an empty tree I don't have any nodes in that tree that need to add to my list so I'm good recursive step is as usual I'm going to consider my right and left subtree separately so in order to make sure that every node ends up every value at every node ends up in this list I have to add all the values to my right subtree all the base my left subtree and all the values of my rights up all right and the way I combine the results together is I use this list so I'm adding myself to the list and then I make sure that all my children in my left tree have a chance to add themselves and all the children in the right Torpy have a chance Adam selves so this is a case where you know again that the skeleton of this algorithm that we've been writing these programs we've been running it on trees is pretty similar but this is a case where it's kind of interesting the way that we're going to combine the results is we're actually gonna create a list in the wrapper function and then we're gonna pass that list down as we recurse into the tree and the way that we combine the results is essentially by modifying this list okay so let me just pause and and talk about this data structure you guys have actually already implemented these lists are a tremendously useful data structure you know you can get a lot done you know I used to tell people and I still think this is actually true you can get a lot done as a computer scientist with just two data structures one is the list the other is something called a map that we will talk about a few weeks all right lists are incredibly useful if you don't understand how to use lists and maps there's a lot of really important high-impact real world problems that you can work on and solve that's kind of all you need right answer your data structures come in handy you know in certain places and stuff like that but particularly for building prototypes and for solving a lot of problems that really have a lot of real-world impact you don't need a lot of fancy data structures right you can get by with lists and and maps all right so we've implemented these together so you have some idea of how they work but as you know when you go out into the real world as a programmer your typical approach when you need to use data structures should not be to implement it it's not a good idea and in fact it's such a bad idea that if you do that in a job or whatever people are going to be concerned because look you're not the first person in the world who want to use a list and people have been working on this for a long time and there are existing list implementations this is true of trees and pretty much every data structure you can think of has a good reference implementation in pretty much every programming language you can think of and unless you're taking a course where there you're implementing these for fun to learn how they work you should just grab the ones that are already there so in Java these are in these packages arraylist and linkedlist is the one that people tend to use okay now here's but here's another place where we're going we're going back and we're introducing or refreshing this concept of interfaces because you can use so I could write this a little bit differently down here here what I've done is I've created two lists reference variables so I've got a list reference variable called list and I've got a reference list reference variable called another list list in Java is an interface it's an interface that both ArrayList and linked lists implement list has those functions that you implemented before get set add remove as well as a bunch of other useful things okay so ArrayList and Linkedin plantasia of the same interface now by taking the right side where I'm creating the new object and then casting it to a list you might wonder why am i doing this I could just have list on line five being ArrayList reference and I could have another list on line six be a linked list reference but the nice thing is if I use list if later I want to switch between an ArrayList and a linked list I can do that very easily without changing a lot of my code okay so let's actually use these to solve our problem here's the list as I promised this a list interface in Java and there's something about this you don't understand yet that thing in the the triangle brackets we will get there in a couple of weeks in fact we'll start talking about that today as the feature of Jabez type system known as generics that allows me to create containers that hold specific kinds of objects without knowing what kinds of objects there are actually going to hold all right so here again I can create two different types of Lists and if I wanted to because the list reference might because my list reference is an interface type it can hold either an ArrayList or a link post if I make so sure so here's what people do you know I had a colleague it was like oh yeah you know I just always use array lists now the problem is if later in my code I realized that the problem I'm solving would be better served my code would run faster with the length list I can't switch and I'm stuck so I would always suggest that you use whenever you're using a list have your reference types be list types not ArrayList types alright so let's solve this problem that we reposed so what I want to do is I have a tree and I want to put all the values into a list okay what I'm gonna do in my all values function is a lot of times our wrapper functions have just immediately called into the private function and started it on the root node here I'm actually going to use the chance to create my list so I'm gonna say list values so I'm allocating a reference variable of type list and I'm gonna create a new and let's just use an ArrayList for now I could use a linked list well it's using array list we actually go back and switch it in a minute and I'll show you how easy that is and then I'm gonna call all values and I'm going to start it on the root node and I'm gonna pass it this list of values so now my private wrapper function looks like this takes a current node and then a list of values okay and then so what's my base case when do I stop I always want to start with the base case how do I make sure that what's that's what's the point at which I've reached the smallest problem yeah well my note is null so at that point I have an empty tree right so if current is equal to null there's no nodes here right and so what I'm gonna do is I'm just gonna return the list that I was past I don't want to modify because there's no note here to add otherwise I've got to do three things I've got to make sure that I put my own value in this list and then I have to also make sure that my right subtree my left subtree my right since we both have a chance to do that as well so here what I'm gonna do is I'm going to say values not add current value that if I remember correctly puts it at the end of the list I can also put it at the front but it doesn't matter I didn't say that we had to put the list into the I didn't say we had to put values into lists in any order okay now I'm gonna do I'm gonna restart all values on my right child I'm gonna pass it the list and then I'm gonna restart all values on my left child and pass it the list and then I'm gonna return the list that now has my value all the values for my left subtree all the values for my rights all right let's see how this works see if this works okay that seems to work let's put some additional nodes in here let's make sure it works for an empty list good okay questions about this example we could probably make this a little bit cleaner a little simpler anybody want to make a suggestion how to modify this slightly it's a small tweak that I think might might allow it to make a little bit more make it a little cleaner might help them make a little more sense any suggestions done I mean this is this is pretty good as it is so so here's what I might try so here's what's interesting about this so the wrapper function is the one that creates the list it then passes a reference to the list to the the private function right but what if I did this I could essentially start my wrapper function on and hand it the list that I created and then when the wrapper function returns that means that all the nodes in the tree had been visited and they've all been added to the list and then I can return the list that I still have a reference to so what this allows me to do is make my wrapper function return void so it doesn't actually need to return the list it just needs to make sure that it passes the list to the right left subtree so they get a chance to add their notes so again a little a little bit cleaner because any questions about this before we go on so again so now what I've got is I've got all the nodes in a list right so let's say I wanted to you know figure out if there was a particular value and in my tree right so we've already done search right what I could do is I could say list values is binary tree all values and I could say for integer I in values you know if is equal to 8 I'll print oh yeah right okay this is this is gonna be see here yeah okay well we'll come back and fix this in a few slides yeah there's a there's a problem with the list that we're getting back to the list of objects right all right let me let me so you know let me talk we we pointed out a minute ago that if I instead of using array list references if I use lippert release references I can change this really easily and I can so let's instead use a linked list to store our values and it works fine yeah so essentially this is the nice thing about using interface reference variables rather than tying them to specific implementation right I don't need to know how the list works I just need to be able to add items to it right all I really all this code really needs to know about values is that I can add an item to it that's the only thing we're doing so both array lists and linked lists and whatever other fancy I think there's something called a tree list that stores things internally in a tree all of them are gonna are gonna behave the same way from our perspective yeah yeah so that's a good that's a great question so it depends so so can anyone answer this question yeah yeah so essentially this tree is built randomly so if you look here when I add so one is always going to be the root note because it's the first node but then when I had to half the time twos gonna go on the white side of one and half the time that's gonna go on the left side of one okay and if you look at my algorithm my algorithm always adds the nodes from the right side first by and then the left side so about half the time it finds two on the right side half the time it finds two analogues that make sense yeah and if we run if we run this a bunch of times we'll see that you know over time I suspected about well looks like it's less determinate less even than I would want but I think about half the time you would expect this to be one five two and the other time one dude great question what the questions about this before we go on all right so so last time we introduced sorting is an algorithmic challenge as an exciting interesting problem with really deep roots and something that's the building block for a lot of things so today we're gonna look at our first sorting algorithm it's called insertion sort we'll start talking about merge sort at the end of class today so I mean I don't run out of time in lab next week you guys are going to chance to work on selection sort and on Monday we'll come back and talk about quick sort so merge sort and quicksort are really cool because they're both examples of recursive sorting algorithms and ones that have really interesting trade-offs so today's sorting algorithm is also kind of fun but it's an iterative sorting algorithm it's sort of a warm-up for us all right so let's talk about insertion sort all right so here's here's the main idea behind insertion sort here's my array of unsorted values all right again we're sorting arrays we're sorting array of integers and we're gonna sort them in ascending order but we could sort we can sort of raise them anything anything that we can compare two values and we could sort them in either order if we want but just for the sake of simplicity this is gonna be our default sign so the what what insertion sort tries to do is in every step of the algorithm it tries to increase so it starts the left and it builds a sorted part of the list or of the array so right now that sorted part is empty okay and what I insertion sort does and as every step of the algorithm it makes that part of the list that's sorted one item bigger and it does that by taking the item from the right side of the unsorted section and moving it into place in the sorted section so I can start now here's the thing so I can start with eight right now when we implement this we're gonna allow the sorted section to start with one value in it because an array that has one value is already sorted right so now what I need to do is I need to take five and I need to put five into the sorted part of the array so in order to maintain the sordidness of the first part of the array I had to put five before eight okay so again now my sorted section has two values in it my unsorted section has the remaining six and I continue this process so now I take seven and I move seven into the sorted part of the array okay so seven needs to go in between five and eight I'm gonna take three threes gonna go all the way back at the beginning I'm gonna take four form you know finds the right spot I'm gonna take 11 11 stays put the woman is the largest value so it turns out it was already in the right spot I'm gonna take six six ends up kind of smack in the middle and then my last step requires taking 11 and moving it all the way across the formation okay so every step of the algorithm conceptually for this is why it's called an insertion sort I take one value and I insert it into the sorted part in the right spot okay so you know again in each step just go back a few here I took six I inserted six into the array in the right spot here I took negative one and sort of negative one into the array in the right spot if I continue this process obviously the sorted part of the array is getting bigger by one every step so it's going to take n steps to finish the job now the question becomes though how long does each step take so again this is not an O n algorithm there are n steps that I have to run but you might start to think about how many comparisons do I have to perform to figure out where a particular value goes okay so now let's look a little bit more carefully I think yeah so this is just another version of this kind of showing you where the sorted item ended up right so here now it ends up here great so now let's look at a single step okay so that's the outer operation of the algorithm now let's look at the single step of inserting a value into the right place okay so let's say here my sorted part of the array has six values in it it's in blue I have item six that I'm trying to insert into that sorted section so remember I know that the blue values are sorted and I'm going to use that in my algorithm to know when to stop but I don't know where six should go right so what essentially what I have to do and what our implementation is going to work is I'm gonna start six where it is right now and I'm gonna start moving it to the left and every time I do that I'm going to compare it with that value so essentially my first step is to compare 11 and 6 and I say is 11 bigger than 6 is 6 less than 11 right if that's the case then these two values are out of position all right 6 should go in front of Loven so actually the way that our algorithm is gonna be implement is we're going to swap them right so I'm gonna swap 6 and 11 because 6 needs to go to the left now I repeat the same process I compare six and eight and I say is 6 less than 8 the answer is yes so eight needs to move to the right six needs to move to the left keep doing this I compare 6 and 7 is 6 less than 7 yes so again 7 goes to the right 6 comes to the left finally I get to the next value in the sorted section which is 5 now I say is 6 less than 5 no now I found the right spot so now I can stop and that's where I'm going to insert 6 ok so again this step of the algorithm it's exploiting the fact that the blue part of the array has already been sorted because if if you know the fact it's already been sorted means that as soon as I find a value that's equal to or less than 6 I know where to put it right I know where it belongs I found that spot at me right ok questions about this actually before we give it a try do our first sorting algorithm and the Medusa mail system yeah why would you go from left to right so the let's go back and look at our other diagram hey yeah this is this is an arbitrary decision right so the way that we're going to implement insertion sort the sorted part starts at the left and grows to the right you could implement it where it started at the right and grew to the left at which point you would take a value and move it right right but the idea is that be in any step the next value that we want to insert is the first value in the unsorted section and it needs to go into the sorted section now we could start it from the right to right you can actually do that when you're swapping values it's either to start it in place right yeah so essentially the way this works internally you guys will see us a minute is I swap when I'm when I'm moving four I swap eight and four I swap four and seven I swap four and five and then I stop right so I'm essentially I'm moving values by exchanging yeah great question there's there's several different ways to implement this you can implement it where the sorted section grows from the left and you move values from the right you can implement it where the throat of section gross in the left and you men's values to the left and all of the other combinations right I think to me this is sort of makes most sense but other versions of it may be more intuitive to you great question other questions all right let's give this bad boy a try since always the time of year where I do some practice before class because these are tricky all right let's do the easy part first let's check for bad inputs so if I have a null array I'm just going to return null so I think I do with that an array otherwise so let's go back here and think about how a single step works right so my outer loop is essentially the the place where I'm growing the sorted part of the array okay so remember they're the outer step of the algorithm is growing the sorted part of the array one value at a time and I'm gonna start not with zero but with one right because the first if I ignore the first value when I'm doing this time starting with the sorted section it has one value and that's already sorted right this also means that if you asked me to sort an empty array or an array with only one value in it my implementation is going to stop very quickly because it doesn't have anything to do if you ask me to sort an empty array I'm never gonna enter the loop at all okay okay so now I'm gonna start my so now I'm gonna start my J value and I'm gonna start J at value I I could start it at I minus one it's just it started at I actually I need to start at a so I'm gonna start j8i right I'm I'm moving this index back towards the beginning so I'm taking the value at J and I'm going to want to move it back towards zero as far as it needs to go so whatever so the the unsorted value is the value at J and I want to move it back to the left I'm going to continue this as long as J is greater than zero and I'm gonna decrement J each time and I'll show you why greater than zero in a minute all right so here's the two and it's useful to think about this when when at the first time we go through let's say it let's imagine we're just thinking about the first two values so the first time we go through I is equal to one okay I start J at one the two values I want to compare are the values that index 1 and the values at index 0 okay and what I want to do is I want to say if input array J minus 1 is greater than input array J then I need to swap them so what this means is if the value to the left the value to the left is greater than the value to the right I need to swap the two I've got a I've got two values in my array that are out of place so eventually when I sort my array and if I went through and I compared every pair of values the value on the left would always be less the value with the smaller index would always be less than the one next to it less than or equal to it would never be greater so if I find one where it's greater I found two values that are out of position so now what we're gonna do is we're gonna swap them and this is just a standard swap that I think you know we looked at earlier in the semester so in order to make sure that I what I want to do is swap array J minus 1 and Ray J in order to do that I need a temporary variable so I don't lose the value in this case of array J minus 1 so I create my temporary variable I set it to J minus 1 I overwrite J minus 1 with J and then I set J to my temporary variable which or the original value of and put a rage a mattifying okay so let's see if this actually works oh look at that pretty nice now here's the other thing though let me go back there's one thing that we need to do here in order to make this make sure that we get the performance that we want here right so let's go back and look at our algorithm so remember what we did so essentially what we've just implemented is this step where we're taking the first value from the unsorted part of the array and we're moving it left comparing it against its neighbor until we find the spot where it stops so here and then we're going to insert so what can we add here that represents so there's this so we have the part where we're moving in over but what else can we put in here that will make it run a little faster and represent the point where it's like I know where it goes right so essentially the code inside the the loop is what's doing the swapping right and at some point if I'm not swapping it what can I do let's go back to our diagram again so here after I do the insertion I don't keep going I don't need to look at examine 5 &amp; 4 in 4 &amp; 3 right I know they're already sorted ok so what can I add to my insertion sort recipe yeah let's put a break statement down here this is dangerous let's see if it's still gonna work so such I'm saying if the 2 items are out of order then I need to keep shifting the unsorted item to the left because it's not in the right spot yet but if the 2 items are in order I've entered the sorted part of the array and I'm done I don't need to keep going all the way to the beginning all right so let's try this to make sure it still works it does ok cool questions about this this is like good you know I know you guys you know we started off with this imperative programming and we wrote some kind of gnarly stuff and now it's like you we've seduced you with objects for you know the the middle of the semester and you didn't have to write any complicated imperative code and it's back yeah so insertion sort selection sort you know these are can be tricky to to think about any questions about this yeah ah okay well let's come it so the question was is there a better way to do it than N squared and the answer is yes but let's come back and talk about that a minute yeah great question first of all let's think about the performance of this algorithm actually is okay so what I want to do here is I want to count the number of swaps that I have to do and before I return I'll just print off the number of swaps that I did okay so here to sort the array required 18 swaps all right let's make the array one item bigger now it requires 22 let's make it let's put another item back in there now requires 23 well these are ones that go at the end that's the problem when you put one like this right now requires 26 what way bat 35 okay yeah so how many values on the array it looks like I have 10 now and it's thinking me 35 swaps to get through to get through the problem right so what is the time complexity of this algorithm right so what's the worst case let's go back and think about our array and one step so remember my insertion step stops as soon as it finds the right spot so what's the worst case for the insertion step where I started at the right and it keeps swapping keep swapping and keep looking for the spot to insert it and at some point yeah yeah if I have a value that belongs at the beginning of the array meaning it's the smallest value in the array then I have to drag it all the way over to the left side okay all right so if that's the worst case for insertion that step what's the worst case input for insertion sort so again if we go back here and let's go let's let's go back to an eighth item array if I give you eight values to put in here and your job is to make insertion sort take as long as possible what eight values are you gonna put in there's actually a lots of choices but how what's going to be true about that those eight dots yeah they're an opposite order yeah so let's try that let's do eight seven seven six five four three two one twenty-eight yeah as bad as it gets like it's every time I go through I've got to take that value and I've got to move it all the way to the left all the way to the left all the way to left right if I take any of these and swap them let's try put in 4 here and 5 here then I get 27 right like I made it a little bit better but the worst it can be that's funny Agron works by day for one time ok so what about the best case input right so now it's thinking about my inserts up again yeah yeah if it's already sorted ok so now let's do this 3 4 5 6 7 8 I didn't know swaps it all right because every time I went through the array and I picked the unsorted it was already in right spot right never I'd do any work you know and again if I make this slightly out of order all right let's take just do this I got one swap all right if it was an order okay so worst case is Oh N squared if the array is sorted in reverse order and again there's that there's some constant factors here that I'm ignoring so for example it's not exactly o N squared because it's I only have to move it one I only have to one swap the first time two swaps three stops four swaps right but that outer loop is running end times and the inner loop starts out running one and ends up running n so the inner loop is running like n over two and so it's really N squared over two all right the best case is if the array is already sorted all right average case you know again this is one of those places where it really depends on the data but typically what you see quoted for insertion sort is Oh n square that's if I give it random inputs right not worst case not backwards best case not sorted but now here but here's the thing that's cool about insertion sort I want you to remember this because really none of the sorting algorithms that we talked about in this class are worthless they all have some value the good thing about insertion sort is that it's fast when the array is already sorted so let's say you have some data and you're pretty sure it's sorted but you just want to run it through a sorting algorithm to be sure insertion sort is a good choice for that because if the array has already sorted it's very fast okay the algorithm we start talking about in a few minutes a recursive sorting algorithm called merge sort does not have that property it's always and log n even if the array is already sorted okay so insertion sort does nicely there the other nice thing about in certian sort of said it doesn't consume a lot of extra space so if you go back here to our implementation essentially I have one extra temporary variable here and if I want to be clever about this I can actually move the Declaration of the temporary variable outside of the array outside of the loop sorry so now I have one temporary variable that's it the rest of the work is being done inside the original array right and again we look at merge sort and we look at quicksort we're gonna see worse space complexity there were more computer memory to do the same task merge sort sorry insertion sort is just like just gonna be one temporary variable and I'm good right alright so we're gonna start filling out this big chart and we'll keep coming back to it and look at merge sort and look at quicksort and self ID but this is our summary for insertion sort okay now I think I mentioned this last time but we know that we can do better than this right particularly this average and worst case performance sorting algorithms you can prove should do no worse than Oh n log n right and so if you find a sorting algorithm has Oh N squared behavior in the average of worst case you know that it's not optimal right so we know that there are better alternatives out there okay let me let me do a brief very brief digression into Java generics just to sort of start to speed your mind four things that are gonna come downstream all right and this is actually the reason that we had this problem earlier so again you're gonna use lists because lists are super useful right we're also gonna use maps and other built-in Java data structures in the future however lists had this problem that we observed actually a few minutes ago and I just decided not to solve because I was excited to get to show you this here okay here's the problem the way that we've been using lists right now we had we have not told Java what type of objects we're gonna put in them and so essentially what we're using is a list of can you guys just not have an ongoing conversation during class I can hear I can hear it yeah thanks it's distracting all right so the list that I've created on line six is a list of objects so here's what happens when I add that string to the list Java up casts it to an object so on line 10 when I try to pull it out Java won't downcast it for me because it's sort of forgotten about what kind of object it is it says well what you put in was an object reference that's all I know about it so when I get it out it's now an object reference and that's not very useful right now again what you can do if you know what's in the list is that you can do an explicit cast right and then I could print off the value but what if you put something into the list that's not a string now I get this runtime error which is really gross okay so you might remember like a month ago we talked about the fact that one of the things that we've been trying to do to build better programming languages is allow the compiler to check more things for you when the code is being compiled when you compile the code not when it runs because you compile the code as part of your development process right you compile the code before you can even run the app you compile the code before you run the program okay so if the compiler catches an error no one is ever going to see it because your program isn't even created a Java is like I'm not even gonna build that program because I know it has a problem right so the more things we can catch when we're compiling our code the better right and he is a place where we would like the compiler to be more helpful right now all the compiler knows is that there are objects in this list doesn't know what kind they are because we didn't tell it what kind of objects we wanted to put in the list so here's how we do that and it's another bit of syntax unfortunately for you guys to learn and start to use it's in this it's this triangle bracket notation so again this is a new thing what this is is this is a generic what's called in Java generic type so instead of a reference to a list my first variable energy list is a reference to a list that is going to be used to store integers that's what I'm telling Java I'm saying I'm gonna use this list to store integers I can also store anything that I can up cast to an integer but I know that anything I put into this has to be an integer or something that descends from energy same thing here now I'm creating something that's gonna hold strings okay I need that type both on the reference variable and when I create these containers so you'll see that I have this triangle bracket notation on the left it says this reference variable refers to a list that stores integers and on the right I tell the ArrayList class this ArrayList is going to be used to store integers and the second time I have an ArrayList it's gonna be used to store strings okay here's what's cool here's what's nice about this okay is that now if we pull stuff out oh it's angry with me maybe this one then maybe it's examples I'm gonna work it I'll fix it after class all right but now if we put things out that are strings they're gonna come back as strings actually let me go back to this example because this one worked right all right so let's say let's make this a list of strings so here's there's two good things that are gonna happen here one is that the compiler can now help write because the compiler knows that this list is only supposed to store strings so when the compiler sees on line eight that I'm trying to add something to it it's not a string the compiler is gonna complain this is a compiler error that's what I wanted I wanted help from the compiler so now if I put in something that's a string like test that's okay and when I get things out from the list they're also strings all right we are gonna use I'm gonna give you guys some practice with this later you guys are actually gonna use these to build some of your own generic classes it's not that hard but I just wanted you to see them for now because this is pretty this is pretty useful right that's useful way when you're working with Java container times okay so I think what I'll do is I think I'll defer the mergesort overview to Monday and instead what I want to do is talk about our final project fair so prou leave it or not this is coming up semester it's really flown by so mp4 is due next weekend the first lab before Thanksgiving and we are gonna sorry the lab and the week before Thanksgiving we're gonna start you up thinking about your final project we wanted to get this started before Thanksgiving so you guys can partner up and you know find someone to work with and start thinking about what to do and maybe if you get bored at home and you know you're tired of watching football or eating turkey or whatever you do you can spend some time actually working out if you want alright so here's the thing we're gonna have a fair this is always fun it's unreadable obably like mid-afternoon kind of right before dinner there's usually some food don't tell anybody you do not have to participate in the final project fair this is important to note okay i can't require it because it's on rainy day what i can do is i can give you one percent extra credit if you come and demo your your app okay and what we usually do is we take over like a big part of Siebel so we'll probably have a bunch of the Siebel classrooms and spaces around the building okay so why do we do this here's why so all of you are gonna get a job if you learn software development if you learn computer science you'll get a job I promise you all right not all of you are gonna get a good job right he used to be like 30 years ago there were no bad jobs in tech everything was cool now like someone has to so there is somebody at Microsoft who has to maintain all this crappy legacy code right and you know it's not a good job in the sense does it pay well does it have good benefits does it you know produce a knife work-life balance yeah it does but is it exciting is it like cutting edge is it changing the world - like maintain Clippy or whatever the equivalent of Clippy is now I don't know like you decide if you don't want a good job here's what to do here's how to get a job but not a great job take your classes you know do the projects get good grades do the MPS whatever you know and then when you're standing in line at the career fair in a couple years you and everybody else the only thing that you'll have to brag about it so you got an A in 225 how many people get a's in - 25 like a lot okay this does not make you stand out and this does not distinguish you or identify you as someone who has a passion for technology because all you've done during your academic career is the things that we made you do you know you did the tube you know we do 225 mp4 because we made you do it you did the third MP checkpoint for 125 because we made you do it that doesn't show that you're excited about the field okay if you want a great job in tech the way to do it is to show your passion for technology the things that we teach you in our courses should just be a springboard for you to then go out and learn more and find out more right and the gold the project fair is to just hopefully light a little bit of a spark under some of you that will get you started doing that so that then when you're in the line to talk to Google you can be like hey I built the bus app that's up on the App Store that's actually used by thousands of people and I have paying customers true story Ben Nordic that bus app started as a 125 final project you can now use it there's like a $5 paid version that has some sort of quest where you can track how many of the different bus stops you visited it sounds pretty cool all right so I have the site up for you guys to look at in terms of what were the projects were from last year you know the bar for the final project is pretty low but I know because I've seen it before that some of you guys will get sucked into this and get excited by it and do some really really incredible things all right so this page is up to inspire you not to intimidate you on you know as long as you try something as long as you work together with your partner and don't turn in something that was clearly generated by watching a tutorial and copying the code from online you are gonna get a good score on the final project the gradient is very generous right again our hope is that this starts something for you where you start to learn how to think independently find your own problems and also work in a team okay I got nothing this weekend I hope you guys have a fantastic one's supposed to warm up a little bit good luck with today's homework it's last one on trees a little bit of a doozy I hope you enjoy it I will see you on Monday  
﻿ [Music] hey back everybody so today's a little bit different we're not gonna ready to code today we're not going to analyze any algorithms we're not going to you know rat try to rep remains mount the mysteries of recursion or learn them some new feature of Java the next two classes are devoted to introducing you to something that I think you need to be reintroduced to it's not something that's new to you but it's something that I think you take for granted because you grew up with it you grew up around it you know the students in this class I'm guessing were probably born around the the turn of the millennium right so you guys actually you know came into being at a time where the thing we're going to talk about was already fairly mature and so this is one of those things where you know my goal today is actually to try to re mystify something for you something that you guys use every day but something that also really shape your future and technology going forward it's something that you need to understand in order to understand how to best leverage the world of technology around this is the internet and the world wide web so that's what we're gonna talk about today we're going into the conversation on Monday this is also designed to set you up to work on your final project because one of the best ways to build something so mp4 wraps up this weekend one of the best ways to build something impressive today while doing this little work as possible and while leveraging the work that other people are doing is to have your app or have your program use data or computation or other features provided by what are called web api's and so we'll get there on Monday we'll talk a little bit about how you can actually make what amounts to a function call across the internet to a remote server to have it do work for you to do something cool retrieve some data that you might not have locally run some processing that you might not have the power to do locally this is the major you know you guys have already done this for mp4 on some level if you're completing this checkpoint or I think actually this was probably the last checkpoint right you guys have attached your app to our back-end and the way that those two pieces of code are communicating is over what's called it Web API we'll talk about that on Monday but today the goal is to give you a little bit of sense of what the Internet actually is okay so before we can talk about the web and before we move off about web api's it really I think helps to sort of back up and think a little bit talk a little bit about what the Internet is because um it's sort of I guess not surprising because it works so well but a lot of people including a lot of computer scientists include a lot of people in this room don't really have much of an idea about how this actually works now you guys are sitting there with your laptops I'm sure you're all looking directly at my beautiful slides but even if you're not even if you're using some other you know tool or some other service you're online right if I turned off the internet in this room I think that the attendants would probably drop quite a bit right obviously the attendants would drop to zero because our attendance tracker would work but I think people would stop coming because you know what can you do so think about it this way what can you do with your computer today without an internet connection when I was growing up we our computers spent a long time when I was in high school it's been a long time without being connected to the Internet we've got little bits of internet time that we would use every week and my mom would very fairly divide them between me and my brother and sister and stuff like that it was like you know you get these discs from AOL that had 30 minutes on them so you would divide that 30 minutes up very carefully um now we expect all of our devices our laptops our phones even these little you know $5 devices we buy from Amazon right to be online all the time right so what created this this revolution so today we're going to talk about the internet a little bit about how the internet works I hope this is fun for you I really like this stuff I think the Internet is probably the most significant piece of technology that humans have ever created you know yeah you can fight me on this if you want fire the wheel stuff like that but I think the Internet is actually more transformative than some of those other things because I think the Internet reflects fundamental human desire to communicate that's why we invented written language we wanted to be able to communicate document things and the Internet is sort of the ultimate flowering of this desire okay and again I really like talking about this stuff so I should taught an entire class you know a few years ago on the internet you can find all these videos online including videos of me like you know going into the wall Jack in my office and ripping that out and figuring out what was going on back there talk a little bit about that today later write me hiding in server rooms and stuff like that anyway it's good stuff so if you want to know more there's a lot of videos of me talking about various pieces of this okay so at the end of the day what is this thing that you guys are using right now you know their computers in this room I wish I had like data on this but are probably communicating with thousands of other computers spread all over the world okay how did we get to this place this is really cool right how did we get there how does it work what's behind it how did it evolve this way and what's so special about it so those are the things we're going to talk about today all right so the first thing that the internet is you know if there's this but how many people have seen the Internet is a series of tubes video that's a meme that I think precedes you guys a little bit I may be 10 years anyway but the Internet is a series of tubes it's a series of wires so what this graph is showing you is overlaid on a map of the United States these are the main Internet backbone links that we've established in this country all right and if you pick up a map of France or if you pick up a map of Australia and it looks kind of similar now if you pick up a map of you know Africa or certain parts of the world this looks different but in first world countries one of the ways that we've enabled the Internet is we've laid cables okay we're going to talk about what those cables are but but here's a map showing and this is act you can actually use this map to figure out like let's say you're on Facebook right now and let's say you're actually talking to a Facebook server that's located in California what path is the information taking from you to California how many people would how many people thought maybe that happened wirelessly like over a satellite or something like that right anybody think I mean it's a reasonable thing to think you guys are using a wireless device right now not the case alright this happens over wire so were let's see we're in here somewhere right this is Chicago you can see there's a lot of internet connections that come together and join up in Chicago and you can see that in a couple other major cities but we're down here somewhere right so your internet traffic it's probably if you're communicating with the server in California might start here and it's gonna run across these really and and these are really high speed sometimes what we call the Internet backbone the companies that operate this infrastructure you have never heard of before Google Google and Facebook have started to own a little pieces of this right but most of the companies that operate this our names that you've never heard of right this is but this is the fastest most high-capacity links that we've created these run for hundreds of miles right and we'll talk a little bit about exactly how data gets from one place to another but this is you know again many of you are probably too young to remember Al Gore talking about the information superhighway this is the information superhighway right it is a real thing okay now anyone can anyone sort of spot something about this map there's something interesting about this map if you look at where the connections are yeah what's that is no one in South Dakota yeah what's going on up here that's interesting yeah there is no can there are no high-speed connections in South Dakota apparently what Isis you know no one has ever noticed that before what is it there's like these dead ends here it's like oh I sent some data into South Dakota it never came out again I feel like it's more likely that South Dakota like didn't share data with this survey or something like that and so there ya know that's interesting no one has ever seen that before but what else does anyone ever drive across country anyone ever driven across some of the big interstate highways so if you overlay the interstate highway map on this map what you'll see is that a lot of these internet backbone links run along major US highways why is that now why why wouldn't I just run these from you know from point A to point B yeah yeah yeah so you actually have to like bury these cables right there's a process involved in laying them and they also have to be maintained okay so putting them alongside the interstate highway system makes a little bit of sense right now there's features of the interstate highway system that we try not to duplicate with this so for example you know how many of you ever wondered about like why when I'm on a highway just there kind of like go like this why don't highways just go straight it's like you know I'm going straight to Chicago why does in 57 just run straight to Chicago like dead straight no turns the reason for that is actually because of you if we do that you guys get so distracted while driving you fall asleep you know whatever right I'm serious so highway designers build in a little bit of undulation in order to keep you alert right that's why we do this there are some sections of highways that are really dead straight and I've read things like you know there are higher accident rates there because people get distracted right all right now okay so here's another question those interstate highways if you there's an older map right so there's another map I can overlay on here that's also gonna line up with that anybody know what that is so this does match up with some of the interstate highways not all of them but some of them the interstate highways themselves were many cases laid out to follow if you've driven 57 up to Chicago what do you notice alongside you for a good part of the route railroad yeah there's a train line there so this is like we're actually fought the Internet it's actually following paths that were laid out hundreds of years ago across the country we made decisions about where to put railroads those decisions guided where the highways we're gonna go those decisions have guided where we're going to put Internet infrastructure it's kind of cool all right this is also the case when you talk about Internet connections that span that span continents okay so again I just want to make this very clear because I think for some of you this may be surprising there are cables this is all done with wires there is a wire so if you want it to actually follow the path of your data from here to Facebook or Twitter or Instagram or whatever server you're communicating with there is a wire in this building right there's one that comes right out of this router over here so we could start with this router if I pull this off the wall which I'm not gonna do because Greg will get mad at me there's a wire behind if I follow that wire your data is travelling along that wire until it meets somewhere in this building there's gonna be a locked cabinet that's gonna have a bunch of pieces of equipment in it that's where that wire leads and then if I follow that there's another wire that leads out of that if I follow that wire there's another live why are the leads out of that you're gonna be on a wire from wherever you are from this router all the way to a server in some big warehouse full of computers somewhere in the world if your traffic spans a continent if you're communicating with a server that's actually located in England or Australia then you get to go underwater alright so then we actually start to go on these undersea cables so you can see here again you know these are very us centric maps I realized so here's a map of the United States and this is a map showing all or at least a lot of the overseas cables that we have pulled to enable Internet communication across these long distances so there is a cable that runs like from somewhere on the East Coast of the United States and a bunch of these cables run across and terminate in a bunch of places on the west coast of Europe right and you know putting these down is pretty much how you would expect there's a boat that sails from one port to another and it's got literally a big reel at the back and as it's sailing across the ocean it's unraveling it's unspooling cable behind it right which then floats down to the ocean floor or however deep it it sinks and lays there for you know tens or hundreds of years some of these oversea cables have been in operation for decades okay see I don't have pictures of this but it's actually really I find this stuff really fascinating i like infrastructure but if you if you want to find the play where these so somewhere somewhere on the eastern seaboard is a place where this cable comes out of the water right it's got to come out somewhere there are typically these very nondescript buildings that they build around these because these are sort of sensitive sites like you if you were a terrorist and you wanted to attack the United States and and knock down our communications infrastructure knocking an oversea cable off line might be something that you would try to do so there's not like a big sign that says oversea cable internet here right instead in some places I've actually built buildings that are designed to look like apartment buildings from the outside except nobody lives there and there's only ever one car in the parking lot and what's inside that building is the place where the cable comes up and then hooks in to other parts of the Internet infrastructure you can I know it's sort of easy to identify these buildings they have all sorts of coolers on the top because there's lots of electronics in there but in some places they've at least try to put them put up a facade to make it look like something that it's not yeah question no idea I think start over right so the question is like how do you repair these things so the the new ones I think are probably much easier to take care of I want to talk about why in a minute there were older versions of these cables where literally you actually had to have vacuum tubes like every mile or so and some of those are still running right so some of this stuff is just really in really good shape there's also a lot of redundancy here so you can see that there's a lot of cables that have been pulled across the North Atlantic for example there's a bunch of cables now that have been pulled across the Pacific Ocean that connect us with Asia and other places right so if one of them goes offline it's not necessarily the end of the world there's enough spare capacity to route around at this point some of those companies that you have heard of like Google and Facebook own cables they've decided to actually start establishing their own infrastructure so they might own an entire cable or they might own part of a cable right that means that all of the data that travels on that cable is from like one Google data center to another cool data center one Facebook data center to another place today some of these big Internet companies have started to move so much data that it's actually made sense for them to start investing directly in the infrastructure that they need to do that all right so what are these cables okay so here's the other really support these are the things that sort of surprised me when I started learning about this stuff right I hope they'll surprise you what well that's cool again it's the one time all right here's a fiber-optic cable right this is you know on some level kind of a mock-up of what these underseas cables look like right so you've got an outer sheath you've got a bunch of these individual cables inside and what material is what are the little threads that are poking out of there anybody know fiber-optic cable made out of I dick glass yeah so the individual fiber is very hard to see it's probably easier to see in front of you that a running these are glass and actually so if you go to there's an in upstate New York I should something it's in western New York there's the Corning company so Corning is an old company and for years and years they made glass for things like plate ware and cups and saucers and stuff like that right so you might think like this is it really a growth industry but if you go to the Corning Factory now they have like this incredible visitor center it's just like dripping with money cornea now is making their money buy because they are one of the only companies in the world that can make glass of high enough quality to use in fiber optic cables and actually there's actually at least a few years ago there was actually a bit of a shortage of fiber optic cable because we were running so much of it to try to build out the internet and make it faster and allow it to carry more data and some of the companies couldn't keep up with it actually there are really really high cost facilities that you need to maintain to make glasses of this quality so just so you understand this isn't the glasses and the doors of fallen tour it's not the glass that's on the screen of your iPhone this is really this has to be very very very high quality very clear very pure I to allow signals to travel in it for long periods so here this is what these cables actually are so and actually the other thing that's cool about the about glass is that you find fiber optic cables way quicker than you would think so in any building so again let's go back to thinking about this router so if I pulled this router off the wall the cable behind it is going to be copper that cable can only run about a hundred meters before it has to have this the signal has to be refreshed it has to be amplified and so usually what we'll find is that somewhere in this building is a switch that takes those copper cables in and what comes out oh come on don't do that thank you what comes out is glass so there are fiber optics in this building all right those fiber optics run probably through some sort of maintenance tunnel to some other building this where they meet up with other fiber optics and then the things so I actually got a chance to tour this at the University I used to work at and you know you guys use a lot of data right I mean that's fun thing about being in college you guys could to browse the web all the time so you would assume that's somewhere right it's sort of like you but problems we think about data like water right we would assume that somewhere on campus there's like a really thick cable that we need to carry all of the data that you guys use right we make sense right everyone here is browsing the web all the time you guys are like streaming movies and doing all this stuff that's like uses crazy amounts of data shouldn't there be some like thick you know cable maybe like even like this right so it turns out that all of the traffic for a university of this size can be carried on just a couple of very very thin pieces of fiber-optic cable that stuff it's so good it's such high capacity that you would be shocked to find that somewhere at the edge of campus is like a pipe that has like I'm gonna wire going into it and that has all the data for the entire campus traveling across right and that goes up to the city of Champaign maybe where it meets up with another cable I suspected our traffic eventually gets up to Chicago and then from there who knows all right so here are the things to take away from this okay we're gonna talk about wireless infrastructure in a minute but most of the infrastructure that we've had to create to support this computer network right this transformative you know way of connecting everybody on earth is wired this is real physical stuff Wireless is mainly used at the very edge of the network so today most of the time the way you guys connect to the internet whether it's through your phone or whether it's through your laptop is through some sort of wireless connection right so I've got routers in here this in case you don't know is a wireless router you can see there's about a dozen that are arrayed throughout fold injure to provide coverage this building they're all over campus right this is Wi-Fi infrastructure right there are like billions of Wi-Fi access points that people have set up various places with your phone you connect to a different type of wireless infrastructure that will talk about the sex but that's mainly the first hop past that point most of the rest of the communications are over wired infrastructure right and so you can think about all of the investments we've had to make and physical infrastructure to support this system right that's what's so cool and then again most of that wired most of those wired connections most of the duration of those are over glass as soon as possible you get to fiber-optic cable it is so much higher bandwidth it requires so much less infrastructure right so those long you know hundred mile cables we were talking about before there's really no way that we could run those using copper it would just require too much infrastructure whereas a fiber-optic cable can carry a signal for miles with very little loss of signal very little degradation so the signals can go a long way before they have to hit some other piece of infrastructure and get refreshed all right so I mean again if you think about things that have enabled the internet other than the work of some extremely clever computer scientists that we're about to talk about glass fiber optic cable I mean if we didn't have that we could not have built the Internet right it would just have been cost way too much okay so any kind if you guys want to see this I did this I thought it was kind of fun there these are links to videos that I did it at UB so essentially we kind of like started at a router or at a jack in the wall and we kind of watched through the process of getting off campus and you could do that here too right if you could find the right person to talk to right there's somebody who could let me into the networking closet here and then there would be a wire that runs out no maybe over to the Union and there's another closet there and then we could follow that all the way off off of campus and then that person would also know like where the data goes after that point all right all right so we talked a little bit about Wi-Fi right and though you know that's something that's you guys are I think are kind of used to seeing around right these ubiquitous Wi-Fi router right this is short distance wireless infrastructure well I think some of you have not learned to identify which is also kind of cool is the connections that your phones are using when they're outdoors so Wi-Fi is mainly used to establish connectivity indoors although if you go to some cities in Europe in some places the United States you can actually find Wi-Fi like in public parks New York City or Chicago right but what are these what says what are these cellular data connections how they were how are those set up right okay so how many people have ever seen something like this notice something like this I've been driving around particularly long highways this is a cell tower okay the these things right here are basically kind of the equivalent of this guy except they're a little bit different they operate in a different frequency range and the protocols they used to connect to clients are a little bit different but these are cellular radios okay they're hooked up to the tower you'll see they're always connected so there's something distinctive about this tower right anyone noticed this this this is not unusual to see but there's something what's distinctive about this geometrically if you've ever seen this this is one of the ways that you can identify these though what's typically true about them this is not always true you go to a city sometimes you find these wireless routers just attached to a side of a building or something like that right some building owners will rent space to a cell company to put up infrastructure on their building to provide service to a particular area but particularly out in space right you know out in the hinterland right where we're located what do you what's true about most of these towers there's something in common about them that should give you a clue about how how the cell system is set up you can notice this see it twice here yeah yeah I've got this equilateral triangle right these towers almost always have this feature so you can see I've got one at the base of the tower that's configured one way and I've got a second one a little higher up the tower that's configured another way and these are actually probably two different cellular providers one of those might be sprint the other one might be AT&amp;T why are they equilateral well I don't have a good picture of this unfortunately but if you it turns out if you want to cover as much space with as few towers as possible the right way to do this is to have every cell look like an equal outer hatch agon and that allows you to basically tile so it's like tessellation right I'm tiling the entire surface of Illinois trying to make sure that at any given point you're within range of one of these towers so that you can get serviced if you do that the places where each hexagon comes together are these equilateral triangles so this tower is serving three cells it has antennas that are pointed this way this is for company a right is that tennis pointed this way that serve one cell there's a tennis pointed this way that sort of another cell and InnoCentive pointed that way that sort of three cells that sort of a third cell so these towers are actually positioned where three different cells come together that's the goal right now what's interesting about this of course is that you know these two companies have not agreed on what the best way is to divide up whatever part of the country this is in because you can see that the two parts of the the two triangles are aligned differently right so that probably means that you know they probably agree to put the tower in this place it's kind of a compromise between the two of them but they've turned they've decided to divide up space a little bit differently all right so and this is actually I mean in previous years I mean you guys are so used to this right but you know that was the second big evolution they and the internet went through and that's I think really what made it so ubiquitous right it's now all this wireless connectivity that we've built out this is also required an enormous amount of infrastructure so both these short-range wireless connections that you use that we refer to typically as Wi-Fi and then medium-range wireless connections that we set up that are set up typically and operated by cellular providers right okay and so what is this all result in all right so here is this is this is a cool animation so this is essentially showing an animation that's estimating Internet activity in different parts of the world by time of day right so if you watch this right so here is probably morning in the United States right now we're into evening things get a little bit more quiet and then here's morning again there were there were periods of time in this country where they were actually these massive email spikes when people got to work like everybody gets to work at nine o'clock the first thing to do is check their email I suspect that's not is true anymore because people are checking email all the time right and so there's probably a little bit more spread out right but what do you notice about this map right if you just look at this I think this this is it this graphic is a couple years old but it's probably not that far off today what do you notice about this but what can you what are some observations about the internet and how the Internet has propagated that you can make from looking at this yeah yeah so so it does favor populous areas right so if I look at this I can see like so for example has anyone ever been to Australia before so like nobody lives in the middle of Australia right it's like a desert there goes on for hundreds of miles right so most of the population of Australia lives on the west coast so this is actually pretty accurate right there's a little chunk of people over here but like there's one or two lights in the middle here but there's there's very little population there so on some level this follows population but there's a huge population center here that is not reflective several of them actually right so you know so again if I look at the United States I can kind of I look at Australia I can kind of see that nobody lives in this great desert here Europe I can see kind of you know it's pretty densely populated throughout but but what else what else is this telling me yeah son it's not just that there's not data I like I like that answer so the answer was there's no data for Africa right that's actually not the case right there's very little internet penetration in Africa it's very little Internet usage so that's a great point look at this this is the most you know this most populous continent and dark so at this point I can't remember what the exact numbers are they change frequently but I think we're only to the point where like 60 or 65 percent of the population of the earth has regular internet access okay now you guys are very privileged to have 24/7 access to the Internet by regular internet access what we mean is like maybe once a day they might be at an internet cafe or something like that right that's what we mean by regular and even based on that definition we're only up to 65 percent what are the one the wiped coast oh yeah I don't know if these are just done to help show like the boundaries of the various contents right yeah I don't think there's any that's a great question I don't know why these are white they're you know what actually I bet I do know why these are white because I think there's people living there right if you were gonna live in Greenland there's plenty of coastline right isn't that where you're gonna live right again I doubt very many people live in the interior of green I suspect this is actually probably following a population so anyway you guys so the exciting thing about this right I think no I think that it's easy today sometimes to feel like you guys are a little late to this party where the party is the internet but you're not because there's still a third of the earth a third of the world's population that we haven't brought online yet and those people are really interesting Internet users those people are people for who access to the Internet is gonna totally change their lives all right you know we've kind of everyone all the brain people we've already hooked up to the Internet all right all the first world people and so my bad it's like whatever okay now I can get better access to Netflix you know but the people out there that don't have regular internet access this is the Internet's going to be something that when they do start to get connected to it is really gonna have the potential to change their lives and you guys will have a chance to be involved in all right so here's the thing right at the end of the day all this work that we've done and actually you know again I was think about this this morning so he's sort of wondering like what drives us as human beings all right what drives us to do things right why do we do like why do we build things like this and yes it's true that the Internet has made a lot of people rich right but do you think about all the work that's been done across the entire globe to create this system I think there's something deeper and more fundamental going on than that I mean if you're sitting here in this room you can browse the website of countries with which we do not have friendly relations chips right but we've still decided hey we should connect our networks together right we should allow our citizens you know in certain cases and there's plenty of Internet censorship out there you know but we should allow them to you know use Facebook exchanged messages with each other right I mean and I think there again there's something very deep and human about this effort right because people human beings want to communicate with each other and this is the kind of a really beautiful example of us working together across countries across nations between friends and enemies and in a variety of different contexts to make something like this happen so right now if you get online you can potentially connect to billions of other machines right through all the shared infrastructure that we've built right well it's the time your first connection is wireless but at that point there's a wire that you can literally follow to the other person's computer alright so so now we have this substrate right we built these wires we have a way to send electric signals electronic signals from point A to point B but we haven't actually answered the question of how we're going to use this capability to enable devices to communicate with each other so this is the second level so the at some level the internet represents physical infrastructure huge investment in physical infrastructure but the other thing we also have to do and again this is something that somehow we all got together and agreed on is we have to agree about how we're going to use this thing to actually enable communication okay and to do this requires a new concept that is really a computer science concept it's not something that we've talked about yet but it's something that the computer science community had you know contributed to the system I mean if you think about it up till now right what we've talked about is really like ECE right they built all that hardware and all that stuff and all the wires and ee did a lot of that right you should thank them for that right that's an incredible contribution right at this point now we need to start writing software okay so a communication protocol so protocols energy same word I mean protocol has its roots in you know diplomatic relationships right the protocol for receiving a head of state all right if someone comes to visit the White House there's a set of rules that you follow about how they're received and what sort of you know banquet you're gonna hold and how you address them and who walks to the door first and second it's not like that else has been negotiated right a communication protocol is not that similar not that dissimilar it's a set of rules that we establish so that two devices can communicate with each other so now we have this way that we can send signals back and forth and we can actually use those signals to represent you know bits and use those bits to represent text or images or whatever but how do we all work together so that this just doesn't become cacophonous right how do we work together so that we can actually make sense of what to do with this thing all right so um so IP you know how many people have heard the acronym IP before like your computer requests like an IP address ID so IP is the second place where we see this word Internet all right IP stands for Internet Protocol this is the base protocol that all Internet connected devices are as as you know expected to adhere to okay and it's designed to address a couple of fundamental questions about how we use this this network okay so here are the couple things that an IP one of the best things about IP is that it doesn't do very much okay and we'll talk a little bit more about design principles on Monday for the internet and why it's been so successful one of the best things about IP is that it's small it's a very minimal set of expectations and requirements so here are the things that IP sets up the first thing that I the first problem with using this big network that we need to address is how do we address each other what do we call each other if I want to communicate with one of Facebook's servers that has my news feed on it or whatever how do I send it a message that message needs to have a destination and it needs to have a source so that the server can send a data back to me so what do we call each other okay so IP specifies the format of what it referred to as IP addresses right and here's an IP address this is in what's called dotted decimal form right this is the first iteration of IP and probably the only mistake that the creators of IP made was not anticipating how big the internet was going to get so we'll talk in a minute about why this is the case right so these are old format IP addresses okay how many people have ever seen something that looks like this before couldn't you sign up a router or whatever you've been connected okay how many people have seen one that looks like this before all right so this is the future and by future I mean this is the sixth version of the IP protocol to be been rolling out now for like two decades okay here's the problem we ran out so when IP got started it was using these ipv4 address this there are four billion of those for reasons that are more complicated than I want to go tune to at some point it became very clear that we were going to run out we do not have enough now you know again there's more than four billion people on earth and if every one of them had two devices which is you know probably more than they're going to have right we'd have 8 billion devices that would need to connect so it's not clear that 4 billion was ever enough but there are other structural reasons why it's difficult to make use of all those addresses that again I'm not going to get into okay and so slowly but surely the Internet has been transitioning to use this different address format and these new addresses are much longer this is sort of like the difference between an int and a long and Java and then can store 4 billion values a long can store like a lot right ipv6 I think if I remember quickly you could give a separate ipv6 address to every atom in the universe so that's probably enough right although I don't know if every atom then decides that it wants both the laptop and a phone then we're in trouble all right so the other thing that IP lays out is how are the messages that we send across the stuff we're going to be structured ok so this is you know this is sort of this is sort of a format that's not that dissimilar from designing an object in Java right we need to decide you know when I send you a message what's gonna be in that message and how do i decoding if I was just sending you random stuff then you wouldn't have enough information to figure out what to do with the message you'd be like okay I got some data but I don't know how to decode it right what do I do with this information all right so here is the format and then this is not going to be on a test but I just thought you guys might be interested to see it this is the format of every single message that is transmitted across the internet this is what's called an IP Datagram so a lot of this stuff we don't really need to worry about right so this is information this is called the header of the message this is the first part these two pieces though are pretty important right so one of the things that every message contains as it travels across the Internet is where it came from that's the source IP address so that's how the computer that sent the message identifies itself the other thing that it contains and this is critical is where it's going where is this message trying to go that's the destination IP address and then pass that there's some other information and eventually what we get down here is just information data and one of the things that IP did and you guys will learn more about this when you go on and take other courses but this is a really really powerful and beautiful idea is that IP didn't create any rules about what you can put in an IP message the header err you have to get right that's the part that where you agree on is all the stuff that's in here the data you can send whatever you want doesn't matter now you and the person you're talking to have to agree about how to interpret that data but IP doesn't care IP has no objections to moving in whatever you want in there as long as you set up the header problem I don't want to talk about this topic without giving credit to some of the people who were involved and I'm but I want to do this in an important way right so if you look at the people on this slide these are what kind of old white guys all right and they're old now when they were working on this so let's go back in time 50 years right actually about 50 years ago one of the first internet machines was actually arriving on this campus internet Illinois actually hosted one of the first nodes in what became the Internet but this was like this was at the point where there were six computers hooked up to the Internet and nobody had any idea how to use them what happened was there was there was a bunch of graduate students they got ahold of these right because these are the people that like are excited to work with this new stuff and they want to figure out how it how it goes and the professors were all like I'm too busy I've got a paper to write or whatever the graduates into like somebody sent us this big piece of equipment in the mail and let's play with it and see if we can get it to do cool stuff so that's what they started to do as they were doing this so so there so essentially there were all these graduate students around the country at different institutions that were unboxing these big you know these things were like the size of a closet right they barely did anything right but their boxes I'm hooking them up to the phone lines figuring out how to get them to connect to each other and stuff like that the whole time and you can I mean you can read interviews with these guys I mean Vint Cerf is still alive Bob Kahn has died unfortunately Vint Cerf now works at Google sort of internet evangelist and has continued to speak out about the future of the Internet but but what they kept saying is that they kept wondering like when are the people who are in charge going to show up this is sort of I feel like the story of Technology and are in our era right it's a bunch of like people that were kind of making it up as they went along and they kept wait like they literally kept waiting it could be like well at some point someone from the government is going to show up with a suit and be like okay guys we got this right we have a plan that we've made before but it turned out that no one had a plan and so these protocols were invented by some of these graduate students like when they were in graduate school because they found a cool problem to work on they also worked together and I think this extremely laudatory way so the if you look at how the Internet has actually been standardized so there's a bunch of documents that lay out how each part of the internet works and these go all the way back to laying out IP and a bunch of the other protocols that I operate on top of the internet that we'll talk about next time does anyone knows about these are called they all have their it have a number so there's like thousands of them now but there's an acronym for it you go up and look like you know and there's a whole website where they have every single one going back to the dawn of the Internet does anyone know what they're called they're called RFC's maybe that rings the bell first men descending we know what our C stands for our C stands for a request for comment so the graduate students who were in charge of this were worried about offending the people who were in charge and so they didn't want to make their documents seem like they were they were like the instructions right they didn't want to make people think oh these graduate students started to take over right so whenever they agreed on something they wrote up its a request for comment and then they would send it out and then you know later if the people with the suits came back they'd be like oh no we were just you know we were just asking for help it's just a request for comment right we didn't comment so we just decided to go ahead and do that thing so again I mean and this is a this is a process that the system that persists to this day there's still committees that are involved with you know continuing to guide and shape the future of the internet and they still use the RFC system to propose new ideas and get feedback all right so I think we're going to stop here we'll talk about routing next time that's all I have for today because I have a fantastic weekend it's beautiful outside I have office hours today 1 2 3 I hope to see some of you there if you are working on it before good luck finish it up this weekend this is our last machine project deadline we will start on the final project next week have a great weekend I will see you on Monday  
﻿ hello can you hear me now oh that sounds better alright so on Friday Jeff foreshadowed these things called functions and functions are a way to structure your code break it up into pieces that you can reuse and you can test and we're very excited this is gonna be great but before we get into this I'd like to take a moment talk about how we're going in the class this is at this point in the semester it's the third week of class and we're getting into something of a rhythm all right can everyone hear me now hello all right can you hear me now how about now all right that's no problem we will survive so as I was saying this is the third wave class we're getting into something of a rhythm this class is intense you've probably starting to discover this but we try to maintain a consistent level of difficulty so the reason we've been doing weekend homework problems is to prepare you for working on our machine project the MP we are going to lay off the weekend homework problems pretty much from now on because again we want you to work on the MP instead so the MPs are obviously there they're longer than the homework problems you have longer to do them which means that the scheduling of them is more up to you we highly recommend that you get started early we they are designed to be doable in slow and steady progression they are not designed to be done in the frantic rush the night before if you try that not gonna work out so hot so let's go over how we're settling in here so on Sunday MA and Monday depending on your deadline group you're going to either be finishing up the first half of each checkpoint that is for the early deadline points we're going to be finishing up the checkpoint as a whole and starting the next checkpoint that we released if we're on a checkpoint boundary on Monday the MP continues of course our quizzes in the CB TF run from Monday through Wednesday and we have class right here as we're doing now we have our weekly homework daily on week's homework problems and our office hours run from noon to 8:00 Tuesday you'll continue working on the NP you'll this is a very repeating theme the quiz continues in the C btf and you all have your labs on Tuesday and of course another homework problem Wednesday fairly similar to Monday the quiz is still proceeding we've got class we've got homework we've got more office hours Thursday is a really great day to make a lot of progress on the NP because there's no CBT F quiz going on and we have lots and lots of office hours on Friday again we're here and there's office hours happening and the weekend we lay off the homework problems and you have plenty of time to work on the empty office hours run noon to 8:00 Saturdays and Sundays so so far in this class we've learned some really important fundamentals we were able to do basic math using the arithmetic operators we can make simple decisions using if statements we can do a lot of things over and over again even a variable number of times using loops we can store data in variables and arrays and computers are also very good at communicating obviously this is a very important part of the world people are constantly sharing information over the web and we're gonna get to how that happens it's gonna be very exciting so now that we have these fundamentals what are we going to be doing we're going to be thinking about how to use these we're gonna put these building blocks together to make algorithms to solve our real-world problems or data processing tasks and we're going to consider how to lay out data so that we can process it effectively of course people there's this big rage on about now about data science but data structures have always been a really really important part of computer science there's different trade-offs between different ways of structuring the data and how you can access that and we're going to learn how to do this in a way that is reasonable then a way that is maintainable and we're gonna learn the craft because say I might know how to use all the kitchen accoutrements that doesn't necessarily make me a chef and people can attest I can't cook very well so the craft is another layer on top of the tools and along the way outside of the the really critical parts about Java and programming general we're gonna take just a couple fun detours into things like compilation just really exciting bits about how this all works very fun now how do we lay out our programs in a good way that allows us to maintain them and reason about them well we want to organize it imagine if you were reading a syllabus for this class and imagine that there were no section breaks it was all just a giant wall of text that that would be a mess you had it would be navigable so we organized it we have links between things so that we don't have to repeat ourselves constantly and functions which we're talking about today are going to allow us to do that because if your entire program is just one long sequence of instructions if something is going wrong it's very hard to investigate the problem could be anywhere but if we break it apart into more or less independent chunks then you can test in isolation and once you've identified that the problem is in one chunk you can fix that chunk we're going to combine state and behavior this is foreshadowing of something called objects which i think is going to be either later this week or next and this allows us to put the behavior that is the code the processing organize it next to the things that it operates on so that you don't have to trawl through the entire code base to find what is this related to why is we're going to learn how to write good documentation so that we can understand our code later so that other people may be our partners in a new startup we'll be able to understand what we've done and so that of course once we've come back after a long break we still know what's going on computer scientists are you might go so far as a fundamentally lazy we want to not do another thing if it's already been done because if we have a solution fantastic you use that and structuring programs well allows us to do that and once we've organized everything well documented it wonderfully other people can use our code and that will help them avoid code duplication it will help them build fantastic stuff on top of our foundations you're communicating and contributing to software development as a whole so here's Wikipedia's definition of a function a sequence of program instructions that is a bunch of code just code like we've been writing so far that perform specific tasks that is they accomplish one thing maybe it's their job to find the maximums Andre like we did on this weekend's homework problem and we'll review later today this unit can be used in programs whenever that particular task should be performed that is once you have a function that accomplishes some tasks you don't need to copy paste that code all over the place all you need do is invoke the function and it will do the job so different programming languages have somewhat different conceptions about functions these are more or less shared but we'll we're gonna talk about Java specifically so it gets a handful of inputs or none in some cases and it either returns nothing it just does something and doesn't have an answer or it produces an output one response for example in the homework problems it's very common that you need to find something given some input like the sum of an array the input would be the array and the output would be the sum and there's nothing super magical about code inside the function it's just imperative code like we've been writing and it's packaged up in a nice way so that we can use it elsewhere now you can like I just said put all sorts of code inside a function what should you put inside a function how should you plan this out in general a function should have one responsibility perform one atomic that is specific task like it would be somewhat bizarre if our array sum function was also responsible for emailing something to someone we would know on that in the same function because it's one job is to summon array that's what it's for we want to be easily tested so that if something is going wrong in our program we can say well let's see if the fuck the problem is here we exhaustively test that function we say oh okay that function is behaving properly so we can move on to the next part of our code so we don't have to test the entire program all at once and you'll see some of this in the NP and it can be reused in multiple places so that rather than copy pasting code all around the place because what if we made a mistake in our original implementation and then that got copied everywhere that be a mess to clean up so instead we package into a function where if we have a mistake we change it once and then all users of the function will get the updated behavior once we fixed it now how do we actually write one of these things that I've been spilling on about for 12 minutes this is a function declaration in Java first the thing you'll notice is that it has a name just like variables have names functions have names too so you can refer to them the inputs for a function what it receives are called arguments often they'll be referred to as parameters and that is the part inside the parentheses these look very much like variable declarations they have a type int for this first number so what this first part here is saying is that one of the first parameter to our add function is an int which inside the function will be referred to as first number and then we also have another parameter it's also an int and it's called second number and then much like loops or if statements functions have a body that is delimited by curly braces everything inside the function is run when the function is called above all this code you will see some fairly human readable text all this big comment and this is referred to as a javadoc comment Java documentation its purpose is to explain what the function is for so that humans can understand why it's here why we might use it and how to use it so the first part is a general summary so the job of this function is to add two numbers together and then the other parts say what is expected to be passed to the function these parameter and that is the first number to add and then the per am second number that's the other input that's the second number to add and then what does it return the sum of those two numbers you're going to see a lot of these comments in the MP code to describe what the function is supposed to do now strictly speaking since their comments they are not necessary for the compiler however once you start writing your own functions in a later MP checkpoint textile will require that you add appropriate Javadoc Manor studio can help with this that can help you format it we think it's really important to write Java doc so that again other people and you later can understand what the function is for and how to use it Java cares quite a bit about the arguments and return type so when we try to use a function Java is going to check for us that the things are passing to it are actually of the type of function expects and again the Java doc helps both you and it helps other people who are using your function because if we just there's only so much information you can pack into the function name and if you want to explain it more Java doc so now we've written this fantastic function it does something super amazing and now we want to actually run it from somewhere else in our code because just the act of declaring a function doesn't doesn't run it it's just there now so to call it you we will use some syntax involving parentheses that we will show very shortly once you call a function you execution transfers immediately to that function we're gonna see examples of this real quick the code that is the calling excuse me the code that calls the function caller makes sense and so once we've started the execution of a function that called function is going to run to completion and only once it completes will the function that called it continue executing and again we'll see the control flow very soon if the function returns something not all functions do but if the function returns something then it can be used like any other expression so here is an example of calling our add function from lines one to ten is the add functions declaration and from lines 11 to 15 is some loose code that takes advantage of it now need to shatter a bit of an illusion here from until now we've been using just instructions just Java statements in our slide examples and in the homeworks but Java actually does not allow just loose code outside of functions if you try that in an independent Java file outside of our system it will not work Java requires that all executable code is packaged into a function mostly so we've been doing a little bit of magic behind the scenes to make it so that it'll be put into a function so that we can test it but anyway we have this function and we're going to use it to add the numbers three and four you may notice that this syntax looks somewhat familiar considering line 14 because system dot out dot print line which we've been using all this time is a function print line is a function and calling it involves these parentheses so we name the function that we want to call we give the value of the first parameter and so on through all the rest of the parameters the parameter values have to be separated by commas and checks I'll want to space after them so this line 11 declares result Java to fill that out has to evaluate the expression on the right-hand side which is a function call to add and once we've done that result now has likewise you don't have to store it into an intermediate you can just use it as any other expression you could say add 4 and 5 and pass that straight through to system dot out print line so line 12 is going to evaluate ad first execution will transfer to line 9 where it will add 4 and 5 when it hits the return statement it will proceed back to the caller and now system that with ritalin has that value it can work with and send out to be the console you can have multiple function calls in one expression just like this line on line 13 Java will evaluate one at a time first it'll add 10 20 then 20 or 30 and then once you put all that together you store it in the bigger result and if even if a function returns a value you are not required to do anything with that value so line 15 is perfectly fine it will call the add function add will dutifully add those two numbers except the result gets thrown away by the caller sometimes it is reasonable to throw away the result maybe you were using the function for a side-effect that is something other than just the return value so let's actually run some code now first up you'll notice this weird static word here this is an artifact of our slide system just ignore it for now do not include static in the Prarie learning problems if you do I think things will break but for now just alright we'll talk about it later we will later in the class so we run the code we get nine where is that coming from probably this line right here and where's the ninety coming from we add all this together and we print it now let's maybe get a sense of the control flow by adding some extra print statements and whenever you're debugging something like your MP it's really helpful to just add print statements to say where we are now and get a sense of how Java is running your code so let's gonna have to type one-handed here this is at the start before we've called any of our add function now let's add code to the ad so we'll be able to see when it's run I think since I'm typing one had to be best for me to copy this they might as well print the parameter values as well so we can see which colouring and let's make a note of when we get back from ad and let's see what happens to you obviously I haven't instrumented the entire thing but I think we'll get a pretty good sense here so just declaring a function does not run it so we're not going to start inside the add function instead execution will begin on line 6 that's the the beginning of our imperative code here and to get this result we're going to need to invoke the add function so Java transfers control into the body of the add function where we note that we are adding 3 &amp; 4 and once we hit this return statement we return to where we came from before the function was called and we hit line 8 which notes that we are now done adding 3 &amp; 4 in the process of executing line 9 which is a print statement of an add function call we first have to evaluate that because we don't know what to print we don't know what to call print 'ln with until we've evaluated the inside of this call so we add 4 &amp; 5 and then once that is done this is ready to go and we pass the resulting 9 to print 'ln when you have multiple function calls Java has to do them one at a time so we scroll down here and we see that first Java added 10 and 20 and then 20 and 30 and then once we got all that we got 90 in line 12 just to prove that Java does actually run the function even if you ignore its return value we see adding 6 &amp; 7 at the bottom even though we threw away their results 13 so much like variables functions have names and these names are going to be used whenever we call them so how do we name a function well we want to be scripted we want the name to mean something in quizzes there might be functional names like a because we want you to figure out what the function does and describe it to us but when you're writing code the function name should mean something so you can remember and it should describe that specific function sometimes maybe you have a plan for a function what you think it's gonna do and as the code develops ends up doing something else and then the name doesn't really describe it and that will lead to confusion so make sure that the functions name actually describes that one function otherwise when you call it you get behavior than you other than what you expected and it's baffling and that's a problem and since you're going to be using these function names in various places throughout your code probably best to not go wild with the length like 50 characters probably pushing it but be descriptive it describe what's going on we do have a lot of horizontal space on screens nowadays so if you have to do a trade off between descriptiveness and succinctness probably best to describe what it does so you and other people can know when we declared a function we gave the names of the parameters inside those parentheses and like I said those looked very much like a variable declaration and in fact they kind of are because once you've done that once your function is declared to have parameters with certain names inside the function you have variables with those names so you do not need to declare them again inside the function their value is going to be up to the caller so in this example on line 14 the caller decides that it wants to supply 3 as the value of the first number parameter so on different calls of the function the parameter values will probably be different and again this does pretty much what we expect 3 is the result of first number is excuse me the value of first number if we change this maybe add 9 and 3 23 one hand to typing [Music] sure enough the value of first number is nine other 323 as expected oh and the order of these parameters matters the order that you pass them when you're calling the function has to match the order in which they are declared in this case ad is commutative the addition operation is commutative so that doesn't matter too much but in other functions yes you definitely need to make sure that the first value is what you want to pass as the first parameter oh and by the way even in this in this case all the parameters to add are intz they do not have to match the return type you could have a function that takes an INT returns a string you could take a string return a double these are all independent it just happens in this example that they're all in now in that example you saw a return statement and you if you're looking at the MPL ready you'll have seen a couple but if not that's perfectly fine the return statement says we are done executing this run of the function please go back to the caller I've I've done my work and they can appear anywhere as soon they don't have to be unconditional so you could have an if state excluding an if statement that contains a return statement if you only want to bail out of the function under some condition you can have multiple return statements maybe you want to under some circumstances return one thing but if execution falls through and that is never reached you have a different return statement that may be returned some other value and again return immediately bails out of the current function it execution will not proceed past a return statement as long as it's actually executed I mean if it's not executed because say it was in an if statement whose condition was false then it won't be run you won't bail out but if their execution reaches the return you're done it's over for that function if the function is declared to return a value then you have to have a return statement because you have to give some answer to the caller who is expecting you to produce something and it has to match your declared return type so in the ad example it's declared to return an int if we had written a statement that returned a string that is some text that would not work Java would complain vigorously and would not even compile the code if the function doesn't return anything and I'll show you in just a second how to declare a function that doesn't give an answer then you don't have to have a return statement you can if you want to bail out early but it's not necessary once control reaches the end of the function job will automatically return if you don't have to return a value before we get into that you may be wondering why why do we have to do this Java doc why not just normal comments or why not my custom format that that looks nicer to me that is because we can use Javadoc it's a convention that there are tools for to produce quote unquote pretty web pages like this now you may be thinking the web designs a little dated probably but you can have all of this one entry for each function and if you say jump to one of them your per am tagging turned into things like this your descriptions have been turned into nice text here the return tag has been turned into that and this is really nicely browsable so that people can look at a web page rather than having to go through your code in fact on the MP you will be looking at especially in future checkpoints are Javadoc that we generated from the solution code to tell you what functions you need to have questions on this before we proceed anywhere we good alright so now that we have the ability to package up code into a function we can use this to do I'm an algorithm because often an algorithm is in charge of one specific task like summing an array or solving some data processing tasks like on your MP algorithms have inputs data they need to work with and a result they need to produce and that is exactly suited to the function model of taking some parameters returning a result and again we build algorithms out of the fundamentals that we've been learning up to this point we use arithmetic operations we store results in variables variables can be changed in the middle of an algorithm you can use that for accumulation I like in the array some problem you can do different things under different circumstances with conditional statements and when there's a lot of data you need to process or a variable number of things you need to look at that's what loops are for so let's do some examples let's say we have an array of characters and we want to find every case where we have one letter and then the letter after it is the same so how might we approach this what what are we going to need ideas yes yep so what he said was go through every element of the array one by one if for example position the value of position two is the same as the value of position three we found a match so we should note that down and update a variable yes that is great so we need to go over the entire array and we need to compare it with the adjacent value how are we gonna do that what feature of Java allows us to do this yes yep we can use a for or while loop exactly and then once they're the same we can on either store that in a variable or print it out so let's try to do this so we have an array called characters and we're gonna write a function to do this task for us let's say we want to return the number of times that there was an identical character next to itself so our function should return what kind of thing yes yes an int so int the return type of the function goes first we're going to need a descriptive name for this function let's call it consecutive identicals a little long for typing with one hand so we'll call it same and what is the input to our function what kind of thing ideas yes yep a character array an array of cares and we need a name for this yes we can call it Karis sounds good we open the block of our function with a curly brace we will also need a closing brace and like we said before we're going to need to loop over this can we use an enhanced for-loop for this or are we going to have to go with the index based for loop yes yep index based because we need to know the index so that we can look at the next or the previous so let's set up our normal for loop our I will be an index variable I is less than cares dot length and increment i before we go around again so we now need to get at the current character which is going to be cares indexed by eye we're going to do an if because we want to check if something is the same so our current character is at index i we compare things using equals and how do we get at the next one the one after the one we're looking at i plus one yep I wonder if this will work oh and of course we're going to need a variable to accumulate this will declare this outside the loop because if we declare it inside the loop it would be reset on every run around the loop so we put it outside so if the current character is equal to the next character then we found a same and we'll increment that and once we are done with the loop we can tell our caller hey I found your answer here it is is this gonna work oh it will definitely not work if I do not call it because just declaring a function does not invoke it so we'll need to name the function that we want to call and pass it our character array which is called characters oh and by the way the name of parameters to the function is not accessible outside the function cares is whatever consecutive same receives but we're gonna pass characters as the Charis parameter so we run is this gonna work oops I forgot the static is it gonna work now oh no array index out of bounds how did that happen yes yes I'm the very last run when you tried to do I plus one it's off the end of the array how can we fix this yes yeah we can do not carousel length minus one so that we stop on the penultimate entry and then check the last entry in there will this work it helps if I actually print the result all right we got our answer of - does that look reasonable to us we have a B and then another B and I see another C I think we have done it nice all right so now let's say we want to write an algorithm to take the average of an array and as a hint one of the problems we've already done is very very similar to this what might that be yes yes finding the sum of an array because if we want to average a bunch of things you need to add them up and then divide by the number of elements so let's try writing a function to do this again we're going to need the static just for the slide sandbox to work and this should probably return a double because we're going to be averaging double precision values I think we can name an average and it's going to need to take an array of doubles might as well call it numbers we're going to need to accumulate the sum so far variable for that what's a reasonable starting sum value yep zero can we use an enhanced for-loop here or do we have to go with the indexed yeah I hear so serations of enhanced yeah because for this purpose we just need the values we don't need the index so for that we do for every double we'll call it number in the numbers array we accumulate its value and then what should we return now that we've calculated the sum oh is that an answer over there yes yep we need to divide our sum by however many numbers we have which is the length of the numbers array and let's call this function and we already have this to average array declared for us so we'll use that run and yet we get the average of about six point three seven which looks pretty reasonable to me nice so now let's do a review of one of the weekend homework problems finding the maximum of an array so how might we go about that if you were a human and you had a imagine that you were human and you had a whole pile of numbers basically unknown length collection of them and you wanted to find what the biggest one of them is until you reach the end how would we go about this as a hint we're probably going to need to check everything because the maximum value could be anywhere and we're going to need to keep track of the biggest thing we've seen so far because maybe there's a ten somewhere early in the array but maybe later we encounter a twenty and now that should be our biggest number maybe there are smaller numbers later and we don't want to set those as the maximum because we saw something bigger before so we'll start by declaring our function with static gonna need a semicolon on this and since this is an inter a all the data are intz I think maximum would be a reasonable name for this function its input is going to be an integer array we'll call it numbers again so as we're going along what state are we going to need to be keeping track of do we need any variables outside our loop to remember anything what do we think about that anyone in the at the the top I haven't been looking too much the top sorry yes oh you're stretching your stretching he's stretching well I think we are going to need one variable because we have to recall what the biggest we've seen so far is so if we were a human going along here we would start with the floor we see oh okay four is the biggest thing I've seen so far and then we look at the next element oh five that's that beats my previous best of four so I'll hold on to that then we see a one mmm that's smaller I'll I'll keep the the five and again with the negative eight oh nine that's great I'll hold on to that and then again with the ten and by the time we're done our maximum we've seen so far is 10 we've exhausted the array we've seen it all and we can return the biggest one good needs some accumulator call it biggest now what would happen if I initialize this to zero would that be a problem yes because of possible negative values so instead let's initialize it to some value that's definitely in the array ah maybe the first element numbers slice zero is the going to be the first datum in the array and now we're going to go over every value in it we could use the enhanced for-loop here let's go ahead and do that for every number in the numbers array what are we gonna do we need to see if it's bigger than our current best to do that we will have a conditional because again if if it's smaller than what we've seen already then we we don't want to store it we are not interested so only if the number is bigger than our current best we're gonna be changing this biggest value to store and recall what we've done so far then now our best is this current number oops helps if I type properly close the for loop and once we're done with the loop we've checked every number we've stored the biggest in this variable called biggest and we can save our caller I did it here's your answer and we're going to need to call this function actually I think I have it on my clipboard sure do let's see how this works oops helps if Oh scoping issues biggest is not accessible outside the function so we need to actually call it passing our values all right try this again and the maximum is 10 does it work if the maximum is somewhere in the middle of the array it does does it work if the biggest number is at the start of the array those are edge cases that sometimes can cause trouble it sure does what might be a problem with this what input to our maximum function could cause it to fail yes yes an empty array so if I instead of passing values pass an empty array that is an integer array with zero elements boom zero is out of bounds for an array with no elements so it's unclear what to do in this case but if you want to avoid a crash just for purposes of exercising the ability to return early let's say we want to return maybe negative a thousand is the smallest value you'll you'll ever see they probably have some other sentinel but for purposes of demonstration if numbers dot length is zero then we return negative a thousand there's also a Java constant called intamin that might be relevant so now we try this and we get negative a thousand because there's nothing in the array if we change this back to values we see that our return statement here is not hid because numbers dot length was not zero so execution proceeded and it used our loop that we wrote before and if we wanted to do this as not a function all we would like on the homework we would just take out all of this stuff and this would become just biggest and I know my spacing is bad oh right yeah not called number it's called values and sure enough it still works this would solve the weekend homework problem if the spacing was correct we just did that I will take any questions in the lobby after lecture unfortunately I can't take them on the stage because I need to get out of the way for the next lecturer but I'll be very happy to meet you in the lobby and you will see Jeff back again on Wednesday hopefully there's another homework problem out today quiz 2 will have some multiple-choice questions on functions you won't be writing functions on the quiz but you'll answer just a couple questions about them the MP is out please get started come to office hours if you need to help and especially come to office hours if you need help setting up Android studio and there's early deadline points for making some progress by this weekend that's all folks I have a great day and I might see you in the lobby  
﻿ welcome back everyone I hope you had a fantastic weekend today okay so it's hard to believe it's a fourth week of class week three for us of course because you start counting at zero but today is our the beginning of our last week of the first third of the class or the first half of the class I like to called so next week believe it or not you guys have your first midterm exam and the CBT yeah it's a reminder this is just like another quiz it's more comprehensive but the format is similar to what you guys have seen already but anything we've covered up to that point is fair game next week on Monday I'm going to start talking about a new topic which is object-oriented programming but we have a little bit left to do this we can actually Wednesdays lectures a lot of fun we're gonna talk a little bit about how sort of Java works behind the scenes and clear up some things that may have been confusing you but today I want to introduce one more piece of the puzzle when it comes to how to represent data in Java so we've talked about working with single types single values we've looked at being able to work with series of values and now we're going to start expanding the dimensionality so that we can work with 2d 3d 4d higher dimensional data in Java we're gonna look at how to work with multi-dimensional arrays that's really kind of the last topic in this part of the course the rest of the week homework quiz you know mp0 the first part of the NP that's due next week it's really practice write more practice with imperative program okay so just as a reminder on the early deadline was your deadline day this weekend so that was either yesterday or today good luck getting your 40 points and p0 is due this coming weekend on your deadline day so either Saturday either Sunday or Monday does anyone have any questions about this policy you know I wouldn't so let me just be honest with you so when I talked about this last fall on last spring we started talking about this moto among the course staff a lot of them were like no you know you don't want her to deadlines like students aren't gonna like that you know whatever and so far you guys it's like I've stunned you into submission or something like that I mean who wants to complain about this somebody wants to there we go okay yeah so the question is I miss the early deadline by five minutes because and let me summarize what you just told me respectfully I didn't follow instructions right I did not follow instructions be how we have laid out in fact it says very clearly do not download the zip file and use this as the starting point so let this be a lesson those ten points if you've lost them for some dumb reason make sure that that doesn't happen again the nice thing is this semester so in the past it's like every NP was different and people kind of make the same mistakes every time this semester once you've got everything set up and you can push properly and you can run a local auto grader and you're confident in that that should just keep working right so you shouldn't run into the same problem again but if you lost the ten points this time is it gonna make a difference in your grade no it's highly unlikely but but it'd be a lesson in following instructions starting over then getting help when you need it other questions yeah yeah read the form that I said read the forum that's been discussed on the forum yeah autograder is not working yet we are still working on it we'll get there it'll be up soon I wanted to work properly before we actually so we're testing it we did a lot of work on that over the weekend so that's coming along okay here's what I'm gonna do though right because I think there's some legitimate concerns about this multiple deadlines approach so here's here's what I promise to do at the end of the semester I will compare the performance of the orange team and the blue team on EMP and if there's a significant difference I will adjust for that when I do the final grades does that sound reasonable okay by significant I mean like more than a couple percentage points percentage point or two here it's just within the noise floor but if there's a big difference I don't expect there to be a big difference but if there is I will adjust for that in either direction you know you might be surprised okay great so next week's the midterm this covers everything up to this point we will review together on Friday there may be a special guest here on Friday stay tuned to help us review if you are trying to figure out how to prepare for the midterm MPs working on fp0 is a great way to do it doing homework is a great way to do it doing the quiz is a great way to do it today after class I will take all of the programming problems from the first really from the firt last two quizzes the first quiz wasn't very interesting I will take all those programming problems and put them on to the homework 125 problem set so they're there for you to practice we have a couple of people that were still making up some of the early quizzes but that's over so those will be up there okay and then we're gonna we will continue homework next week during the midterm I just want to point that out this would be very easy getting started stuff with objects but it's important for us not to lose that time so just plan on that these will not be hard homework problems the poem problems this week last few days a little tougher but once we start talking about objects for the first week these will be pretty basic yeah question No it's all in the book [Applause] I mean the questions from the book would have been easier than what's on there now right so I don't know pick your poison okay any other questions before we get started today yeah well there be questions on the about the book on this week's kids yes there will ya the chapter is signed yeah no we'll get there we'll get it graded once you pushed you're good now run the auto grader on your own machine before you push that's the only way to make sure that you didn't do the math wrong or you didn't miss something or things aren't working quite as you expected right but unless you've done something it must be done something bad you know unless you now this happens sometimes you know people modify the test Suites while they're working to try to help them and then they forget it's like oh I got all the points no when we test we use our test Suites which are the same as the ones that we gave you but if you made modifications to them that can compute that's something to check yeah no not right now yeah how many MP checkpoints are there I think five like five actually sorry I think six because I think the five is the last one we're starting at zero there's six MP checkpoints they're obviously not all going to be two weeks long we don't have time for that some of them will be shorter but yeah six MP chuckles okay so let's expand the dimensionality of the data we can work with so we work with series of data that was itself very useful and there's a lot of information in the world a lot of data in the world that we can represent as a series of values but once we started adding dimensions now we're in really good shape until we talk about objects as good as we can do okay so in Java I can declare and use a race that have not just one but multiple dimensions so online - I'm declaring an array called samples with the single dimension I have a single pair of square brackets over here on the left that's how I tell Java I want an array of int with one dimension and on the right I'm initializing that 2f size for to store four elements so I have valid indices 0 through 3 on line 6 now I'm upping my game a bit now I have a two-dimensional array so I see two pairs of square brackets over here on the left in the declaration and on the right I now have to tell Java when I create the Ray when I initialize it how large each dimension should be so this says my first dimension is size for my second dimension is size 8 so I have valid indices for the first dimension of the array 0 to 3 valid indices of the second dimension of the array 0 through 7 and this array can store 28 values right okay down here at the bottom let's just see how this and you can continue this on ad infinitum at some point you're going to get a tired of typing square brackets but on line 11 I'm declaring a 3 dimensional array of doubles with dimension size 6 in the first dimension 8 in the second dimension and 10 in the third dimension meaning I have valid in to see 0 through 5 in the first dimension 0 through 7 in the second dimension 0 through 9 in the third dimension and can't store to 480 values in this right now when we talked about one-dimensional rays we talked about the fact that we're associating metadata with each item in the array so in a mote in a single dimensional array every item in the Ray has this new piece of associated metadata which was a single index in a two-dimensional array I'm now associating a pair of indices with each piece of data and in the three-dimensional array I'm associating a triplet three indices with each each piece of data so that's really the difference here internally if you think about how your computer actually stores information there is one long array that is the best way to think about computer memory is one huge single dimensional array so all of this trickery all of these things that look like three dimensions at the end of the day have to be stored in one single dimensional array in your computer's memory but for the purposes of our programming it can be useful to associate two pieces of metadata to integers with a piece of data or three integers depending on the data that we're working with oh yeah I don't okay so I'm gonna blow past this really quickly because this gets how Java does this gets confusing quickly so on line two I'm declaring two two dimensional array if I take now normally when I when I access values inside a two dimensional array I use a pair of indices one for the first dimension one for the second dimension but here I'm only using one indicee so it turns out if I do that what I get back is a single dimension array so what Java is really doing is it's storing arrays inside of arrays so my multi-dimensional array is really a single dimensional array which everywhere every value is another array so you think that you can think of this as a single dimensional array of int of size 4 where every value is itself an array of integers of size okay so let's yeah so we can you know we can commits ourselves of this let's play around with this a little bit doesn't print anything yet but let's print the size of this so samples slice is an array it has a length the size is 8 right so if I print the length of samples and if I do this I print just the length of samples you'll see that at high school yeah so I have a 1 dimensional array of size 4 where every value is a one-dimensional array of size 8 and if I had a third dimension every value inside that second array would be another array so it's raised inside of a raised and side of arrays I can also okay so this happily I don't think we're gonna torture you with anymore we used to have an MP on that that had you used multi-dimensional arrays heavily and we did some static array initialization this MP and it's terrible because it really because you start to make assumptions about where the data is on the screen and those are wrong based on where it is in the array so just like I initialize a single dimensional array if I want to do static initialization I can use brackets I can use the same I can do the same thing in a Java array so here I'm initializing an array where the first dimension of the array has size 2 and every array inside that first dimension has size 2 so this is a two dimensional array where the first dimension has size two and the second dimension has size two and I can also use so I should have had a slide on this but this is how I access values inside a two-dimensional array so in a one-dimensional array I used one in to see inside the brackets in a two-dimensional array I can use two indices each in their own pair of brackets so this gets me the first value from the first array and then the first value from the first summary again so if you think about it I've associated so let's look at this and we can see now both the data and the metadata so the data is over here so the data inside my are stored inside the array is the value one but I had this metadata associated with it which is the pair 0 0 I stored the value 2 and I associated the metadata 0 1 with it I store the value 3 and I associated the metadata 1 0 ok how do how this maps down to here again can be confusing so I don't suggest you do this you won't see this very often okay all right so let's go okay so here's one thing I really want to encourage you when we do problems and when you guys use arrays how many people were taught about rows and columns in high school in your class okay I'm sorry you know I don't you know maybe when you go home for Thanksgiving you can go find that person and have a conversation with them about the fact that we talked rows and columns are a spreadsheet concept that really have no relationship with how we use multi-dimensional arrays and I would suggest that you try I know it's hard it's like that movie Eternal Sunshine of the spotless mind right if you could somehow erase that part of your brain it would actually be good you know when people teach physics they have to deal with all these people's misconceptions about the world part of teaching physics well is actually figuring out how to convince people that they're wrong about stuff and you can find these great videos online you know there's a how many people have seen this there's a famous video where they go around at Harvard and MIT commencement and they ask people to explain why the seasons happen has anyone seen this before if you happen I would suggest you find this on youtube and watch it it is really funny okay if you thought those people were smarter than you think again all right watch the video maybe you don't know why the seasons happened what once you do you watch this video you'll be able to pretend that you did before anyway we don't talk about rows and columns in this class I will not let those words escape my lips because it's is a confusing concept what you the meaning behind the first and second dimension of a multi-dimensional array is totally up to you those are just extra pieces of metadata that you are associating with each piece of data inside to your right and this is particularly important when we start working with certain types of multi-dimensional data because otherwise you're gonna the rows and columns thing is going to make you think that you've organized the data inside in a particular way that maps to a particular spatial orientation and that's wrong or it can be wrong depending on how the person setup the problem so you're in charge here the meaning that you give to each dimension inside a multi-dimensional right it's totally up to you and should be appropriate to the problem that you're solving or the data that you're modeling using a multi-dimensional array all right so why are we doing this and again I apologize I sort of started here and worked forward but instead we've talked about this but what type of information do you think would be a good fit to be stored inside a multi-dimensional array what kind of data in the world does it make sense to represent and to store multiple pieces of metadata with yeah images right okay so let's think about this in an image what's the data yeah yeah each pixel is a particular it's like a little dot of color right so imagine I'm putting together a photo I get these little dots of color and every dot has a value which determines what it looks like and then what's the metadata so that's my data but remember the metadata is as important as the data in a picture what's the metadata so if I'm putting it let's say I'm putting together a photo I've got all these pixels different colors and I'm using them to try to assemble a photo I pick one up the metadata is yeah where it goes its position so I say you know I imagine I start with a square canvas and I'm sticking things on there the value is the color the metadata is the position so yes a picture consists of a series of pixels so here's a random photo right every so the way that a computer represents this is it breaks it into tiny tiny tiny pieces on a grid it says I'm gonna break this and you know depending on how large the pixels are the picture looks fuzzy or it might look sharper right so here there's a certain number of pixels that we go across certain number of pixels that we go down every one of those if you zoomed in and zoomed in and zoom didn't zoomed in you'd see that every one of them eventually get two squares and every one has a single color so there are the data is the actual color at each pixel the metadata is its position again just like with music I think it's more apparent with sound with a photo but the position is as important if I took all the pixels here and just scrambled them up together you wouldn't have this nice photo black and white photo of a waterfall you just have like static it would just look like wow whatever you know it loses its meaning so the metadata matters lot of scientific data is multi-dimensional so here I don't remember what this is but you know you could imagine maybe this is like the temperature on the surface of a volcano or something like that so here's my volcano and and this representation is is for dimension actually right I've got one dimension here one dimension here a third dimension of height and I'm using color to represent the fourth dimension so this is four dimensional data right so for every you know in order to figure out you know at every given point here I need to know where I am in space three dimensions and then I have to have the color dimension as well all right so for dimension all right music okay so this may confuse some of you we talked before about music as single dimensional but music is actually typically unless you're still listening to the record player with old Joe Biden music is typically multi-dimensional actually even record players for stereo sorry I shouldn't make that joke this this is make sense everyone music what are the two dimensions in music yeah okay I can I can represent ever I can represent music in in general as a series of measurements of pressure that's a single dimensional data set but where does the second dimension coming from I'm giving you a big hint on this picture yeah I just have one series right so time the values are the measurements of pressure and the one dimension is time yeah what's that know what's that I think I'm hearing the right answer yeah you've got two ears most of you I suspect when you listen to music do you did you guys know this when you listen to music there's actually separate signals being sent to the right ear and the left ear there are two separate tracks and that's on the simplest possible music how many people you guys still go to movies anymore I don't think you do because when I go there's no one there right but does any has Evan wood been to a movie like in the past ten years in a theater okay good at a theater there might be eight different tracks for a movie you've got speakers behind you to your left and right up in front of the stage one below the stage that's for voice and then maybe a track for the subway so typically when you listen to music it's multi-dimensional so there's lots of data out there in the world that we can store what are to be able to work with multiple dimensions and again this is all data where for each piece of data I have multiple uses of metadata that I want to associate with it with a picture the data are actually the little color swatches the metadata is the position with sound the data is the series of pressure measurements the metadata is both there's two pieces of metadata one is time the second is which ear or which channel it's part of if you're wearing headphones which ear is it going it okay so one frequent use so you know when we talked about arrays we said okay we've got this data in an array a lot of times what we want to do a lot of algorithms that work on data consists of going through a data structure like an array or a multi-dimensional right and then doing something to it here's an example so this is now going through a two dimensional array when we went through one dimensional arrays we used a single for loop now every array is itself an array and so here's the pattern that we use to go through a multi-dimensional array so my outer for loop and this is again one of the places where you're allowed to use single variable letter variable names my outer for loop is using I and it's going through the first dimension of the array and my inner for loop is using J and it's going through the second dimension of the array and then inside that inner for loop I'm using the double bracket syntax to print off the values inside the array and if I wanted to see both the values and the metadata I could print I J and the back okay so okay so let's let's do our so one of the another piece of data that we could store inside an array is data about a game how many people here have heard of tic-tac-toe okay so for those of you that haven't I know this is a something that might be called a culturally specific reference so tic-tac-toe is a game played by two players where you start with a board that has two dimensions and you have one player use this X's the other use this O's and each turn you're allowed to place you know an X or an O on the board and any one of the open spots and the goal is to get three in a row either three up or down or diagonal right that's the rules of the game of tic-tac-toe so we can write we could write a computer program to play tic-tac-toe tic-tac-toe is one of the games that's in the world that's known as a solved game does anyone know what that means any game players out there anyone play chess or go or yeah yeah so essentially in a solved game there's a known strategy for proceeding from any state in the game so there's no you know high strategy involved it's always a right move let's put it that way and that's why in tic-tac-toe unless you're playing against like a three-year-old you can always well unless the three-year-old playing against you unless you are a three-year-old you can always either win or force a draw right there's no reason to ever lose a tic-tac-toe that means that you did something dumb or you're a small child all right so let's so we're not gonna write the entire program to manage the game but let's let's think about how we might check to see if there's a winner we're gonna write a little function here together so the first thing we need to think about is how are we representing the state of the game so I told you that there's a two dimensional board and at each position in the board each position the board can be in one of three states so either it contains an X meaning that the player who is playing X put an X there it contains an O meaning that the player who's playing o put an O there in a previous turn or it's empty and what I've chosen to do here and you could do this another way if you were writing this game but I've chosen to represent an empty spot using a period so period isn't a valid tile it's on a valid character in the game and so I'm using a period to represent a spot on the board that no one has played in yet so you can imagine how this would how this game would work inside your computer essentially you'd have to make sure that X's and O's play one after another and then every time somebody puts a new piece on the board we need to check to see if there's a winner so we need to look for three in a row and we need to look for three in a row either three in a row either across or down right so we need to find three in a row in the first dimension or three in a row in the second dimension see how I'm not saying row rows and columns okay so let's let's do this so the first thing I think we should do we're going to write a little function here let's let's just get some practice writing a loop to go through the board why don't we do that let's try to write a loop let's try to write a little function just before we check the board let's try this fit and figure out how to how to print the board out okay so here's what I'm gonna do I'm gonna write my little for adopt length I plus plus and then okay and so now let's just make sure that I'm getting the right values of I to start with oh yeah it's mad at me because I didn't return anything that's okay let's just return nothing for now okay so this looks correct the board that's being passed in has size three in the first dimension and I'm seeing indices 0 or 1 and 2 okay so my outer for loop is working let's write the inner for loop now and we'll check this and make sure that works so my inner for loop is very similar except the condition is a little bit different so rather than going through so in my inner for loop my outer for loop I'm using the length of the first dimension of the board remember how arrays work in Java when I have a multi-dimensional array that means that every element of the first dimension in the erase itself an array and so that's what I'm using here inside my second to write my second loop so I start j at 0 I continue J until it reaches the length of this particular sub array and we'll see why that's important in a minute and then I do J plus plus so now let's print off I and also will append on J here to see what's happening and I need to stick all right drag this up a little bit so we can see everything okay so this looks right okay so the first time through I've got 0 0 0 for I 0 1 2 4 J the second time I've got 1 1 1 for I 0 1 2 for J and and it's up so it looks like I'm my indices are correct now let's do this let's try to get the value at that position in the board so we'll do board I J put another space here ok and you'll see here that I've got so the at 0 0 so the first sub array the first position in that sub array is X that's right here the first sub array the second position is oh that's right here the first sub array the third position into c2 is period etc so I'm this looks good now if I wanted what would I do here if I wanted to print this out a little in a little bit prettier way here's one suggestion so I'll show you how this looks in a sec that here's my code okay so what did I change so I'm not printing the indices anymore because I'm pretty confident that I'm going through the board properly instead I'm just printing the values inside the board and I replaced my print 'ln with a print statement so that's not going to add that new line so that means that the board is going to go left to right until I reach the end of each time through the inner loop and then I'm going to start a new line so I print X oh and period on the single line I jump to the next slide and I keep going so now I've got a nice way of visualizing the board now is there a winner on this board there is but it's a diagonal winner which we're not going to check for so I'm gonna get rid of that winner make may just change this okay so now there's no winner on the board all right but I want there to be a winner because I actually want to run this and I want to see that there isn't one so now there's a winner now now I know I don't know why Oh got to play so many times right you know again when you're you're playing with your you know child when you're playing with your friends who are small sometimes you let them cheat right so oh when a bunch of times right but we won't worry about that right now we're just gonna try to figure out giving this board well have some other piece of code that will make sure that people are playing fairly or maybe not depending on who you're playing with but all this is supposed to do is identify that there's a winner on the board okay and in either the you know either across or down so how are we gonna do that who has a suggestion for how to accomplish this so I've been able to display the board it's good start but I actually want to detect when there are three in a row so let me let me change this a little bit to give us a little bit of an easier starting point and when you guys are developing this is a totally valid thing to do right I'll put another X in here okay so now I've got a winner going across so how do i how do I do this what's my algorithm for checking now you can see the board so someone described how your code would work or just think about what you're doing when you look at this board to try to find out whether or not there's a winner we're gonna try to replicate that in our code who can describe an algorithm to me that's going to solve this problem yeah okay so I definitely I couldn't hear very well but I got pieces of that I like what we started with which is I definitely need to clearly I need to loop through the array let's let's just do this together so let's say I was scanning through this how do I do that so I look at the first character let's say I'm looking for winners let's just do part of the problem again whenever you're struggling with something make the problem a little smaller see if you can figure out how to solve that one part not only will you solve part of the problem but that might suggest a way to do the rest of it okay so let's look for winners horizontally so the horizontal winners are going to be detected in my second loop and here's if I was looking at this here's what I here's what I'm doing I look at the first character and then I say is the first character the same as both the second and the third character in that you know that are going across if it is then I found a winner right almost look at to that in a sec so let's try to write a piece of code that's gonna that's going to allow us to do this okay so I'm going through now here I actually don't need the this inner loop anymore all I'm gonna do is I'm gonna print the first element of whatever first dimension I'm in okay so that's now just printing the left-most element of every sub array that goes across oh oh and dot writes oh oh oh and dot and what I want to do is let's say let's do part of it let's say if board is I is equal to board I one when I okay right so what am i doing now what does this piece of code accomplish so this piece of code is looking in the second it's looking in the second dimension of the array and it's looking for places where the first value is the same as the second value so the value with indices 0 is the same as the value within 2 c1 inside this second array inside the loop so my loop is going through every you know second dimension array and it's looking for cases where the first two values are the same so here it's printing where I am in the first going through the the first loop so basically it says here's one place where that's true and here's another place where that's true so I'm close how do I extend this to do more of what I want so here I'm saying the first character is the same as the second character but to win in tic-tac-toe what has to be true yeah they all three have to be the same right so how can I do that let's add another if statement and I could do this multiple ways I could check whether the second was equal to the third but in this case I'm just going to check whether or not the first is equal to the third okay so this is close except there's one problem this is now identifying two winners it says there's a winner in the first second dimension of the array and there's a winner in the third second dimension of the array that's wrong right there's only one winner on this board right now what do I need to fix about this this code has a bug yeah yeah I should ignore periods periods indicate an empty space so here's a question there's an empty space can there be a winner in that part of the array no cuz it has to be filled with pieces from either the first player or the second player so here's what I'm gonna do again there are multiple ways to do this I'm gonna say if the first the first value is equal to this then I'm just gonna I'm just gonna stop because I know that that it's impossible for there to be a winner at that part of your way okay so this looks good let me clean it up just a little bit let's print print it's pretty nice message here okay what else can I do let's let's say that this works eventually and I'm running it every time and the game is gonna stop as soon as there's a winner so what can I do as soon as I find a winner so a little bit of a optimization what's that yeah I can stop looking remember this piece of code was actually supposed to return who won the game so let's go down here and print the result currently it's returning dot because I have this down here so instead of that I'm gonna say return as soon as I get here as soon as I find a winner I don't have to do anything else I'm done this is a good this is a good strategy for when to use return statements this is something you can apply as you finish up the first checkpoint of the machine project in certain cases when you're writing a function or algorithm as soon as you know the answer you can stop you don't have to keep looking now I still have a return statement down there at the bottom okay and what is that for so that's for cases where there are no winners so let's break the winner here so I took that place in the game where I was finding the winner and I changed one of the tiles to X so there's no winner at that spot anymore and now it correctly says that there's no one all right so I have correctly I think this works let's test it okay so let's add a winner in the second array that I would need to check and it still finds that one so that's great let's add like a tile here okay so that that works right let's see here me let's put a winner down here all the way at the bottom okay so this looks like it's working however it's not finished and I'm gonna leave this is an exercise for the reader because this is a homework problem for later in the week here's a board on which there is a winner if I printed this up you'd see that there are X's going down three of them my code does not identify this so I'm not quite done I need another so you can think about it is this part of my code is looking for horizontal winners I was looking for winners horizontally the way to be printed the board before now what I need is I probably need another loop to look for vertical winners I need to look for winners going down and if I really wanted to make this totally complete I would need a third place to check for diagonals we're actually not going to make you do that okay so one of the things that I wanted to use this example to point it out is this idea of testing right when you're when you're writing code I'll give you guys test cases but I want to give you some sense and this is useful when you guys are working on the homework problems when you guys are working on your own code sometimes to think about how to test your code and typically what we do is just what we were doing together I write some code I pick the inputs for it where I know the answer so I chose inputs where I knew what the winner should be and then I can check to make sure that my program is producing the right output okay I didn't check every possible board okay I only checked a couple and so part of doing a good job of choosing test cases is trying to pick ones that you think are going to cause a problem and this is something that you will get better and better at as you continue your career in computer science you will so this is kind of an interesting adversarial relationship that you have with yourself when you're working on a software project and I I do this all the time right it's this sort of Jekyll &amp; Hyde thing it's like you write some code and then you write tests that try to break the stuff that you just wrote so you know you turn around and now you're in an adversarial role where you say I don't think you did that correctly and so I'm gonna see if I can find a way to crash it and then you go back to the first one you say oh I found some problems things that didn't work right I'm gonna fix those and then you swap back and forth right and this is how people write good test Suites you essentially have to you know again this hopefully this chapter on debugging that you're reading has convinced you and helped remind you that this isn't this is something that never stops so again if there's anything I wrote this on the forum but if there's anything you take away from this chapter in the book it is that the fact that you write code that has problems does not mean that you were bad at this you will never stop writing code that has problems okay the people that are interviewed in this part of the book are experienced software developers and they're still making mistakes all the time think about it I mean you've lived through cases where there have been big outages of you know big services like Amazon Web Services or Twitter or whatever right those companies have thousands of really smart engineers working for them and they still make mistakes all the time now actually they make a lot more mistakes than you noticed because they catch a lot of them through testing and stuff like that but they still mistake make mistakes that you do notice mistakes that take down their entire site okay so again this the fact that you are making mistakes is a sign that you are doing the work it is not a sign that you are bad at this okay trust me ask any other core staff and I'm sure they will be happy to regale you with stories of problems that they've mistakes the David all right let's not do this okay I do want to talk about this because this is important this is on this week's quiz all right so then this is one place where you can get easily tripped up in Java all right so here's an example I've got two strings up top and I initialize them both to be new and remember I had this nice equality operator that we were using when we worked with primitives the double equal sign is supposed to check for equal and here's the problem with strings here's why this is confusing with strings that's why I'm talking about it as a special comment right now is that it's with strings this equality operator can be confusing so this is weird right this returns true it's not the right way to compare two strings here I've created two strings using the new keyword and then I compare them using the double equals and it returns false so this operator is not doing what you think it is there's a simple rule of thumb whenever you compare two objects there's a function typically provided called dot equals and that's what you want to use you should never test two objects for equality using the double equal symbol okay with that I think you are prepared for your quiz this week good luck with that I will be back on Wednesday oh one other comment on this week's quiz so check style is now fully operational okay it's not if you're gonna lose points is that you're not gonna get any credit all right good luck with this week's quiz I will see you guys on Wednesday  
﻿ good song I already heard that one okay so today we start we launch ourselves into the third second of three parts of the class so up until this point the last roughly one month almost exactly a month welcome to fall by the way today is the autumn equinox which I discovered is actually not the day where there's an equal amount of sunlight and darkness it's actually later this week it's a day called the equinox but today is the equinox official beginning of fall a little bit of cool weather out there for so well we are gonna start today is the discussion of object-oriented programming that it's going to consume us for about a month again this is a topic that builds on and layers on top of what you already know how to do objects you can think of it's really a conceptual addition to our toolkit for how to write computer programs and how to compute communicate with the computer itself objects also represent a major step forward and our ability to work with data and that's one of the things that's more exciting about me okay so let's get started you know and let me sort of also give you a little bit of a roadmap for the rest of what we're doing this semester slides too advanced for me so these are the main things that we're going to talk about so algorithms we've already started to talk about algorithms when you guys work on a problem like how to reverse the string essentially you're implementing a simple algorithm that's fine the algorithm itself is simple learning how to communicate it to the computer is the thing that you're struggling with right now but as we go forward in this semester we'll give you practice continuing to work on more and more complex algorithms as you become better at getting the computer to do what you want it to do we're gonna make the thing you're actually trying to accomplish more complicated that'll be fun data structure so how do we structure data and work with data and objects really are in addition to our ability to structure data so we've looked at simple ways to store in structure data in our programs objects give us a much more powerful tool we can actually design our own types and add them to Java's type system alright finally the software development principles and a lot of this will come out in the NP the talk about this in class may be from time to time but this is something that you're gonna be learning primarily through your work on the machine project and the different machine project checkpoints that we have coming up one of the things I think I've mentioned this already but I want to reiterate that I'm really excited about the machine project you guys are doing this semester is that because it's one long project rather than a series of disconnected assignments we actually get a chance to introduce you to things that you do in a real software development project that you normally don't do when you're just doing little one-off assignments for a class so for example refactoring your code you learn about a better way to do something if you go back and you fix the code you've already written you rewrite it to use a more sophisticated set of idioms or concepts that's something you guys are gonna chance to do on mp1 which is well timed because objects are going to clean up some of the mess that you guys made an empty zero and I'll show you how in a few slides alright so we've talked about we have some you know tools already here for how do we structure computer programs breaking things down into smaller pieces so we try to write functions that each do a single thing or at least can be tested right on some level we're forcing this on you through our test Suites because we're requiring that you write your code in such a way that we can test it effectively now we're gonna get to this second thing which is how do we model data how do we model real word entities real world entities typically have state they have you know a variety of different pieces of information that we might want to know about them they also do things and object systems like Javas allow us to model both of these components of real world entities State and behavior data and algorithms we're going to continue to get you guys to document your code properly that's something that's older more emphasized on np0 and eventually as we move forward we'll have an opportunity for guys to use libraries and figure out how to do this as well okay and then publish things which we'll get to at the end of the class when we start talking about objects so this is kind of a fun point in the class because this is one of the places where you start to get to use the right side of your brain so roughly speaking your well exactly speaking your brain has two halves but roughly speaking the right side of it is more concerned with creativity higher level thinking the left side is the more logical step-by-step side of the brain at some level you might think of the left side is more like a computer right computation is one of the things that's listed look at the things on the right side there holistic thinking imagination you know dreaming daydreaming all right these are things associated with right side of the brain programming contrary to popular belief is actually an activity that heavily utilizes both sides of your brain you know if you if you could scan you know really talented computer scientists really talented programmers this they're working I'm sure you would see both sides of their brain are heavily involved and objects are the first place where you actually start to get to some make some of your own choices about how you're going to design things you want to represent information about a position in space or a person or an animal or a course that you're taking at the University what information are you going to store what are you going to call it how do you structure that information so that you can use it effectively these are all design problems there's no right or wrong answer to them there are better and worse answers but there are no right or wrong ways to do this okay so Java objects begin to start to expose you to that part of computer science so I find this a very kind of an exciting moment right and we'll get a chance to again creates and things together you know imagine how we want to represent stuff and think about start to think more holistically about how we work with the in the war want me to think about it is until now you've had to content yourself with these eight primitive types that Java gave you out of the box now you get to make the box you can put anything you want in there objects allow you to design your own types and augment Java in any way you see fit okay so what is an object we've started to peek at them when we looked at strength but objects are a concept that appear in a lot of programming languages Java as a language is more centered around objects than some other languages but object orientation or objects as a programming construct appear in Python they appear and go I'm fairly sure they appear and rust they appear as types in Haskell they appear all over the places and every language is a little bit of a different system for working with them but roughly speaking usually when we talk about an object computer price we're talking about something that combines two features so an object has state it stores information normally this and and this is actually one of the more powerful features of objects because it starts to allow us to model data more complicated data types than we can store with just our primitive types and sequences of our primitive types but objects also so they were existing you know back before object started to become popular they were existing languages had a concept of something called a record which was kind of a way of joining together multiple types of data to represent something more complicated but Jonathas objects and objects in general also brought in this second feature behavior so behavior so on some level the way to think about this is state is sort of like variables and behavior is sort of like functions and objects unite those two things together okay so when we think about objects we're always gonna talk about two questions what does its store what is its state objects allow us to encapsulate information and when we design objects together a lot of what we'll think about is what is the state that we want the object to store so that we can store the information about whatever it is in the world we're trying to work within our program and then what does it do what sort of functionality should it provide so let's think about strings right a string was the first object that we worked with in Java it stores an array of characters that's pretty simple in many cases the state that an object stores can be fairly simple what gets interesting are all these different behaviors that it provides because strings as you saw if you you know have even opened up the string documentation have a lot of features that they provide they can do things they can search their contents for stuff they can break themselves into smaller pieces they can combine themselves with other strings at supper so all those different behaviors are what make the string pretty interesting and so on some level objects are kind of you know objects are in the middle of this class right we talk about objects for the second half of the class out of the three halves but the third half of the class we're gonna talk about data structures and algorithms that on some level objects and up until this point you know we've been talking about data structures and algorithms in a more simple way objects unite these two things together so objects store data and they implement algorithms and these are kind of the two core concerns of computer science ok so here's the actual object definition and technically I'm using the word object a little loosely right now and we're gonna talk about a more we're gonna try to be more precise about this in a few minutes because technically an object is an instance of a class a class represents an actual class of objects in the world a certain type of thing that we're going to work with an object represents one instance of it so for example person or student is a class every one of you is an individual student an instance of a student all right so the object can be a combination of variables functions and data structures and at some level that says an object be a function of variables functions and combinations of variables so really state and behavior data and alright so let's introduce so let's let's start to be more precise with the terminology we use when we talk about objects so a class represents a particular type of object and again now there you know for example because I write a lot about Haskell this this summary and Haskell has a very powerful type system that's one of its more important and distinguishing features and classes in Java are like Haskell types a type represents some type of thing in the world right so a type all the things in a particular type are similar in some way they all have common attributes but they're also different so each object each instance of the class can have different information but there's something similar that unites all of them that means that together they represent a class or a type when you design a class in Java and this is an example of a class definition you are essentially creating a new type in the programming language so up till this point we've worked with int and chars and strings and Long's and you know just the primitive types but now we can design our own types so here's an example of an object this is a class declaration okay so this is this is the point so the object part of this class from a programming perspective is not difficult from a conceptual perspective it's going to challenge you a little bit ok so this represents a particular type of Java object this class definition this says what I'm working with an object that's of type person that object will contain the following information alright so here's my class definition on line one class is another one of our reserved words in Java that we can only use here so when I define a class I start with the special keyword class and then I give my class a name and just like when we name variables and functions we want that name to be descriptive types or classes that it's incredibly important that that name is descriptive if I called this B you have no idea what this is I'm calling in a person that could see a clue about what type and information this class is supposed to represent okay so I have now I have a block and inside that block remember we said objects classes in Java unite State and behavior data and algorithms I have pieces of data and I have Method declarations or algorithms so the body of my class definition contains two things it contains things that look like variable declarations I've got one on line two and one I'll on three the one on line two says every person contains a piece of data that's a string that I'm gonna use the word name to refer to you can guess what that is every person also has a piece of data called age and a sub type int and you might say well why didn't I store that as a double he'll be a good question right because until you know ages that actually a continuous quaniee but let's just say we sorted this int we made that design decision maybe for this particular program it's not important exactly how old somebody is I just want to know what their ages and year is not years days hours minutes and seconds okay so that is the state that the object stores every object of type person that I create will store a name and an H it'll have a name and an age so again you know this is maybe you know something that it doesn't excite you as much as it should because look up until this point we've been just forced to deal with these single pieces of data if I wanted to store information about a person I wouldn't have been able to do anything remotely like this I would have had to store like their name as one variable and their age as a secondary and then I'd have to always remember to pass them around a function if I wanted to store multiple people I need a raise of both of them it gets ugly very now I'm actually designing a new type in the language I'm saying hey I'm gonna work with some data about people and here's the information that every person has to have for my program now obviously people have a lot more than just a name in an age there's a lot of other attributes that you might want to store about a person but maybe for the particular program that I'm writing this is enough so you get to make choices about sort of which data it can we not talk over here guys just like constant chatter coming from this part of the room like that to stop Thanks all right so but when you design the person class you get to choose what data you want to store about each person okay then following that I have my first method definition so now I'm saying that every person can do the following thing I'm establishing behaviors that are associated with this class so here's one this is a behavior it's a function it's a method you guys have been writing these as part of the homework you're not gonna write them alone anymore now you're gonna write them as part of a class but you've written these all right these implement algorithms it's a very simple one right this one says just print that person's name to standard out so I just use my familiar system got out print 'ln and I use some special syntax there that we're going to talk about in a minute to access the name of that object whatever object is running that method that's it when you look at more complicated class definitions you typically find just more of the same thing okay we'll talk a little bit about some places where things are slightly more complicated and I can do some some interesting things but this is the root of it so more complicated classes in Java have typically will have store more pieces of data sometimes not think about a string string only stores an array of characters one piece of data but if you looked at the definition for a string you'd find many many many methods okay the class so again a class doesn't represent an instance of the class that's an object you can think of the class one analogy that I think is somewhat helpful although I try to stay away from these as much as possible is that the class is sort of like a blueprint so a blueprint is not a house a blueprint tells you how to build a particular type of house if you take that blueprint and execute it faithfully which of course Java will you'll get a house and then if you execute it again you're good another house all right so the blueprint determines how a particular type of object is going to be structured now again each instance of a class or each object can store a different name in a different age but the class sets up a structure that all instances of that class are required to follow so every person has a name and an age ok so again every instance of an object class person so every object that's of type person will have a instance variable name that's a string I also have an instance variable age that's an int and so that's its state and its behavior is it'll have a method called print' name that takes no arguments returns nothing and prints the name of that object to the string so one of the things about Java that makes it interesting and one of the restrictions about Java that makes it useful although sometimes frustrating is that in Java once you have a particular class that you've established and you've compiled your code you can't make changes to it later you can change the name of an instance of class person but as your code is running you can't suddenly decide oh wait I think person should also have a birthday I'm just gonna add that it's my program runs if I want to make that change I actually have to change the class definition and recompile my code now there's a reason for this other languages Python and JavaScript some interpreted languages will allow you to make changes like this at runtime that can be a little terrifying it can cause problems Java doesn't allow me to do that if you decide later that you need to model more information about a person you can change the class definition but you have to recompile your code and then you know for example if you had an app you would have to redistribute a new version of the app you may think that this is frustrating when you're writing small programs it turns out to be really really helpful when you're debugging and working with larger pieces of software because you have a guarantee if I give you any instance of a type person I know things about it I know that has a name I know that hasn't it okay so now we get to finally talk about new which has been kind of you know messing with us for the last couple weeks we didn't really exactly know what was going on so now I have this blueprint I have this class definition how do I actually create an instance of that class that I can use to store information so I have a blueprint that says this particular type this particular class is going to represent or store this following data and it's also going to have these behaviors but how do I actually create one so that I can give it a name in an actual age so an object you know again an instance of a class or sometimes we'll just use object for this in Java or an instance sometimes I'll use them interchangeably is an object that has been created according to a particular class declaration so I said here's what a person class looks like and then I'm going to create one the way I create a new object is I use a special keyword called new all right so here's right here one two seven this is my definition of the person class that tells me what its state and behavior are and then on line eight I'm actually creating a new instance of class of a class the class of type person now this looks pretty similar to other variable declarations and initializations we've already seen over here on the left side I'm saying Java I want to work with a variable called Jeffrey that's a type person variable named variable type once I start defining my own custom types I can use them in the place of a normal type declaration as part of an initialization that's what they are right this is equivalent to an int or a char or a string now on the right side unlike an int or a char I do need this special new keyword it's actually a literal and figurative new keyword so I use this word new that says the Java create a new instance of this class and then I have the name of the class and something that looks like an empty method declaration and for now we're going to ignore that but we are going to come back and talk about that very soon on Wednesday so after line 8 executes Jeffrey is an instance of it's a variable of type person so I can set its name and I can set its age right so again let's try to get the terminology straight here because it's important person with the capital P is a class it's a type of Java object Jeffrey in this example is an instance of that class or sometimes just an object an object of type person all right dot notation so how do we get we know that objects combine stated behavior how do we access that state of behavior again some of this you've seen already with strings and with the rays but you didn't really understand what you were doing now hopefully this makes more sense so the dot notation is what allows me to access the properties and methods of an object of an instance of a class so here on line 8 I've created my instance of class person called Jeffrey now I have a variable called Jeffrey so I have one person and I can set that person's age using the syntax on line 9 I take the name of the object Jeffrey dot and then the name of one of its instance variables so one of the pieces of state that are defined as part of that object so I defined a name and age here I'm using dot age to set the age of this particular person and on the right side I've got a literal right ages an int that's defined in my class and so I can set it with an int literal once that set I can then initiai can then print it right so let's try this together and make sure that it does oh this one's still wrong I've aged bit ugly happens all right there we go I could also set my name here as well let's do that say Jeffrey name is equal to hope you like stab but that's fine right and now down here I could print name you go if I try to access something that I haven't declared I get a compiler error again this is one of the places where job is helpful and if you try to do this in IntelliJ it won't even let you do that it'll be a big angry red squiggly there being like instance the class person does not have you know instance variable food you know Java also makes sure that my assignments conform to the right so same thing here now I'm using a double literal but age is an int and so I get a warning very similar to the way that I would get a warning if I tried to set just a you know a local variable type in it all right any questions about this where you going yeah ah okay a good question goodgoodgood bit of review so what does this mean here on the left part of printing anyone remember so what goes to the left of a method or a function declaration yeah a return type and what is void me yeah it means what it means it doesn't return anything so avoiding method cannot return anything so if I try to return something from a void method let's try to return an INT it's not going to compile if I try to set something to the result let's use print name actually let's do jeffrey dot print name okay Oh still mad me about that let's get rid of it ah okay so this is actually really interesting that we're gonna come back to that in a second let's set my name well I like to be called no print it will call the print name function which does the same thing and now let's try to save the result of that I can't do it all right so void is a special type the only place it's used is in a method declaration to indicate that method doesn't return anything I can't create a variable type void cuz what would the point be right can't send it to anything that would actually be amusing if Java would let you do that I could just a clear voice variables just because I wanted to have a variable called whatever you know I can't do that only place I can use void is here okay so one of these I want to point out so we talked before about the instant the the primitive types in Java this a primitive types being the building blocks with which we were gonna then use to build more complicated pieces of data to model data you know as I just want to remind you of something as computer scientists you know there's this all this buzz about data science and stuff like that okay as computer scientists you are already data scientists right that's what a computer scientist is plus some other stuff right don't forget that you guys work with data all the time you will spend the rest of your career working with data don't feel intimidated when someone says there are data side say okay yeah me too on the computer side but how do we work with more complex data in Java well we have these primitive types but now I can design objects that combine multiple instances of those primitive types together and then it turns out that my objects my classes can also contain variables that are themselves objects so I can nest things so I can have a class declaration that includes instances of other classes in fact we already just saw that right person my person class one of the instance variables age is a primitive type but the other one it's an object strings are objects that's why they're capitalized so here I've got a class that combines two fields two pieces of data one is a primitive type and then another one is itself a class and then if you look inside a string what are you gonna find an array of characters so I promised you before if you drill down far enough eventually you get two primitive types so you can start with any object declaration in Java and if you break it down break it down break it down follow it all the way down you're gonna find yourself two primitive types so here's just another example and a lot of cases this is useful so here's an example of I'm storing maybe I'm building a program to allow people to you know create a schematic for where to put furniture in a room or something like that okay and I've got a room class that's supposed to represent information about the room my program will have multiple rooms every room has a name remember that name is another object and then here I could say oh the room has a height and a width but what I've decided to do is I've decided to represent height and width themselves as a separate class as a dimension class why would I do that that just seems more complicated why not just have every room have a height and width that would probably also work at least in the beginning yeah so so the answer was if I have a bunch of different rooms but if I buncha different rooms everyone will have its own height and width so that's okay that'll still work why take dimensions here and create a separate object yeah what's that okay I could have an area method on my room class that returned the area of the room it's a good question actually yeah yeah so it's possible that other things also have a dimension like a piece of furniture so my furniture class so as I was writing this program probably what you would do normally is well you would start by saying okay my room has a height in the whip but then you have a separate class for a piece of furniture and you're like oh gosh this also has a height to it so now I'm starting to repeat myself and so by creating this dimension class now everything that has a dimension can use this and if I need to do something like compute the area I'll add it to the dimension class this will make more sense as we go on all right if I need to set the value of something inside an object I use I can continue to use dot notation so I can use dot notation to follow an object pass so you know to take one object and to access you know other methods or variables of objects that it contains let's put in something so we know what happened here all right good so what am I doing here so dining room so I have an instance of room here that I've declared and then notice so I want to point something else out to you that's important here because this will motivate a little bit of our discussion on Wednesday so after I create they get rid of this okay I've created an instance of my dining room what's the value of dimensions going to be right after this finish is executed let's find out okay who thinks it's gonna well who thinks the job is already automatically gonna set up like a dimensions object for us with you know so that would be nice right yeah chop it's not so nice I'll see what happens right so let's print the value of dining room dot dimensions no okay so that scary magic value that indicates nothing this is one of the places where our null trips people up is uninitialized object variables so for example if I forgot to initialize dimensions and then I came down here in my program and I said okay what's the width of the room now I have one of these really nasty null pointer exceptions a runtime error that will cause a crash that somebody will notice all right we will talk about how to address this problem the next time so again in Java this objects open up the type system they are your key into the type system in Java Java gives you some starting points these primitive types and then you're off to the races once you know how to use objects classes in Java should not be something that's scary unfortunately you know because of how we grade your assignments it's not always straightforward for us to give you practice at doing this and this is something that I've thought about a little bit I just don't have a good solution for you in terms of how we structure this class normally when we have you design classes we're gonna tell you what we want because we don't tell you we can't test your code right so if I say okay design a person class I've got to tell you what the names of the variables are and stuff like that so I apologize for that because we're essentially kind of limiting the creativity that you guys can express but when you're actually so when you guys get to your final project and when you get out in the real world and you're writing real programs a lot of what you spend time doing it's thinking about how to model the data that you're working with what pieces of it should you store what should you call them how do you initialize it where does it come from where does it go you know so you know in a lot of the code that we've written for this Club to support this class for example if you talk to some the course developers they'll say yeah I mean we spend a lot of time designing classes designing objects designing new types right partly because a lot of those choices are up to you once you're you know once there's no autograder to satisfy let me give you a little bit of a preview about where we go with this so you know those of you that have you know I think by now pretty much everybody is working on mp0 many of you are done graduations but you had to write on MP 0 this incredibly sad function alright maybe writing it made you sad but the thing that's sad about this is actually not that you had to write ok one of the TAS for the class like went through the NP and was like oh my gosh what do you is doing this good target within range like it takes like eight arguments right ok but up until now you didn't know about objects so this is the best we could do ok so I'm sorry that we forced you to do this hopefully you'll get a chance to fix it right so why is the method signature of this particular function so awful well because the only thing that we were you were allowed to work with on mp0 the first empty checkpoint was primitive types and so if you want to represent latitude and longitude a position that's fundamentally at least two variables maybe even three if you represent high altitude off the Earth's surface okay so a function like this has to take an array of latitudes an array of longitudes a path and then a current longitude and the current latitude okay how can we clean this up all right so you know again is this this approach is sometimes known as synchronized indices and please forget that as soon as you saw it because we will not do this again all right but what does that mean it means that the the value of doubles I is associated with the sorry the value of latitudes i's associated with the values of longitude i okay so what we really want here this is one place where opening up Java's class system be able design our own type produces a dramatic improvement in the quality of this code okay we want a location type that stores a longitude and latitude this is a piece of data in the world that's more complicated than just a series of data points okay this is a this is a particular type of data it's not hard to model it just has needs two doubles alright so here it is okay sorry there's a bug on this slide let me see if it got fixed yet just reload this guy oh not yet okay ignore them this this is from last semester okay but imagine I have this class I can design my own classes now no I know how to use I'm starting to learn how to use objects in Java I know that I can use them to represent more complex data that I can represent with just single or series of values of the primitive types so what I've done is I've created a location class every location has again at minimum a latitude and a longitude and then I can also put an is valid flag on right to indicate whether or not this longitude and latitude makes sense maybe you gave me values that are outside of the range of valid lat/long right there are limits on you know there are so there's a range of valid latitudes and longitudes and if you create a location with invalid ones I'll check and I'll set that to false we'll show you how to do that next time so now look down at the bottom and look at this look at how much cleaner this becomes okay remember before actually it was worse I had the array of latitude story of lunches and then a third array the path that was had indices in it that guided me through the first two arrays so that was bearable all right instead what I do now is I just give you the path as a series of location measurements all that data Google's collecting about you a lot of its in this form series of location measurements right you know usually there's pobably a timestamp associated with them too then I give you another location that's the current location that's where you all right now again I don't have to give you a latitude and a longitude current lack current law just give you one location object so this is why this is you know just one example and you can imagine how the rest of this function goes and doing some of this cleanup is something that I think is part of mp1 alright so on some level objects are one of our first data structures right you know formerly known as records but objects you know because they combine state and behavior they go past this little okay so last thing we're gonna talk about today are this idea of an instance method so we've talked up into this point we've largely concerned with the data that an object could store but objects can also do things that's one of the things that's fun about them the instance methods are part of the class declaration so every object of that class can perform certain actions it can implement certain behavior so here going back to our dimensions class is an example of me adding a feature to every dimensions object I might say hey would be nice if the dimensions object would know how to calculate its own area just in case I forget and indeed I can do that very easily now we're seeing a new piece of syntax here well let's let's make sure this works first okay seems like it works when they create an instance with different dimensions and make sure it's still working okay good so state and behavior let's say let's see let's do this boolean is portrait I need to be able to spell portrait and I'll say turn this it's greater than this height so you know if I was looking at this and the width was along the bottom of height was long time this is in portrait orientation this is more appropriate for a photograph maybe right so now I can say this is how I add a piece of state to an existing variable right so now the width actually it's that right no it's all the way around if the height is greater than the width right so as I went along and I was working on my program there might be other things that I needed every dimensions to be able to do and I can add them that easily okay so let me briefly talk about this special new keyword called this that we just saw so when an instance method runs it I can only call an instance when I have a I can only call an instance method when I have an instance of that class so whenever an instance method runs its accessing the values of the variables on that particular instance of the class and one way to do that is to use this keyword called this so whenever an instance method runs this refers to me that object okay so let me go back here let's just this is gonna be silly but let's make something called void print width and we'll say system dot out dot print Lin this dot width and then we'll do sample dot print width so that's gonna print 10 let me create a new dimensions object and then let's set it to 20 call it second and now let's print second dot print line hope I said example again second I kind of second since this variable is perfect so at this point I have two different dimensions objects they are independent from each other if I change the width of one it doesn't change the width of the other let me prove that to you by [Music] printing the width of the first example again done all right so we will come back and talk about this a little bit more oh look at that I just did that one awesome all right okay so we'll come back and do some object modeling next time on Wednesday we're going to talk about constructors but the midterm starts today I wish you guys the best of luck a quick reminder about format 12 multiple choice questions on code reading three programming questions the programming questions do have partial credit there is one on arrays one on multi-dimensional arrays and one that uses strings string documentation is provided as part of the cover sheet for the exam good luck I wish you guys the best of luck you guys are doing really well and one of the practice problems one of the quiz questions is up on the practice problem side all right good luck on the midterm mp1 will be released to everybody tonight the blue team already has it good luck to the orange team finishing up mp0 I will see you all on Wednesday  
﻿ welcome back so today we continue our journey in Jabba's object system and we're gonna talk about a feature of Java objects that makes them much more useful to us it allows us to establish relationships between them which at first is kind of a nice way of avoiding duplication within the programs that we write but eventually as we'll see we talked about polymorphism and interfaces and other things has really powerful properties that aid us in our software development right and really I think reflects something about real world entities so you know again objects in Java Java is class Java's classes the ability and Java to create new types is a capability that's designed around the idea of working with data and when we think about things in the real world we know that there are relationships between things hierarchical relationships between things and we're going to start seeing today how to model those relationships using our java classes so that the data we work with in our programs more accurately reflects the relationships and they you know the relationships between the data that we find in the real world all right so first let's talk a little bit about the midterm so overall I was pleased with the aggregate performance of the class on the midterm there are two if you want to look at a couple of practice problems I didn't release the problem that was just already from the homework she already had access to that problem but two of the practice programming problems are available as part of the homework 125 practice problem set if you want to go after them use them for practice for the future notice that these problems appeared on the midterm in several different forms so it's possible that you saw one that was slightly different than the one that is on the practice problems okay however you know when we look at the midterm when I look at the midterm I mean what I see is the aggregate performance of the class and I look at that and it's say ok that's fine but behind that are you know 800 individual stories and individual assessments and so let me talk for a few minutes about how you should interpret your midterm score because the point of the midterm exam the reason why it appears at this part of the semester you know you know I have colleagues and I've talked to people here that are like oh you know the right thing to do is to just wait til right after the drop deadline and then the class should get hard right now way you can fool people those two problems of that first ball to drop deadlines really late and then we won't be able to do anything all semester the second problem is I don't want to do that to you I want you to do a little bit every day but it's possible that at this point in the semester things just aren't going very well and if that's the case we want to make sure that we fly that and do what we need to do to help you either recover or make a decision about why don't you want to continue in the class this semester all right so I would primarily interpret your performance on the midterm is a function of how you did on the three programming problems multiple choice questions you know maybe this little bit tricky you know you might have missed one or two or maybe a few I think that's kind of okay if you missed a lot maybe we should talk about it but the thing I would think has the most diagnostic power for you to make your own decision about whether or not you should continue in the class are the programming questions there were three of them so so here's how to interpret this you got them all good we don't need to say anything else great job you did nice work on the midterm we did two out of three good you know I think that's okay it gets acceptable um but whatever you've been doing keep doing it because you're gonna have to keep doing it to keep succeeding in the class so you're not you know you cleared the bar you didn't clear it by like a mile so you know again just plan on continuing on keep it on keep it on throughout the semester the semester and if you do you're going to be okay if you only got one then something my suggestion is something about how you are preparing for exams in this class needs to change here's the other thing that's that's hard about this and this is why tomorrow in lab particularly if you know you didn't get any of the questions right or if you only got one right I'm asking in lab TAS to come and talk with you and to go over your answers because you know I've already talked with several students and made some small mistakes that's fine you know a little error here and there sometimes there's some little misconceptions that we need to clean up you know whatever so looking at your code which I can't do for all 800 of you I will be happy to do it for anyone who wants to stop by my office hours at any point but the TAS will be able to do that with you individually tomorrow so they'll be able to look at what you submitted and say okay you're really close or you're way off I think we have some serious misconceptions we need to clean up so that's one things we're gonna do in lab tomorrow if you didn't get any of the programming questions right you know again please approach a staff member or be ready to be approached tomorrow in lab you know we don't do this to call you out or make you feel bad about yourself we want to help a lot of resources in this class we have a lot of staff they have a lot of knowledge we have a lot of really friendly people I mean you know from my vantage point you guys may not see you know how hard some of the core staff particularly some of the CAS are working to help you out right you might think oh well it was nice that somebody was patient with me and helped me through the homework problem you don't realize that while you're receiving some help on the homework problem there are like 30 other students that are also receiving help from other ch some of which are rapidly scanning back and forth between multiple threads guiding you in the right direction so again we want to help you we don't want to this isn't like something about shame this is about acknowledging that we're concerned about your performance in the class and we want to help that starts with looking at what you did and assessing kind of where you are conceptually in the class and maybe having a little bit of a conversation about what needs to change going for hey that's what we're gonna do tomorrow in lab one of the things okay any questions at this point it's kind of a you know I think I suspect you know I don't have as much of a sense of the ebb and flow of college life from my perspective but I feel like this is you know we're kind of in the thick of it right now right I mean the beginning the semester feels like a long time ago Thanksgiving break feels like a long time from now it's hot outside for some reason you probably have other midterms than other classes things are starting to get you know when you start off typically as a freshman everything kind of starts pretty easy for a while and then everything's getting more difficult at the same time and so it's natural to feel a little bit overwhelmed any questions about midterm MP stuff yeah other so the question was are there any extra programming questions not that we curate but you can certainly look on the website we have some guides to find other places to practice and the CAS can help you with that in the forums one yeah you know someone asked me this the other day and I have to admit if someone would find one of these I would be really happy but I think unfortunately strangely CS 125 seems to maintain one of the better sets of questions about object-oriented programming that I've been able to find online there's a lot of like little leak code questions about algorithm design and stuff like that but the kind of object-oriented stuff you're doing right now there's just not a huge library like we we'd like to move forward in the future to the place where we have a lot more questions we're just not there these questions actually take a while to produce yeah yeah so the question is how do i distinguish between compiler errors and runtime errors I'll give a brief answer but this is a baby a great question for the forum where we can add a little bit more detail right so compiler errors are largely syntactic mistakes the Java compiler is gonna catch things like your variables are named incorrectly you've got syntax it's out of place whatever no runtime errors anything else when we give you a question that has a runtime error on a quiz it's typically something that we expect you to see pretty clearly like you know classic things no pointers right or a null reference like I have an object that's null and I try to dereference it all right a raise that go out-of-bounds if I have a loop that walks off the end of an array and other sort of classic example yeah but yeah so that's a brief answer but I can I can try to give a more full answer on the on the floor it's a good question okay so let's launch back into where we left off and this is an entirely review because I don't think I really drove this home on Friday but let's let's keep talking about static so to review last week we started talking about Java objects and how we can use them to create our own types within the language that allow us to model any kind of data by combining data and algorithms by combining State and behavior so Java object both stores information and it can combine any number of different other objects or prot Java primitive types but also provides functions that I can run right if I have an instance of that object static is a keyword that changes the semantics of either a variable or a method that's associated with the class yeah Oh Greg it's doing it again there we go okay sorry how's that thank you so normally when I declare so and and this is you know one of the reasons we talk about static now is that you see it in some of our examples and it's also a keyword that dramatically changes the behavior of a variable or a method particularly of variables so you know I after helping students over multiple semesters particularly with kind of the next few weeks of homework problems a very common mistake is to have marked a variable static when it shouldn't be or to have not marked it static when it should have been mark static all right so let's look at an example here so I have a course class that I'm creating and down here on line two I have something that looks normally like a variable an instance variable declaration I'm marking it public means that every anybody can access it or modify it without having used a setter or a gatherer it type is int its name is count essential value of zero but I've added this static keyword to it and so if I remove the static keyword every instance of a course object every instance of the class course every object of type course has its own count and if I modify one I don't modify the others once I put static on it there is only one copy of count it now belongs to the class itself so I don't need to create an instance of course in order to access it instead what I do is I can access it directly using the class name so on line 12 this is now valid code and this looks a little weird it's da notation which we've seen before with object instances with class instances but here I'm using dot notation on the name of the actual class itself so you'll notice that I have I have not created an instance of course you don't see the new keyword here at all never created a course object instead what I did is I access the static variable using this terminal so static variables are not particularly used I would argue we're going to show you how to use them they're not that common much more common our static methods so here's an example of a static method again something looks very similar to my normal method declaration in Java on line 3 I have a method called print' name takes no arguments returns nothing that's void public meaning anybody can use it but I've marked it static so now again I can call this function without creating an instance of the class this is pretty the reason why we see static methods so how many people have used the static method recently how many people here have worked an empty one recently okay all of you I suspect many of you have used the static method anybody know what it was the syntax here is the name of the class which is capitalized dot and then some function might have used this it might have been wrong it might have been right yeah yeah so that's a good one that lapwings you told class the distance function that's a static method you call that by taking the name of the class you're never ideas new to create an instance of lat Lang utils you just use lightly utils dot method name what else it's another really really common package that I've seen some of you using on the NP that's that's handy yeah yeah math dot steal math dot abs anybody using those functions yeah so those are static methods math is a Java class and in fact math is Java class that actually as far as I know you cannot instantiate you can't create an instance of math there's something deep about that that mathematicians would probably appreciate right but you just can't do it in job instead what it does is it provides a bunch of helper methods that are useful for doing things like computing an absolute value computing the ceiling function whatever and those are cases where it doesn't really make sense to create an object what would that mean what would my a snap object represent so this is how Java provides libraries that other programming languages might provide for you to use now a library might be just a bunch of methods if I want to provide something like that in Java what I do is I create a class and then I add a bunch of static methods to it so you can now call those methods they can be useful functions that you can reuse through your code like the ceiling function light the absolute value function you guys could have wrote those functions but you don't need to because you can disease the ones that are built into the math class so this is a common a common idea in Java and a common way that we use static functions alright so again static methods now just one thing to point out here is that I can call a static method if I have an instance of that object I don't lose access to those static methods they still come along with every instance of the OP so for example here I've called print name on line 9 using the syntax which is name of class dot function and I can do that because it's a static function if it wasn't static I couldn't do that well we'll get into a playground in a minute we'll play around with this and show you how it works but once I have an instance of course I can still call that function and it will do the same thing it guys hello thanks believe it or not I can actually hear you talking here that's how this room works both a pro and a con all right getting better at figuring out where the sound is coming from all right good but you can also call them on insistence now the fact that you can remember will meet when we talked about our instance methods our instance methods that access to the special variable called this that referred to the instance of the class that was running the method but because I can call these methods in Java without an instance of the class they can't use this there's no there's not guaranteed to be an instance of the class that I can use when the method is running so here's an example and this is a little bit confusing so let's walk through this because you don't see this here right ok so on line 2 I have a variable is this an instance variable or a class variable do you see the static keyword it's an instance variable so every instance of course has its own name but modify one and I modify the others but until I create an instance of course I've got no name variable now print name is a static function so when it runs it's not guaranteed that I'm actually going to have a course instance I might be able to I might have called this directly on the course class and so I cannot access this field you could replace this with this thought name and I'd have the same problem the problem is that name is an instance method sorry name is an instance variable and print name is a class nothing and so class methods cannot access instance variables because there's not guaranteed to be an instance of the class that actually exists so again going back to the math class you can't create an instance of the math class so every time math dot seal runs there's no this it has to do all its work based on its inputs and sometimes that's very useful right because again math essentially includes a bunch of helper methods that don't really need an instance of an object to work all right so because there's only one static variable so if I create a static variable it's only one copy of that variable associated with the course with the class every instance of that class shares that variable and this can be useful so you know here's an example of a potential use for a static variable I told you they're not actually very useful but here's an example of a case where maybe you can make an argument that this is actually used so I've got a static variable that's a type count I've got a static variable to type int named count I initialize that to zero then what I'm doing here is I'm increasing the count and now every acts every instance of this course has access this the way I would make this more useful so I would have the constructor actually increment that variable and so we can do that we'll do that in a minute all right public and private worked the same way on static methods and variables as they do on instance methods and variables there's no difference there the semantics are the same public the variable can be read or written by any one private can only be written by methods owner class same thing with public and private for static methods yeah yeah yeah so the question is if I take off the static variable static on this count variable does that change the semantics and the answer is it does in a big way well let me show you an example of that in a minute in the playground this is one of the things that's tricky about static particularly for variables so if you throw static on to a variable suddenly everything about that classes behavior is probably going to change static methods you know the you know you may get some errors because you can't answer access instance variables but static you have to be very careful with when you apply to a variable all right so these work the same okay so let's let's do some examples here okay so let's go back let me get one and let me just actually pull one of these out you get the count this guy all right I want I want this one okay let's use this as a starting point actually rather than this example which we'll come back to I think it's it's good to do this okay Chuck style is gonna be angry with me so I'm gonna fix this all right good so let's review what's what's on this what's on this playground so I've got a static variable named count then I have an instance method called print' count now remember an instance method can access a static variable a static method can't access an instance variable so let's try to just make sure that that works the way that we would think so it's chained this to be an instance variable I make this a static method so now I get actually a pretty helpful message from the compiler that says non static variable count cannot be referenced from a static context so my function print count is static and so it can't access any instance variables if I try this it doesn't you know essentially this is the problem I don't have an instance of the class okay so let's go back let's make this make this static and let's make the count static so if both of these are static then I'm good so now let's let's do what I suggested before which is that let's make this count variable reflect how many courses have been created in my program so you know I might have a program that's managing like grades for a bunch of classes on campus or something like that and you know when I add a course to my program that I'm going to store information about I might want to be able to print like on the page on the web page for the for the program like here's how many courses are in the system something like that okay so how are we going to do that yeah yeah so what do I know is gonna run every time a canoe course is created the construct right now I don't have a constructor so I have my empty argument constructor so what I need to do is I need to I need to add a constructive to my course and all that's going to do is increment the count okay now down here I'm going to actually get rid of this alright and now let me actually make this a little bit more useful put this print 'land put this print statement here and then we'll do another one after we print both okay so this is working how we thought right and you know if I write a loop here it just creates some courses a bunch of course those are now all oh it's mad at me not you there we go yeah okay so now I create two courses manually and then I have loop that creates a bunch of new course variables and when I'm done I print off I can I can print I can call that static function using any instance of course and I can actually also call it without using an instance of course I can just call it on the class itself okay any questions about this before we go on and have some fun with this example all right so let's do an experiment I need one small change to this program all right so is there going to be a compiler problem here there is so what's that problem going to be yeah yeah so now every course object has its own count the count is not attached to class it's not attached to the instance of the class so if I run this I try to compile it the compiler is gonna give me that error I saw before okay all right well let's say it's like late at night I'm tired I'm just like I'm just gonna make this work all right I'm gonna make it work by just changing this to be not static oh now it's mad at me down here so I've got to change this to whatever I'm just hacking I'm trying to get stuff to work okay so now let me show you again that the power of static this is so I if I put this here it does what I want if I take it off it's no longer tracking the number of courses that have been created the reason is that every course has its own count and so when the constructor starts the count always starts at zero we can convince ourselves with that let's put a little login in the constructor figure out what the count is when the constructor starts running okay if I put static back here now you'll see that the count is tracking the number of times the constructor is called all right so I've got a prob got a problem with this piece of code and maybe you guys can help me fix here's the problem you know I'm like you know I'm working on the last part of cs 125 final project with my partner and I don't really trust them you know like I feel like they might have like used all their homework drops or something so not sure I want them to you know so they might try something like this right so what if what did they mess up and they just modify the count directly so now it's wrong I only get rid of this this is cluttering my output okay so now my count is wrong because I've access to directly from the class what can I do to fix this problem there is something that I can do yeah ah make it private deep yep indeed this will work now it's gonna fail right now just a pile of Erichs I can't access it but let's like get rid of this it's gonna work you yeah so here's an example of a case where using private improves the overall sort of safety of the code that I've written now it's now it's less likely that someone's gonna make a mistake because the only person that can modify count is whoever can change the core the code of the count class right or sorry the course class you know you have to modify the source code of course in order to change this very alright questions about this where we go and then you know if I if I wanted to allow access to it I could create setters and getters and things like that essentially what I have is a getter right why don't we make this a little bit nicer let's create a public int get public static int get count turn count and then let's instead of printing this what we'll do is we'll just say I'll get rid of this guy rid of this guy don't want to write rewrite all these and I think I should do course so now rather than having these with this sort of special print method I'm actually a created a getter for my count variable essentially what I have is to read only count variable because there's no setter for it I don't want anybody else to be able to change it I'm changing it according to semantics that I've defined as part of how my classroom okay good so you know the the one of the reasons I thought about this a bunch of times Alanna yeah you should talk about static it's confusing but let me just give you a sense of what my strategies I think the confusion that occurs when you're forced to work with static a little bit is actually your brain starting to reckon with what Java objects actually mean the fact that static causes something to be shared forces you to think about what parts of an object are shared versus not share and I create an object every instance when I create a class every instance has certain properties that are its own and other properties that it shares with other classes so for example let's extend this a little bit and we'll create a public string name and now you know what actually let's make this private let's have our course constructor set the name all right so now I'm forced to add a name when I create courses let's make up some new courses here yes one oh there you go that'll work yeah so every course has its own name so if I do system dot out now because I made it private I'm gonna have to create a getter for it so let's say public string that name her name and then let's print it there we go we created some new classes actually 107 rd sis 101 already sis 105 already exists 108 could be cool I don't know what's about it anyway but every course has its own name but they're all sharing this count on so again this confusion this this sort of like having a hammer through this a little bit I think will help solidify in your mind what Java objects really are and how classes store information okay couple of other things you know we're sort of doing Java keyword bingo at this point so let's cross another one off of our card final you guys have seen this a little bit when you've been working on mp1 so final is a modifier that I can add to a variable that indicates that it's value cannot be changed ever so I initialize it once and then it can't be changed later in my program now final variables essentially allow us to establish symbolic constants in our programs you can talk a little bit more on the form about why this is useful if you how many people been getting some magic number errors in your code okay this is the correct way to work around those problems is to establish what's called a symbolic constant so now instead of having to put eight into my code everywhere where I'm trying to make a calculation that's dependent on let's say I'm trying to write a program to help you make sure you get enough sleep or not right and I have a bunch of calculations that I'm trying to do to make sure you got enough sleep and maybe how much sleep you should be getting and the average over the week or whatever but I know that the program needs to know how much you're supposed to get so one option is to just stick the number eight all over my code but then if somebody's reading it they're like why is this value eight here as part of this calculation why is it the denominator in this in this computation if instead what I do is I establish a kind of symbolic constant so I do this by saying using final so everything else here you've already seen this is a variable this part looks like a variable declaration this is a type int this is the name then name looks different talk about that in a second this is the value but now I'm saying this is static there's only one copy of it it's almost always true for final values and public anybody can read it now it's final so they can't change it and final so the final indicates that it cannot be modified I'll show you in a minute if I try to modify value that's final it won't work the compiler will catch this you can play the names of constants in Java have a different format than the variables that you used to see so normally when we use variables they start with a lowercase letter and we use camelcase constants the convention is they are all uppercase I think this is called there's a name for this it's snake case but it's like there's a special name for it because it's all capital so snake case is used by language just like Python it indicates that you break words using underscores and then the all capitals I think then look this up once maybe one of you guys can figure it out so it's like angry snake case because they're all capital letters the reason for this is because when you see something like this in your program you know what it is you know that this is the constant of some kind right now if someone's reading your code and they see hours per night they see you know amount you got - hours per night they see oh this is a computation that's trying to figure out if I got enough sleep right and it's using this variable the other nice thing about some outlet constants is let's say that a year from now there's new research that comes out that says you should really be getting nine hours of sleep or 10 or six or whatever then instead of mucking through my code and trying to figure out every time when I used 8 was it actually the number of hours of sleep or was I using it for something else I just make this one change so I could take my code I can change hours per night to nine or seven or whatever the new data indicates rebuild my app and it's good to go okay so again the compiler will enforce this for you right so once I've established that hours per night is eight there is nothing that I can do to change it the compiler will not allow me to modify it I take that off it's gonna complain about the other one it's no way to change okay final static final questions before we start talking about something else final it's not particularly difficult to wrap your mind around I don't think our homework problems this week are designed to give you practice with static but again you know here's one way to solve some of these homework problems try it with static and then try it without static and see which one you get credit for it's not particularly useful right particularly when you think towards the future and it's like try it with static try it without static see which one crashes when I'm demoing it as part of my IPO and my company loses billions of dollars evaluation right so I do want you to think about what's happening when you when you apply these keywords and part of your code right not just blindly make changes question ah great question so what does it mean to make a class final I like this question and I'm going to briefly stop here because it's it's a really it's actually a really good question okay so let me create an empty class here called test I'm gonna destroy this example and I'm gonna say test test as you build a new test it's pretty boring right I have an empty class oh-oh it's mad at me there we go okay let's find out oh okay Chuck Stiles mad textile wants me to put public final here okay so that works you wouldn't have any you have any questions about what it means for any any clues about this finally yeah so what this is a good segue into our next topic right and so I'm gonna come back and we will talk about that again keep that in your mind but the way I want to introduce us to our next topic is to pose a conundrum so how many of you I mean just ask a general question how many of you is you've been working on one of our impedes have encountered something about this hopefully this is all of you that you didn't understand something that behaved in a way that you couldn't explain okay good so when you are trying your travels through the world of computer science you will have moments when something does something that you don't quite get it might behave in a way that you didn't understand I do something you didn't expect to do now sometimes the thing that's doing is something that you don't want to happen and there it's like bogging you just fix it you move on your life but there's other times when there's something going on there's something this indicates that there's something about the world that you don't understand so let me show you an example of something like that right here okay so I've got a public class example remember our new examples work so that they all start in the static main method that's defined in the example class but examples just still a class so I can create a new instance of it which I do on line four and then on line five what am i doing someone walk me through with that line of code does so at this point I have a variable called lower case example it's a type example there's nothing interesting about it yet I haven't created any you know incidence variables or instance methods I'm just getting started with this but well let's try running this first okay all right ignore the output the output is a red herring what's confusing about this what about this should challenge your idea of what we've been learning so far something's wrong with this there's something that is something we just did does not line up with what we've been discussing yeah yeah great so I'm calling a function on this instance of the class I've got an instance called example all good but I haven't created any instance methods or instance variables so why can I use this dot notation here and call a function to string there's no function to string do you see a function to string I don't so why does this work it's a couple of other things I can put in here as well that will work the other ones are I'm not gonna go into yet okay but this doesn't make sense okay based on what I've told you when I set up the class it's a blueprint I'm supposed to define how the class works and this example class has not told me what it means to call this to string method so why am I allowed to call and it seems to have like semantics so like let's try passing a variable to it okay now that doesn't work and the error message is actually starting to give us some clues about what's happening okay so the next big topic we're going to start talking about today and continue on Wednesday is one of the fundamental organizing principles about how we set up classes in Java done right this can really simplify your code and make it easier to understand and reason about it's also something that reflects the nature of real world entities and this idea is something called inheritance so in Java a class can inherit behavior and state from another class okay I typically do this to set up relationships between classes that reflect things about the world all right so here's an example on the top and you're not going to understand all this yet but in a couple days you will on the top I'm declaring the class called pet it's kind of normally this is pretty much what we've seen already public class pet I've got these two protected variables and we'll come back to that in a minute but these are essentially instance variables a string name and a string type and then I have an instance method called print' me that essentially prints a formatted message with the name and the type to the console now on line nine I have something new this is another place where we're introducing new terminology new syntax that allows us to work more effectively with java's class system Java's object MA on line nine I'm creating a new class called dog so that part I understand public class dog so this is public anybody can use it it's class I'm setting up a new type in the language dog is my name it's capitalized because I capitalized the name of classes what comes next is due so I have a new keyword you can see it's highlighted in purple like other keywords extends pet a extent this is how I establish an inheritance relationship in Java so essentially what does this mean so it means that dog wants to inherit state and behavior from pet when I say I'm going to extend another class what I'm saying is I'm gonna use that other classes blueprint as a starting point for my class and then I might want to add some stuff to it or I might want to establish you know certain semantics about how it works so my dog class right now doesn't actually add any variables to pet but it does provide a constructor that sets the type of the pet properly for this type of pattern okay so the other thing that I can do now I do inherit the name and the type from the pet class so you'll see here in my constructor I'm studying the name and the type I have not declared these as instance variables as part of my class the reason I can use them is they're declared as part of pet and I've declared that my class dog extends pet I also inherit any public or protected behaviors from pet so for example the print me function print me was defined by pet but if I have an instance of a dog I can call that method I'm inherited the state and behavior from my parents all right so let's establish some terminology quickly before we're we run out of time today so in Java I create an asset I establish inheritance relationship using this extends keyword so when I declare my class I am allowed to declare that it extends one class one at most one this is different than other languages there are other languages that support multiple inheritance Java does not okay one class when you extend a class you inherit its public state and behavior so any public or protected instance variables you have access to those any public or protected methods you have access to those private stuff no we'll come back and flush this out more here what I've done is I've created two classes that inherit from pet so a dog is one kind of pet and a cat is another kind of pet now you might quibble with me and you might say well the dog is really actually a species of wild creature creature some dogs are pets and some dogs are not pets there are definitely wild dogs out there that you would not want as pet same thing with cats right some cats are pets I'm not sure that well anyway you can keep people disagree about whether or not you ever want a cat as a pet but there are some cats that some people think make nice pets and then there's some other cats that clearly do not make good pets but anyway but this is how we're gonna model this this might be an app that we're using to you know help you know set up care for people's pets right there's a couple of startups that are trying to do this today once we establish inheritance relationships between classes we have some terminology that we use so we call pet the parent of dog and cat and we sometimes call dog and cat pets children okay I can establish multiple levels of inheritance in Java next time I think this later this week we'll look at a tree a data structure or a visualization that allows us to see this a little bit more clearly but here I have a case where I dog extends pet and then mutt extends dog so mutt is a type of a dog which is the type of a pet mutt inherits dog's behavior in-state dog inherits pets behavior in state and this relationship is transitive so mutt inherits behavior and state from pet through dog okay right sometimes we refer to dog and pet as mutts ancestors and we would refer to dog and mutt as pets descendants so these are determinate these terminologies are drawn from family treats right okay where am I I think I'm um I'm a little cell type I think I'll come back and do protected next time okay well actually you know what I have a minute here so I've started to put protected on the slide what is the what is the intention behind protective the goal behind protected is to allow access to a variable or to a method to be determined by this inheritance relationship so public anybody can read or write the variable private only methods to find on that class protected the variable can be read or written by any descendant of that class any methods on that class or any methods on classes that descend from that class a protected is actually a little bit more complicated than that I'll finish up with this on Wednesday and we'll continue to talk about inheritance all right so just a couple of quick announcements there is no coders chapter on this week's quiz chapter 4 for next week I'm so confused by that easier than the questions that it's replacing all right the autograder is working again you used that to check your scores on mp1 I would have appreciated a round of applause for the autograder god for coders see you guys on Wednesday  
﻿ hey back everybody you guys had a lovely weekend it's beautiful out this wasn't Chicago so beautiful day today and a great day for us to slow down for a minute we have some stuff to finish up from last week particularly polymorphism which is a topic that will continue to look at in the future so if it's not quite clicking yet that's okay don't be discouraged we'll see this again and again we're going to talk a little bit more about polymorphism today with some reminders about how we can change the view that we have of a particular type of Java object and we'll show some of the implications of looking at objects in different ways right looking at an object is a capital o object right that gives us still allows us to do some things with it but then if we look at it more specifically as the instance of the actual class that we created it as we have some more features that come along with that view okay so that's what we're gonna do today and then we'll do some problems at the end it's kind of a you know a slowdown break object review sort of class but the first thing I want to I want to just talk about since I know that people are frustrated is how many people here have been frustrated recently with this class with the NP okay good so let me let me talk about that a little bit so frustration is a feeling it's an experience that often accompanies another thing that I want you to experience in this class which is learning it's not it's not easy to learn new things I was just reading a an interesting study about some experiments that they did in the physics class at Harvard actually what they found was that students perception of their own learning was actually inversely correlated with how much they were actually learning and you know part of the reason for that and you know I teach class in a somewhat traditional way and I'm up here talking and I make things sound all easy and nice and Chris been clear I hope that's my goal but then you sit down and you have to do the homework problems there you have to do the MP and then you might get stuck you might get frustrated and you know really again I just want you to understand that's a moment where new knowledge is entering your brain that's a moment where new information is taking root right you're building these new mental pathways that are going to be there in the future now I have so that's the good news okay the bad news is and I hope you know as you guys were reading coders you're getting some sense of this frustration is not something that goes away in this field in this profession in this world that you guys are entering into this is something that you will still be living with ten years from now 20 years from now something that I still feel on you know a fairly regular basis you know with my own work with other things that people do around me whatever but specifically this frustration with programs not being able to get things to work the sense that it all seems so easy when I started and then it got hard and ugly and gross and had to make do things I didn't want to do to get the system to work I was trying to build or whatever okay so why don't we take just a few moments I don't want to spend too much time on this but what do you guys do when you feel frustrated I guess coping strategies anyone share something you know when you get frustrated you just keep going just feel frustrated so I think you guys do that helps yeah yeah so take a break and that break can be a break from the MP entirely work on something else you got some other classes do a little bit of homework for something else you know write an email to an old friend at home you know check social media for 15 minutes that's okay but there's another way of taking a break which is to kind of step back get yourself out of the immediate problem that you're trying to solve and try to think a little bit more about kind of what am I trying to accomplish here I didn't is there a better way to approach this when I was when I was learning how to do this and so I I'm sort of we'll see how this goes actually this is a great story to tell here but let's let's see what happens so one of the first courses I took that really got me hooked on this was a really programming intensive course on computer operating systems and so I used to I had bad study habits which I don't encourage you to replicate but I used to set aside like an entire night each week to work on the assignments for this class which were known to be extremely time-consuming so I would go down the programming lab and I would just plan on being there until morning again this is not a good idea all right but along the way I would need to stop and take a break and so I developed a habit a bad habit and I'm not gonna say exactly what it was some of you can probably guess this is not a good habit to develop I'm not encouraging you to do this but the habit that I developed forced me to periodically get up out of my chair walk up from the basement onto the ground floor step outside into the fresh air and be there for like 10 minutes doing this bad thing that you none of you should do right even if there's new ways to do it that are like cool or whatever right yeah not good clearly not good right now we're finding out more about this so anyway don't do this but the break was really helpful you know a lot of times I would find myself me back thinking okay you know just it gets you unwedge right now I can I can see the problem in a new way so that's a nice thing to do again don't develop bad habits associated with it have a cup of coffee years that's a better better original make yourself a cup of tea what else anything else that people do to to deal with this for us this feeling of frustration I'm you know one of the reasons we're talking about this is like I said just to prepare you for the future because this doesn't stop this it's not something that ends here this is something that you're going to continue to experience throughout your life and so coming up with some good habits and good practices for dealing with it it's important who else has an idea suggestion obviously no wrong answers here yeah ask for help yeah post on the forum come to office hours you know it's much more fun how many people have realized this semester it's much more fun to be frustrated with somebody else than it is to be frustrated by yourself right maybe the person you're frustrated with this is a CA maybe it's a TA maybe it's me if I'm helping you on the forum whatever might find a frustration buddy then it sort of becomes funny sometimes right or at least you have a sense of camaraderie right you're not alone in this you're not alone going through this and again one of the reasons I'm spending a few minutes to talk about this today is that this is a feeling that does not stop so first of all if you're feeling frustrated from time to time don't assume that that's because you don't know what you're doing don't assume that that's because you're bad at this this is when you are learning this is when you are actively learning something when you're just cruising along and everything is going great that's when you're applying the stuff you already know when you get stuck it means you've encountered something that you don't know how to do you will learn how to do it you'll get practice doing it the first time it'll be hard the next time it'll be a little bit easier the time after that you won't even notice that you did it okay good so let's go back talk about polymorphism which we started talking about last time we met which was last Wednesday so anjaana's object model we can allows us to look at instances of classes in multiple different ways the term polymorphism is a more general term in programming languages and the more general definition is this idea of the provision of a single interface two entities of different types and so what we're looking at when we look at Java objects and how they can behave in different ways depending on context it's actually an instance of a broader idea that will actually see another example of today you've already seen polymorphism you just didn't realize what you were looking at we didn't call it what you were looking at now we're gonna go back and look at another instance of polymorphism you're already familiar with and then in the future when we talk about generics in like a month or so you'll see another form of polymorphism that also exists in Java but let's talk about class-based polymorphism so remember even if I don't inherit explicitly from another class so we looked last week at inheritance relationships with Java objects that I can establish through the extends keyword and that allows me to inherit the state and behavior from another class and this is actually really powerful because there's a lot of cases in which multiple classes share similar functionality and rather than duplicating all of it in Class A in Class B I can refactor my code so that there's a single class that both of them inherit from that contains all of that common state and behavior that they both need then by inheriting from that class I can still customize things if I want I can add new methods a new state and we also saw last week how if I don't like the way that my parent or one of my ancestors has defined a particular method I can also override it in my class definition and provide my own implementation that works differently there are some restrictions about exactly how I can override things but I can still do this alright so these are this is these are sort of a lot of the desirable features Java's class model but because of this every java object is actually except one except capital o object that every other Java object is really actually can be thought of as an instance of two different types at least two potentially more whatever type of object we created it adds and then capital L object so in this particular small inheritance relationship that I've established on this slide I have a class called pet pet does not extend explicitly any other class but that means that it extends capital o object and then I have a second class called dog that extends pet so pet adds the print me capability to the class so pet provides this function called print me that returns no arguments and prints a string to the console it's kind of a you know silly example and then dog overrides that method so dog inherits that method from pet if I didn't provide my own implementation I would get a method that printed I'm a pet but I've decided to be more specific about what kind of pet I am and so I provide an implementation that says I'm a dog okay so here Pat is also an object and then dog so pet can be thought of can be morphed into either a pet or an object I can treat it as either a pet or an object a dog actually can morph into three different classes it can act like a dog it can act like a pet and I can also also act like a capital o object so Java objects can morph into or be considered as instances of themselves but also of any of their ancestor classes all the way up to capital all object okay so what does this mean in practice okay so this is very theoretical up to this point the last time what we saw is that if you take an object in Java and you want it to morph into another object that it can automatically become so everything can morph into a capital o object every Java object can be treated like a capital o object Java will do that for you automatically so this was one of the places last time where we saw something mysterious that we hadn't seen before and didn't understand because I have a print anything function here and I've signed understand what the modifiers mean it's public static void so it belongs to the class it doesn't return the arguments anybody could call it it takes as an argument something of type capital o object call to print and it calls the to string method on that capital o object okay so so far this is very similar to stuff that we've already seen except for the fact that the code on line 11 and 12 will actually run we we experimented with this last time in the playground we saw that it works and that is strange because choo-choo is a capital D dog it's not an object this is a cat it's a capital P pet she's also not an object but I can pass them to a function that takes the capital object as an argument because Java will automatically morph them into a capital o object because they inherit from object we'll see why this works in a few slides so again this will work fine okay so I can say you know I see and I see that when I so here's the other thing but I want you to notice about this it's really important I'm calling to string the default to string implementation we remember produces something that looks like this it's the name of the class followed by an @ sign followed by this thing that looks like a memory address or something just a random sort of hexadecimal string dog decided you know whoever wrote the dog class decided that they didn't like the default to string implementation and you shouldn't either it's rarely very useful so they overrode it in their class they provided another implementation of to string that matches the default object one has to have the same signature so it takes no arguments returns the string and its public and all it doesn't return the string dog so here's what's interesting when these are passed to print anything they are being up casted to an object but when I call to string which I'm doing in the print anything method I'm still getting the dog to string implementation when the object that's passed is a dog so the first time I call this I pass it with the dog and I get the dog to string of application the second time I pass it with the pet Pat hasn't overridden to string if it did so we can do this we can say public string to string return I'm a pet and now you'll see again that I get the over ridden to string of limitation just because I'm treating it like an object just because it's morphed into an object for the purposes of being able to be past that that's print anything method doesn't mean that Java has forgotten what kind of object it actually is so again instances retain their types when they pass even if I morph them into another type of Java object even if I look at them for the purposes of a function as something that's an object Java still knows that it's a dog it still knows that it's a pet and so it still can use that to figure out which two string implementation to use when print anything runs okay so so again same same thing here so here's another way I can do this and this is gonna make more sense later this week when we talk about object references but for now you can think about this as working as follows on line nine I create a variable called choo-choo of type dog I've defined a dog class up here that extends pet which extends object so I create a new dog with variable named choo-choo on line nine on line ten again what's this gonna make more sense later and I really you know again this is one of those places where there's like a circular reference in Java you can't get away from but here what I'm doing is I'm saying okay let's create a new variable called choo-choo as object that's of type object and I'll assign choo-choo to that and I can do that so now I have a variable that's a type object but if I print it I'm still gonna get the dog print the to string method okay another thing too another thing that's interesting here is when you call print 'ln you don't have to call to string on the object it'll do that for you so I'm just passing an object in I can also now take choo-choo and look at you chew like a pet at which point I can call print line on that pet object but I still every time I'm doing this I'm still getting this two string method that's overridden in dog because even when I morph my dog object into a pet which I can do because it extends pet or into an object which I can do because it extends a class that extends object like every Java class even when I do this it's still Java still remembers that it's a dog ok so essentially what we're doing here is a form of casting remember before when we cast we could we talked about casting different primitive types to each other so I could take something that's an INT and cast it to a double just like casting primitive types there rules though about how I can cast Java objects so I can always cast Java objects to their ancestors so a Java object can freely morph into one of its ancestors so if I take again dog I can treat dog like an object without doing have having to do anything special if I want to down cast an object so let's say that I have something that's an object but I know it's actually a dog then I need to do more work because here it's it's not clear that this is something that I can do it's possible that this is going to be unsafe so we'll look at an example of this in a minute so here now on line 9 on the so this is another new piece of syntax so on the right side of line 9 I'm creating a new dog but on the left side I'm saving it into an a variable of type object so even in this one line of code I'm doing an up cast I'm taking something that's actually a dog and I'm saying I'm gonna work with it as if it's an object I can call print anything on it because it's an object and that's gonna work now if I want to let's say I want to treat it as a pet so pet is one of the types of object that a dog can morph into I have an object variable here and I want to treat it as a pet I can't do that automatically I have to do this explicit cast that you see here on the right side of line 11 and I'll show you why in a minute because this doesn't always work now here I can do that because we know that Chuchu is a dog dog inherits from pet so Pat is one of the types that choo-choo can morph into the dogs been formed morph into right so again this will work okay right so I'm gonna print choo choo at the beginning as a dog as an object then I'm gonna downcast you to to be a pet on line 11 and now I'm gonna downcast choo-choo to be a dog on line 13 okay so I can do this through this explicit cast where can this go wrong who can give me an example that causes this to fail so I have something that's an object I know because I wrote this code that the object is actually a dog so I know that it's safe to do that down cast on line 11 I know it's also safe to do the down cast on line 13 but who can give me an example of where this will break okay choo choo can choo choo is a dog he's an instance of the class dog he can behave like a dog you can behave like a pet you can behave like an object also the classes that he can work into what is one class that we work with sometimes in Java that he cannot morph into string okay let's try this let's take let's change line 13 to say okay I'm gonna treat you like a string and this will not work now I get a this is a runtime error okay this is another one of these errors that you're gonna start to see as we work with by morphism that says this is a class cast exception and it says dog cannot be cast to a string right so I can't you know again there were three different classes that choo-choo could morph into you can morph it to he could he is a dog you can morph into a pet and he can act like an object strings not on that list so there's no way to take something that's a dog and force it to behave like a string and you know to some degree that makes sense right choo-choo is a dog he doesn't have an array of characters so there's really no way for him to behave like a string okay let's let's uh let's move onward so if you want to so Jonna provides some features for working with polymorphism and inheritance at runtime to make things like this safe okay and you'll see this when we start to do equality methods in Java we're going to start to have you guys write equality methods for your Java classes so how do I determine one and what what an object's actual type is let's say I just pass through an object but you know that it's not actually a capital o object it's something else Java provides another keyword called instance of that allows you to test whether or not a particular variable is an instance of a particular type of Java class so here I've got set up my you know something similar to what we've typically been using when we've been talking about inheritance I have a dog a pet class and then dog and a cat that extend pet now I'm creating two two objects here one is a dog the other is a cat but I'm gonna treat them both like pets I have two variables that are a tight pack so now the question is how do I find out more about these I know once a dog and I don't wants a cat but what if I pass them to a function that didn't know that and so I can use this instance of operator to say is this variable actually an instance of a dog that'll print true and I can test it against pet which would all print true which is obvious because it's a I'm treating it like a pad and then I can if it's not it it's in that type of object then I can then all return false so this allows you to determine whether or not you can whether or not a particular variable a particular object that you're working with can morph into a certain type of Java class or not and this allows you to do things safely so for example back here I could say if choo-choo instance of string then and only then it's going to get mad at me well I treat you like a spring oh don't be don't be so angry thicknesses all right it's anywhere with me but I could do this all right so here's an example of that and again let's let's test shoot you to see if you choose a string this is now going to print false oh I know they got to use Java to find out string all right something okay yeah I know there's something wrong with this example alright let's go on alright so so this is something I throw out at the very end of class last time and I just want to make sure that we get through this because you know we don't have too many opportunities in this class to actually look at theory here's one of them all right and this is again this is not only a chance for us to connect a piece of theory about how programming languages work but also a chance to recognize you know a great living computer scientist so there's this principle that job adheres to write that Java is type system in class model adheres to which is something called substitutability and the idea is that again let's look at this carefully if s is a subtype of T okay so in that in our world that means if s extends T all right s is a subtype of teeth then objects of type T may be replaced with objects of type s without altering any of the desirable properties of T okay so this is again I mean that this is a very theoretical definition so we have to kind of slow down it and try to make sense of this so what this says in job is I have a class that extends in other class I can take objects of the parent and replace them with the class that extends that class and the goal is that I shouldn't you know lose any of the desirable properties of the parent class and the reason for this Java is because the classes inherit those features from their parents or their ancestor classes okay one of the things that's interesting so here's an example of this everything in Java is an object and when we talk later in the class about some of the data structures that we're gonna build together like lists and hash maps and things like that we're gonna see how there are only a couple of methods that we know that every Java object is going to have because they all inherit from capital object to string is one of them to string is one that we use in a a lot of examples but in a practical sense it doesn't turn out to be useful for that much other than debugging but there's several other ones there's equals there's hash code and those turn out to be extremely useful when we talk about hash code this is going to allow us to build data structures in Java that we can use to store any type of Java object we don't need to know anything about what we put into this data structure all we need to know is that it's an object in Java because every Java object has these features so this is substitutability in practice this means that I can again I can build a general-purpose list eventually you know you guys were upset with the limitations of Java arrays and I don't blame you eventually later at a couple of weeks in a month we're gonna build our own list and you guys are gonna start to do some problems working with Java's built-in list classes those classes can store any type of Java object the reason is substitutability when we talk about Maps right which is another super useful data structure those can store in Java any type of Java object and the reason is subject you to build the reason is that every Java object inherits a small number of desirable features from capitulo object and so I can take capital object I can replace it with any other object than inherits from it which is everyone in Java and I can still maintain those features so again this is an instance when we talked when we started out the class we talked about polymorphism and I said this is this is a design principle that manifests itself in several different ways in Java they're actually three I think maybe even four different types of polymorphism in Java this is something called subtype polymorphism right we know that every java objects going to provide to string even if jeffrey yob java object can implement it a little bit differently so there's this both this guarantee and there's still this flexibility about how exactly I get things to work okay so on some level what we're looking at is same name different behavior so any job object I can call to string on what happens may be determined by the actual type of Java object that I'm calling the method on we've seen something like this before something similar where the name was the same but something else about the information that I was passing you know when I was you know writing the code was providing context so I've seen a case before in Java where I can have the same name for one to ten different things but they could behave differently guys remember what that was yeah yeah function overriding remember this guy same name some potentially different behavior depending on in this case what the arguments are now in this case you know usually when I use this for functions I want them to behave similarly right if I have two functions called sum and one actually doesn't sound than the other you know does a product then it's confusing but here I can write as many different versions of sum as I want and they can all work differently if I provide them with different arguments that's how Java distinguishes between so this is a second type of polymorphism so subtype polymorphism a single method can act on all of you know a particular type of class right so a single method to string can now be called on every descendant from object this is Method overloading a method can behave differently depending on the arguments that I provided and the third type of polymorphism we'll look at Java and Java something called generics but we'll get to it towards the end okay any questions at this point before we do some examples yeah oh I yeah so okay great question so know what is our ask that question before it's a really good question so the question was what's the distinction between overriding and overloading so a Java I overload a method by providing multiple implementations with the same name that take different arguments I override a method that I've inherited from one of my ancestors for by providing the same method that takes the same arguments so I can understand why this is confusing right overloading it's like I want to have five different versions of some that are all defined in the same class overriding is object and find to string but its implementation isn't very good and I have more information that I like to provide when someone tries to print me out I'm gonna over override that method now you're gonna confuse me about which one is what I'm gonna try to keep it true yeah great question okay so let's go through some of a couple of recent homework problems we'll do this one quickly and then we'll spend a few minutes with last ten last ten is like a classic CS 125 more problems on my favorites alright so here was so we're getting to the point now in the class and this is a fun point right we're from now on what we're gonna ask you guys to do is be designing classics pretty much here from here on out we're about halfway through the homework problems I think I think this week we started with number 33 I think we go up to like 65 or 66 we're about halfway done the homework problems the class design homework problems you know the one thing I would encourage you to do very very you know how do how do you approach these read them right and literally you can see like bits and pieces of the structure emerged from the description to find a public class name flip okay well I've got the first line of my code public class flip it's a single public instance method called flop okay I've got public flop I don't know what it returns but it sends returns a boolean okay public boolean flop alright does it take in the arguments nope okay so I have another line of my object right and then it gives me some information about a what and then it'll tell you about a constructor alright so now I need a constructor it takes a boolean argument so capital flop or is it flip capital flip takes a boolean argument sets the initial state of the flip instance so that also gives me a clue about what the state is that this class needs to store one of the things that we're going to do and this is going to frustrate some of you I get complaints about this for some of the quiz questions that we have coming up when we give you a problem like this we will typically not tell you what state you have to store we will tell you how the object has to behave but we didn't say here store a single boolean a state you know that's that's up to you to figure out with this particular instance there's the big clue because it says it takes a boolean argument that sets the initial state of the flip instance so there's a strong clue there just in the problem write up that the initial that the state that this class of story has to consist of at least a bully but in general we're not going to tell you how the state in the class has to has to be set up that's for you to figure out and for you to design that's kind of what's fun about these problems to be honest we told you exactly what state to store and how to manipulate it it would pretty much just be like translating the English description into code alright so let's do flip alright so I've got just a little I've got some example code here set up that will be able to run in a minute so like I said I've got public class flip that comes from to find a public last name flip but the single instance method the instance method is called flop takes no arguments and returns a boolean public boolean flop and let's just let's just fill this out for now just with a dummy value right now I need a constructor you have a constructor called flip this is the syntax of my constructors generally that constructor should take a boolean argument I'm gonna call this initial state and that should set the initial state so again now I'm getting a clue that my initial state should be okay all right there we go so now I've got my constructor that takes a boolean sets the initial state I have a the class and now all you need to do is figure out what to do in flop so it says flop changes the state from false to true or true to false and returns the new not the old state so if the class is created with true the first call to flop should return false it should change true to false or return the new value the next call should return true so this essentially just toggling things back and forth between true and false so how am I going to do that I'm gonna say state is equal to okay so you know you could write this differently this is probably the most know concise way to do it all right and then I wrote a little bit of testing code just to kind of try to make sure that things are working okay one of the things I would you know suggest you to that you think about whenever you're doing this type of thing is making sure and you know when you guys are working on the homework you can do stuff like this use the playground if you want to it's not not a problem I mean you know no one no one cares you guys write the code eventually has to go into prairie learn but you can use the playground while you're working to do stuff like that so each one of these is supposed to act independently and to test this I've created two of them I've created a flip instance called flip that starts out true and then I've created a flip and since called flop that starts out false and in each iteration through the loop I'm calling I'm printing the result of Coleen flipped out flop first and then flop top flop it's a fun I feel like I'm dr. Seuss up here this is a fun problem to try to talk to him okay so let's just look at one instance for now when you comment this out okay so the initial state of my flip is true the first time I call it it's false and then it goes back forth between false and true and false and true good now let's just look at my flop so its initial state is false and first time I call it it's true and then it's gonna go rotate back and forth between control why is it important to use two different instances here for testing what mistake could I made here that would cause me to get in trouble for last week we talked about a particular Java keyword dangerous makes a big difference in behavior it's another problem with this java keyword which is that sometimes it will it will make it look like things are working yeah static all right so let's see what happens if I've just decided because I just like chaos and mayhem let's throw a static on here hey it works it's awesome okay so that looks good now let's so my flop looks good just not edit random parts of my code let's look at my flip also looks good I'm good right it happens when I look at both of them together now I have a problem so let's look at what happens to my flip I call flipped out flop the first time I already get back the wrong value all right I'm supposed to get false I initialize it with true I'm getting true and then I get true every time okay let me just for fun let me call flop dot flop and I print the result and just show you that this is clearly broken right I'm getting the same value back every time so again one of the dangerous things about static is that a lot of times it'll make your code look right if there's only one instance of that class because as soon as you have two or more they're sharing that state in ways that cause their behavior to be incorrect okay good so those are little warm-up now let's do last ten so I'm not gonna labor here on the definition of last ten you guys knew you guys did this you guys saw the write-up let's just get to work okay so I'm gonna sketch out the bones of this from the description okay I need no comeback I need an ADD method and I'm just gonna have that do nothing for now and I also need a it get last ten method that returns an array and I'll just return null for now just to get this to compile okay oh I do so let me let me look at it let me point out some of the common mistakes that people made okay so here's one of them well we're so sorry this is flip flop let me go forward what's what state do I need here now again we did not tell you what state you needed but what state does this class need at minimum one piece of state this class has to store yeah an array of integers I'm gonna be hard-pressed to remember ten integers without an array of 10 integers so let's put that in there let's say and now just because I'm designing this the whole 10 I'll initialize it to be 10 ok so here's one thing that that people did they did something kind of like this they said ok so I'm gonna go through my array I'm gonna say if values is equal to 0 now use is equal to new value all right so essentially I'm going what am I doing here I'm going through my array and I'm looking for a 0 and that's where I'm gonna put the new value that I'm passed this is a common first attempt first approach at this problem why doesn't it work someone who hasn't contributed yet today it's wrong with the supplementation this could work you could work in another setting yeah what do you think yes okay so there's the first question is what happens when I get to the end let's say I give you ten nonzero values what happens after that I don't have a story for that yeah okay but but there's something else wrong about this this will fail even before I get to ten yeah we're in the problem description did it say that I couldn't add zero to the array I'm allowed to add zero I can add any integer I want so imagine that the first value I put in is one so you do the right thing and you put it in the first spot and then the second value is zero and your code is still going to end up doing the right thing it's still going to put it in the second spot index one of the array but then if I call it again you're gonna overwrite that value so there's no value so here's the problem you have no way to distinguish between parts of the array that contain valid data and parts that don't there's no special value that you can stick in to this array that'll allow you to figure out based on the value in that position whether or not the position is occupied or not right you might have got did anyone get away with this with the autograder you might have been able to get away with it right if you chose like a really big value or something like that right maybe you would have got lucky okay zero definitely didn't work right but maybe you filled your array with like some massive value and autograder didn't randomly choose that value and so you got lucky okay but in general this is not going to work so what is this what is this telling us this is hinting at something about the problem if I just have the array I can't figure out which values in it are okay to overwrite I essentially don't know what the last ten values I added to the array are I can't figure that out just by looking at what's in the array if I add 10 zeros to the array then I expect to get 10 zeros at what do I need here so again when we asked you to do these type of class design problems we're not going to give every piece of information there's something missing here what is that missing piece Genisys the the the solution here is totally up to you to design but who can give me a step in the right direction yeah okay we're on the right track here then um so I'm always adding one number at a time but I like where you're going with that response what else do I need I need another piece of state what is that gonna store yeah yeah so essentially I need to this class needs to remember where it put the last value and there's actually two ways to do this problem one is to remember where you put the last value and the one is to remember where you're gonna put the next value right so this will both work okay so in addition to my values I also need an index here I'm gonna use this index to store the place to put the next value that starts at zero that's the first line I'm going to use and then as I go through I increment this as I go all right we're out of time we can go back and finish on Wednesday but probably let's discuss it on the forum good luck on this week's quiz there are questions from coders chapter 4 on there ooh I will see you guys all on Wednesday  
﻿ better okay great anyway so I heard that our football team did something unusual this weekend so that was exciting congrats to them today we are entering a new phase in this class we have six weeks left roughly at six and change and it's time to start digging into sort of the deep conceptual heart of Pewter science we brought you up to speed with the imperative and object-oriented programming skills that you need at least to bootstrap this discussion that we're gonna start to have because this is the cool stuff it really is I look forward to this day you guys don't know yet what's coming so maybe you don't but this is the point at which things start to get really fun because not only is the material that we start to get to talk about a little bit more interesting I think it's more core computer science material this is what differentiates between computer sciences and programmers these are the deep conceptual concerns of the field not just the tools and the skills the deep questions the interesting problems interesting things to think about but it also is a great way for us to get practice using those imperative programming skills and those object-oriented programming skills you guys have been developing for the past eight weeks so today the third part of this class we are going to talk about algorithms and data structures so that's essentially going to take us from now until the end of the semester you have one last quiz this week on interfaces in the CBT F that starts today and then next week you will have a midterm exam on object-oriented programming that'll cover everything from the second sort of unit with the class and then after that point we'll start with some work on algorithms and data structures so we talked about this at the very beginning of the the class but we haven't had a chance to get back to it but this is gonna be one of the things that we're gonna be talking about starting today is you know and again this is if you think about computer science as a conceptual discipline as an intellectual pursuit this is right at the core of it right algorithms and data structures how do we solve problems in this methodical systematic way that we can then show a computer how to replicate for us right so you know an algorithm is some sort of problem solving strategy that we can then replicate and implement and show a computer how to do right it's especially something you know again we look back at the word history of this word the history of the usage of this word and it really started to take off around the time computers started to be something that we were being using to solve problems so an algorithm is a very specific set of steps a process to solving a problem now one of the things you know and and this is a hard distinction to draw right now because you guys are only said only seen Java and that's the only programming language that we're going to use throughout the rest of the semester I promise that I won't drop some Python in or some ruston or going just for fun but there is a difference between the algorithm and its implementation okay we are going to implement a bunch of you know interesting data structures and algorithms using Java but the Java implementation is not the algorithm the algorithm lives outside of your code your code is a reflection of the steps that the algorithm prescribes your code is the translation of that algorithm into Java and you could also write it in Python or in C++ or in D or whatever I mean you can take an algorithm and actually you can find websites that do this where you know they have a classic algorithm and then they have implementations of that algorithm in like every programming language known to man and so again the algorithm it's the set of problem-solving steps and when we talk about algorithms I'm you know we'll be looking at Java code I want you guys to try to remember but what we're really doing is talking about a series of steps that we take to solve a problem we happen to implement those in this class in Java but that doesn't that's just a result of the fact that that's the language you guys know a little bit at this point okay so now again what we do is computer scientists frequently is we implement algorithms that's what we're going to start doing now that's what you guys are gonna do into twenty five that's what you guys are gonna do downstream and some of your other courses we're gonna learn about an algorithm and its properties in the abstract because if you can talk about an algorithm outside of the implementation and then we're gonna implement that algorithm using the imperative and object-oriented programming skills that you guys know how to do so we know how to make simple calculations these are sort of the building blocks that we have when we talk about algorithms we can do simple math we can store results we can make simple decisions using our conditional statements all right this is the imperative programming part of the class and we can repeat these steps extremely quickly so repetition is one of our tools these are all the building blocks of the algorithms that we're going to talk about okay the data structure is part of the class so you know we're gonna talk about these two things kind of together and what kind I'm just going to bounce back and forth between algorithms and data structures as we feel comfortable and depending on the things we want to talk about right a data structure in computer science is a collection of data that we've structured in some particular way we've seen data structures already we see an algorithms already - we've seen data structures we've seen a raise raise the data structure it's not a complicated data structure but it's a simple data structure and then along with data structures come new ways of working with the data that is stored by that data structure that's why we structure data in certain ways so when we talked about trees for example we talked about binary trees binary trees are going to give us the ability to implement new algorithms for accessing the data that's stored inside the tree the list implementations that we start working on towards the end of this week are going to each give us different the same ways of accessing the data inside the list but with different trade-offs in terms of the amount of time it takes to perform certain operations so for data structures you know essentially what we're going to do here is we're going to lean on our object-oriented programming knowledge that we've been working out for the past month so we're going to be using the primitive types and combinations of other objects to build the build up these data structures that we're going to be talking about whether it's a list or a tree or something else okay we'll utilize the existing data structures like arrays when appropriate and then references become a big part of what we do for the next month okay it's one of the reasons that we talked about references we talked about objects you know in particular unfortunately a lot of the object-oriented content in the class and maybe we could structure it differently and maybe we could structure it better but a lot of it may seem like a lot of machinery that you weren't sure what to do with well now we're getting to the point in the class where we're going to talk about what to do with that machine so these two topics are really you know I see them as highly complementary you know I don't think you should be able to teach a data structures course because of course on data structures is never just on data structures it's always on algorithms the data structures shouldn't be able to do she of course is design algorithms because of course on algorithms it's never really just about algorithms it's about algorithms and data structures okay we implement algorithms that utilize specific features of data structures in order to work so when we implement search on top of a binary tree we're exploiting the structure of the tree in order to make this search more efficient same thing with data structures the data structures that you guys learn about here and then you learn about and 126 if you take and learn about you 25 they don't exist because somebody thought it was cool hey let's make a tree because trees are pretty and then I can store data and it'll be pretty - you know trees are nice you know they're particularly this time of year they change colors nicely know somebody put data into a tree potato into a tree because then you can do things with that data it's kind of cool okay and again this is our chance to bring together the imperative and the object-oriented programming skills that we've been learning and put them to use doing something really cool okay and then along the way no sorry keep being surprised by my own slides then along the way we're gonna introduce some new things alright so we're going to introduce some new machinery we've talked about algorithms we'll start talking about that today and then particularly some new object-oriented concepts we're going to talk about generics we're gonna talk a little bit about some other features of Java object model that come in handy as we start to work with data structures and operands okay so let's so one of the things I want to point out here to you guys may have this you know perception that you know all I think I was I was listening to some students talking about today you know I think you guys have this this misconception that all the interesting problems the computer science are kind of solved you know you guys showed up too late you were born too late you know people got here earlier did all the cool stuff and there's nothing left to work on and and the truth could couldn't be farther from from from that right over the past couple decades we've seen massive advances in computer science fueled by new algorithmic techniques so just one that I'll throw out there for you to think about how many you know how many people have noticed that like Google seems to know what a picture of a cat is you upload a picture of a cat Google knows there's a cat in that photo right like how I mean that is sort of like that's a little bit weird right does Google have a bunch of big data centers full of people sitting around being like cat no cat cat no cat no cat no cat no cat maybe a cat cat no cat no it's all done by a computer this is a computer algorithm that algorithm was enabled by other algorithmic advances that were made extremely recently so deep learning some of the core deep learning algorithms were enabled by algorithmic you know algorithmic invention that happened relatively recently none of those algorithms none of that technology would be possible without recent discoveries in the area of algorithms so this is not a dead empty field with nothing interesting left to do there are a lot of cool problems out and this is an example of a place where you know one change one new idea one new way of doing things gave birth to this entire beautiful field of new cool stuff right a lot of the AI that you guys work with is built on models that are trained using this particular technique okay but let's talk about something simple something that is a solved problem right although to be honest actually we come back and talk about hashing and about computer security a little bit towards the end the semester this is kind of an open problem to actually working with with this is in the space where there is actually some interesting open problems ok so here's an example of an algorithmic problem all right I have two integers and I want to find their greatest common divisor or greatest common denominator given two integers that is the number the largest number that divides both of those integers evenly okay and and actually I can extend the idea so we'll talk about we'll do the GCD for a pair of integers but you can extend this to a whole set so if I give you n integers what's the largest integer that divides all n of those emailing okay so if you go online you will find you know on the Wikipedia page for GCD a incredibly detailed an interesting example of how to solve this problem using a variety of different algorithms is only called Euclid's algorithm goes back a long time again this is this is close to being a solve problem okay and you can implement these if you want but I want to use this as an example of talking about something a little simpler what we're then I'm gonna come back and distinguish at the end of class okay but what if you know it's like you know somebody puts this up on the board you're interviewing for some company and they say look I don't really want a super efficient solution to this problem this is essentially like a fizzbuzz type problem I just want to see you solve it okay don't worry about how long it takes I just want a solution to GCD okay so you can memorize Euclid's algorithm that might impress some interviewers or what can you do all right so let's let's think about so so the solution that we're going to work out together right now is in a category of solutions when we start talking about guns that sometimes known as a brute force solution okay I can never resist bringing this up so when I used to review papers in mobile systems there was some author who would always use the term brutal force instead of brute force when they're talking to brute force out in these brutal forms okay so we're not trying to kill the problem all right the goal is not to execute the problem right we're not using brutal force we're using brute force though right does that mean it's kind of like you know if you need to solve a problem just try harder like force it and I'm always said don't force it but that's what we're gonna do however in algorithm analysis brute force actually has a very specific meaning okay and and the meaning is basically try all the possible solutions until you find one that solves the problem so this assumes that I have some way of checking whether or not each candidate satisfies the requirement so if I go back to my my problem statement for GCD do I have a way of checking what if I gave you an integer and I gave you a set of integers and I said does this introdu bide all of those evenly you could figure that out we use the modulus operator the remainder operator in Java and so I can test a particular solution okay and so a brute force solution to this problem says let's just go one by one we're gonna take all the numbers that could potentially possibly be a solution and we're gonna it's going to try them one after another okay so in order to keep in mind now again this doesn't work for every problem because what we need is we need a way of checking whether or not the solution is correct okay we have that here what we don't know is how to pick good numbers right we can check a number if you give me one but I don't know which ones I should pick as opposed to which ones I should have void okay now here's the thing about this approach and and I'm raising this I don't want you guys to think I'm like a Philistine or something I'm raising this as both an observation as as as a warning okay your computers have gotten to be just you know obnoxiously fast you guys have access to I mean it's really true right it's one of those things that you know if you if you keep a gratitude Journal one of these you should write down today is I'm grateful for how powerful computers are right you know the phone in your pocket is literally as powerful as super computers where maybe 20 years ago that is actually true right that is changing the world in ways that we can't begin to understand and you guys are the beneficiaries of that so you've got access to all this horsepower that's good sometimes it means that you don't need a sophisticated solution to solve a problem okay so sometimes when you're getting started and a problem comes up as part of a system or a program you're trying to write or a system you're trying to build a reasonable thing to do is to try something simple try something simple something that's easy to understand something that easy for you to reason about and see how well it performs okay if it's too slow then you can go back and implement something more sophisticated and when you look at how certain companies involved you see this all the time you know you know Twitter started off doing some dumb things and as they got big and popular they fixed those things with more sophisticated alternatives that allowed their site to work better okay all right so let's let's do this example together okay so I've got my simple math class this is to avoid colliding with the math class that's already existing let's declare a method called public static int GCD this is going to take two integers for now let's just return zero I think Chuck style is gonna make oh yeah okay fine fine Czech style you're gonna win and defeated by my own creations here okay alright so I've got my little method skeleton here alright so let me let me do the first let's actually let's actually do this so let's say public static what let's let's make a helper function here let's say private boolean check int first into second and divisor I call this n all right so I want my check function here to return true if n divides both of them and return false if it does I don't know if n is the greatest divisor at this point but I just want to figure out is it a divisor or not maybe what I should do is call this is divisor alright how do i implement this helper function I've got two integers don't worry about air checking for now we can do that in the main function yeah yeah Jabez remainder operator be careful what you call it because it's not actually a modulus so I know you know you guys and this is sort of review now right let's just do this for now let's do have this return 0 well let's just remind ourselves about how this operator works first remainder second and it's angry about this all right so the modulus operator in Java what does it do it returns the remainder when I take one number and divide it by another number the first divided by the second so if I look here the first thing that's printed is put this right 10 + 8 is 2 because if I divide 10 by 8 I have 2 left over okay okay so how do I use the remainder operator to determine that a number divides another number evenly what value will that return so 8 does not divide 10 evenly what value will this the modulus return or the remainder operator return when one number divides another number evil yeah zero bingo okay so let's return first modulo n is equal to 0 and second I'm just kind of sorry I keep saying modulo remainder and I'll put some nice parentheses in here just to make this pretty okay so there's my check function like I said in order to apply a brute force solution I need the ability to actually check things efficiently this isn't just one line of code it's also fast so this is you know this is something that that is not going to slow me down very much so I can check things quickly okay all right so now I've got a starting point here but I'm not done obviously so now what do I do so now I have my way of checking how do I apply my brute force solution to this problem someone give me just a english-language description of what I'm gonna do I have a way of checking a value I have the two values that I want to find the greatest common denominator for maybe a maybe the way to start is what's this what's the smallest number that can be the greatest common denominator one and one sometimes is the greatest common denominator if I have two numbers that are what's called relatively prime so they don't share any factors than ones the greatest common denominator what's the largest number that can be the greatest common denominator of two numbers the smallest of the two right because if I get bigger than that I'm not going to divide two small one small one even okay so let's do this let's say and smallest this equal to first and I will say if second is less than first smallest is equal to second okay so here's a little snippet of code where I'm declaring a local variable called smallest and I'm setting it to be the smaller of first and second so now I'm applying this brute force search technique and actually I need to go easily to smallest so let's go back to my birth definition of brute force I'm gonna systematically enumerate all possible candidates that's my loop all possible candidates is numbers that are greater than 1 greater than or equal to 1 and less than or equal to the smaller of the two numbers that I want to compute the GCD for so the GCD has to be in here somewhere ok and then what I'm going to do is I'm going to check I'm gonna say if is divisor first second and return n ok let's try this I've got I've got I've got some concerns about this oh I need to make this static that's correct ok uh-oh doesn't look right what's my problem here yeah yeah I want to find the largest value not the smallest okay and the observation is that I'm starting at the bottom and in fact I know exactly what's gonna happen here one is always going to work one is the divisor of everything so I will always get one here so what I need to do is I need to turn this loop around so let's say let's start at the smallest value let's continue this is great imperative programming review while we're greater than one and let's work down okay so now it looks like I have something that's more reasonable and just as we were doing if we were writing this as a library or we're actually gonna you know writing this as part of an assignment or for someone else to use they have some test cases here okay so ten and eight what's the correct greatest common denominator ten and AIDS - all right both even three doesn't work for doesn't work five six seven eight don't work either okay 150 this is a case where the greatest common divisor is one of the numbers this is a good test case to make sure that my algorithm works properly here 50 is actually the greatest common divisor which is kind of obvious hundred is 50 times two down here I pulled two numbers that are relatively prime okay so one of them and and here it's our intuition breaks down a little bit what's one thing about this that would that would set off your alarm bells if if the answer wasn't one what are two numbers don't run it but let's say I changed this to this okay what do I expect I don't know exactly what the result is but can the answer here be one is it possible for the answer here to be one so I'm gonna make an argument for or against yeah yeah they're both even right one ends at 8 the other ends in 0 good old you know elementary school math but even numbers therefore the answer can't be something smaller than 2 it could be bigger if it turns out they have another common factor okay good so here's my obligatory sort of you know Hulk's life this is what this is this is a brute-force algorithm so again let's identify the different parts of it based on our definition I'm going to systematically enumerate all possible candidates that's this chunk right here all right I'm gonna check whether or not each candidate satisfies the problem statement I've actually written this so that my check is isolated as a separate function so again if you go and you look at buccal its algorithm it's much smarter than this and this is not what you should do all right but particularly for small cases and if you were just you know if this was just a small part of your program and it wasn't that important this might be okay all right all right so and again this is a good thing but it's this is a double-edged sword partly because your computer is really fast and so it's gonna make you know again let's go back and let's look at this right is there any sense in which you would describe this as being slow I mean it's not slow right and so you can get sometimes that means you're okay sometimes it means you fooled yourself into thinking that this is a solution to a problem that is going to really come up and bite you in the future all right and so what we're gonna do throughout the rest of the class is we're going to talk about some of the ways this can go sideways and we're going to start learning about how to categorize problems into different complexity classes based on how they behave is the problem gets harder and harder so we talked about algorithms for solving problems for the rest of the semester one things it's going to consume us and you guys will see this again and 173 and again in 225 this is a big part of being a computer scientist is understanding algorithm performance in order to understand algorithm performance we need to have a language to talk about it right but why does it eventually matter why does speed eventually matter so one of the reasons is the problem starts to get bigger so you wrote a function to search for a record among let's say you have a list and you were looking for an item in the list and it worked great your test cases passed really fast as long as the list only had 50 items but then you know your manager at Google is like okay well we're going to employ this on our you know cloud back-end and it's going to now have to process 50 trillion items it's a much bigger problem sometimes an algorithm that seems fast on a small problem gets extremely slow on a big problem the other thing that could happen is you know and again like your computers really fast it's hard to write a slow program on your computer today if you've done that then you have sort of accomplished something in the sense that like you are wasting a lot of compute right and that you may not like that at some point when your startup takes off you're going to actually have to pay for computing power I was actually reading something interesting the other day the number one and Amazon's number one revenue source anyone know what it is Amazon Web Services it's not all the crap you guys buy online it's selling computation to other companies Amazon as data centers all over the world with machines and you can go online right now don't do this because you guys need to pay attention but you can go online right now and for free you guys can fire up a machine in the cloud somewhere you could start using it for stuff and when you start your little startup you may start with ten machines in the cloud run by Amazon but here's the thing you're gonna pay them a bill every month that bill is going to determine how many operations your computer's performed if they're doing things in dumb ways that bills gonna be bigger your profit scrummy lower your company may go out of business if they start doing things in smarter ways this may be better if customers to complain about performance or you're in a job interview there you go bring it at home to something that's really important when you need to impress somebody with your knowledge of algorithms but this is actually a real thing right as a computer scientist people are gonna expect you to know what the limits are for how we solve problems how different algorithms perform and what some of the core challenges are in this space right so if you go into an interview and you're like I can sort a list of integers in Oh n they're gonna be like next candidate you know you've got to know that that's not possible okay so how long is this algorithm going to take all right so let's think about this let's say we're computing the GCD of 4 &amp; 6 and in fact it's for fun because this is fun let's go back here and I'm gonna keep track how am I gonna do this let's say public static int steps is equal to 0 I'm gonna say steps is equal you know what this is bad this is bad don't know no that's this is fine this is gonna work all right so when I start my algorithm and I'm gonna reset my step count every time I call my is divisor function I'm gonna record that it got called so this is some on some level a measure of how many steps it's taking to run this algorithm and now after I run it I'll print the step count all right and let's print this in a nice way all right there we go all right so now we'll do this and then we'll do this okay so ten and eight took seven steps why what were the steps the stage step here is a number that we had to try what were the numbers we had to try we had to try eight right we started at eight we tried eight seven six five four three two two that was it look of seven steps to get to the answer yeah oh hello there we go thank you all right what about 150 that's when we got lucky this was what can happen right when we start to talk about algorithm analysis sometimes there's a case that's really easy so in this case we started at 50 and bingo we found the answer right away okay that's an example the best case scenario for this algorithm which is that the GCD is the smaller of the two numbers I could find it immediately I can't do any better than that Euclid's algorithm is still not going to do better than that for that combination of numbers but here's a bad case right so look at the bottom I started at 65,000 270 and it took me 65,000 269 steps to get to the answer and the reason was well let me make this seven again and then we'll table take one more step yeah the answer is one I had to start all the way from the top and go through all of these numbers to get to one and you know again and if you know anything about math do you realize like this is dumb there are all sorts of numbers that I should be skipping along the way because I know that they can't be the GCD right you know so so anyway so this is not not a good solution right and it's going to perform you know more poorly as things get bigger and depending on exactly how things work right so if we think in general okay and again this is hard to do but we're gonna get practice over the next few weeks how if I give you m and N and let's say that n is smaller than M without loss of generality how long is this algorithm going to take well okay what's the best-case scenario we've already seen the best case scenario in the best case scenario how many steps does it take what's true in that case M is a multiple event so if M is equal to like some constant times n then I'm done because my first number I try and finished what's the worst-case scenario and I started and I have to go all the way to one let's go take n steps okay average case here is hard and we're not going to get into that really depends on the distribution of the how the numbers work but worst case scenario it can take n steps and here's the thing when n gets really really big this algorithm slows down a lot so much so that this is this is not exactly quite it but it's close to being the basis for modern computer security the reason why you can communicate with your bank safely is because certain number theory operations take a long time when numbers get really big and so when you start this is actually true when you start a like if you went to your bank website right now as long as you have a bank that's like not terrible okay you and your bank are going to negotiate a set of really big numbers that you're going to use to secure the transaction and the reason why nobody can detect can no one can figure out what you're communicating with each other which could be incredibly sensitive information it's because it takes too long to solve certain problems when you're given really really big integers okay so this stuff matters okay so I have 10 minutes left let's fly through the complexity classes which we will then come back to on Wednesday okay so here's one of the things that we're going to come back and do frequently from now until the end of the semester is if we're going to analyze our algorithms so what does this mean essentially what we're trying to do is a general version of what we just did for GCD we want to figure out how long the algorithm is going to take and frequently we're going to use this to put in an algorithm into a category okay I'll show you the categories in a minute not always we don't necessarily always want to count every tiny little thing the algorithm does we just want to have sense of what's its behavior like now a lot of times when we do this we don't care about specific inputs I don't care about how the GCD performs with a specific set of numbers I want to be able to make a more general statement about how it performs on any set of inputs that's a lot harder to do if you give me two inputs I can tell you exactly how long it's going to take but if you give me two general inputs I need to think harder about how long it's going to take but that's what we're going to do okay so here are some of the questions we're going to ask ourselves are there particular inputs that are hard for a particular algorithm our GCD algorithm that we just wrote if you give it two numbers that are relatively prime they share no common factors that's the worst possible case because it has to start at the smaller of the two and walk all the way to one okay so best worse an average case running time so best case we just looked at one of the numbers is the GCD worst case they don't share any factors and I have to walk to one average case gets trickier right and probably averaging over a population of inputs that we may not fully understand okay but overall one of the core factors here is how is the algorithms performance related to its inputs if I think about a simple problem it's gonna take so long but then if I make that problem 10 times harder or a hundred times harder or a thousand times harder or a billion times harder how long is it going to take okay all right and that's where we get to this right so wait sorry so that a lot of times to what we'll do is we'll actually talk about what happens at the limit so as M and n go to infinity is the performance of the algorithm behave and there's reason for this first of all is it's really actually very useful to understand how the algorithm performs how an algorithm performs when the problem gets really hard the second reason is at that point all these other little details they kind of fall away ok so let me let me give you an example of this again I'm sorry I'm gonna race back here to my my algorithm so if we look at the GCD algorithm that we wrote there's this little chunk of code right here from lines 9 to 12 that's basically just figuring out what the smallest value is that takes the same amount of time regardless of what the two values are okay this stuff down here this loop is what's gonna dominate performance once the numbers get bigger so if I try a small number it's possible that half of the run time of my algorithm is consumed doing this stupid little calculation it's not stupid it's important but if I give you really big numbers right then my algorithm spends a lot of time racing around in this loop down here okay and so that's why we think of frequently about algorithm performance at the limit right at the point where my inputs get extremely big okay so let's meet our complexity classes when we talk about algorithm complexity a lot of times what we're gonna try it we're going to be trying to figure out is what category there's two things we need to figure out first of all what is N what's the feature of the inputs the drives performance more about that next time the second thing is what category does the algorithm go into okay is it a know what you guys are gonna start to say say things like is this an O n algorithm versus a Oh N squared okay here's why this matters and again I want I want to point out something to you so this is the performance and this is just you know operations whatever you can think of this as runtime okay this is the size of the input over here on the graph is labeled that what are called the complexity classes and what you can see is that there how long they take varies very differently right so let's let's start in the middle here actually let's sort right here so this is what's called one57 so you can see that the line alright that's not too bad completely when you compare it with something like this guy okay this is o N squared so now how long the algorithm takes varies with the size of the problem or the difficulty of the problems squared so if I make the problem ten times harder the algorithm takes a hundred times longer right we even have some worse cases here so this is a weighed down here we're not actually going to talk about oh actually you know what I lied there is an O n factorial algorithm we'll talk about it's a fun one okay Oh n factorial look at this this is like a rocket ship taking off in a bad way okay like imagine that you wrote that and and and deployed it as part of a product or a service okay you will be looking for a new job right as soon as as soon as any type of load starts at your system here's the thing okay this is this is the this is the cautionary tale about this graph look down here okay all right at the origin they all look the same it's not until the problem gets a little bit bigger I mean by the time you get to like four or five like Owen's factorials off the graph it's like peace out I'm out of here I'm going to the moon but if you just run simple test cases and you don't understand how your algorithms actually perform you might actually come up with an O n factorial algorithm and think it's good you might think oh this is great I'll just you know push this out today and in my test cases all passed no problem I'm good it's very easy to get fooled because of how powerful your computers are when you use small inputs that down here everything is kind of cool nothing is very slow but you know you get out here and now you're seeing these big differences between even you know oh and square which is gone right and algorithms that are that are faster okay so I'm gonna skip this we'll come back and do this next time but I do want to do where to go right okay so let me close with this right where am i crap go okay here's my graph again so again I just want to impart the importance of this topic and the sophistication that you can gain as a computer scientist by understanding this all right if so here's the difference you know here's why we talk about algorithms because a dumb algorithm makes an easy problem harder okay so we haven't talked about I bet I have a an algorithm that we'll talk about next time the tests whether or not an array is sorted my implement my algorithm is o N squared that problem should be in the category Oh n I've made it harder my algorithm takes longer than it needs to it's wasteful right it's a computer scientist I should know that you guys will know that by the end of semester on in contrast and again this is where we see advances to this day when you come up with a smart algorithm a clever way of doing something you're actually taking a hard problem and making it dramatically easier all right so again our way of finding the greatest common denominator was Oh N that's actually the category it's in because it's based on the minimum and I have to potentially walk all the way to one Euclid's method is a log n so let's go back and look at the the complexity categories again right so here's oh end and here's Oh login all login is down here you can't even see o log n a log on it's like hanging out with the x-axis alright so if you take some Engineer out here and you're using our stupid GCD implementation but you could use ooh you lets algorithm look at all this time that you're wasting time that your customers are spending waiting for your site to refresh you know time that you're being billed by Amazon for time that you know your demo is loading really slowly when you're pitching something to a VC or whatever ok so on Wednesday we're gonna come back and go through the complexity classes carefully I don't have office hours today I do have them Wednesday good luck to the orange team who's finishing up mp2 tonight I will see you guys on Wednesday enjoy lab tomorrow  
﻿ hi come back everybody welcome to a new season apparently without their hope everybody enjoyed Halloween I was well anyway doesn't matter I was tempted to dress up today but callings kind of over I should have done on Wednesday next semester maybe well no next year that's my next chance alright so today we're gonna keep talking about recursion so we introduced this as an idea last time there's a concept and that's what it is it's not just a programming strategy but today were not only gonna look at a recursive approach to solving a problem a simple problem figuring out how many nodes are in a binary tree well go through that schematically it will review what we did last time and then we're actually gonna write our first piece of recursive code which is fun and this is essentially the kind of thing that we're gonna do for the next week or so a little bit longer than that the homework problems today start with tree recursion and we're gonna continue that pattern for a while you guys are gonna get maybe a little tired of writing tree recursive algorithms but this is great practice and recursion is one of those things that you know you really have to see it over and over and over again particularly if it's new to you even if some of you that think that understand it may need to see it again and again and again in different ways before it kind of starts to click what's actually happening okay I also have some good news for you which is that the class did really well on the midterm so congratulations on that better than last semester better than last year actually so I was happy to see that we have a new MP checkpoint that will release on over the weekend that's gonna be the last part of the game so this is it this is when everything comes together I know that many of you have the opportunity to drop this part of the MP I hope that you won't I hope that you'll do this so that you can complete the process so that you can actually get to the point where we have a fully functional snake game that you can playin use once you guys finish that up so just to think about how to kind of rest of the semester works we have three full weeks until Thanksgiving so this MP checkpoints gonna consume two of them once you're done with the machine project then we're gonna get you started on your final project and so in the lab the week before Thanksgiving we'll start discussions that will have you identify a partner the goal of doing this is to give you some time for those of you who want to do a really cool final project to get some work done on that over Thanksgiving okay and you know so this is what's happening over the next you know a month and a half that we have left in class at that week of Thanksgiving there's four more quizzes one more midterm the midterm comes right after Thanksgiving break and then we will have the final project fair I need to set the date for that I will do that soon but you know this is what's happened okay so let's go back and just review our tree terminology so last time we started talking about this commonly used data structure and computer science called a tree a tree consists of a series of nodes that we organize together that we structure in a particular way such such that every node has one parent except for one node so I have a root node the root node of the tree has is the only node that doesn't have a parent every other node then tree is linked to a parent node now the node itself doesn't always store a reference to its parent but that's one way to think about is that the node has a parent parents in the most general tree that we can talk about and have zero or more children in the trees that we'll work with in this class primarily they're going to have two children it's a special case of a tree known as a binary tree so just to again review quickly some terminology so we refer when we're talking about you know we can essentially look at every part of the tree individual name we can say a node is a parent if it has children so this node has three children the children are descendants of the parent each child if you think about reversing that arrow has a reference to one parent node because these are not roots okay children have one parent every node in divine in a tree as one parent except for the root so we refer to the top of the tree in the way that will look at it of course you could invert these diagrams and they would work as well but we refer to the node in the tree with no parents as the root node many of the algorithms that we are going to use are going to start at the root in fact I shouldn't say many all of them our binary tree class that we're going to look at today and be working with up in the next week or so the only information it stores about the tree is a reference to the root node so this is sort of similar to what we saw with linked lists where my list data structure only stored a reference to the start item and then every other item was linked together as part of the list here the tree stores reference to the root and all the other nodes I can find by starting at the root I start at the root and then I find the root nodes children and I find its children's children and stuff like this it's ever so the rest of the nodes and the tree are labeled as nodes here that the nodes at the very bottom that have no children we refer to those as leaf nodes so any tree any non-empty tree has a root and a non negative you treat has at least one leaf node a tree with one node the root is also a leaf made a tree with more than one node I have at least one right if I didn't the tree would be infinite in size all right so we can talk about the depth of the tree the depth is the depth is determined by we could talk about sorry the depth of a node in the tree so the depth of particular node is determined by how many hops it takes to get from the root node to that node from the root to the node that we're thinking about so these two nodes in my tree here our children of the root they have depth one it takes me one hop to get from the root down to both of those notes the nodes down in this part of the tree higher depths because it takes longer to reach them so here if I started at the root I get here with one hop this note is that level one I get here the second hop this note is at level two and I get to this leaf node here in three hops so it's at level three the height of the tree is the maximum number of steps it takes to reach any leaf node and you guys will actually write the algorithm to compute this in a couple of homework problems so given a tree figure out the height so essentially what I need to do is find all the leaf nodes and then figure out which leaf node took me the longest steps to reach okay so now let's start looking at a recursive algorithm on tree and again we presented this last time we didn't implement it yet we will today after we get through talking about it but you know this is a good starting point it's a good starting point because you still see the recursive solution to this algorithm is extremely elegant it's simple with only a couple lines long but conceptually it could be a little tricky to figure out how this works so let's walk through how we're going to do this so when we approach a problem recursively what we're doing here is we're designing a recursive algorithm we're not writing recursive code yet we're talking about a problem solving strategy that counts the number of nodes in this tree recursively and here's our general approach for designing recursive algorithms and any step in the algorithm we need to either do one of a couple of things one thing that we can do is we can make the problem smaller if the problem is too big for us to solve then we can say well you know what I can make the problem smaller and if I could solve these smaller problems then I could come up with a solution to the firt to the full problem so that's one thing we can do once there's a certain point that we will reach that the algorithm will get to where I can't make the problem any smaller I've made the problem as small as possible sometimes that means that we reach a leaf node or we reach a yeah we reach a leaf node sometimes it needs we reach an empty tree will come back and we'll see that in action in a minute at some point the problem is so small that I shouldn't need to make it smaller to solve at that point the solution is evident and then the other thing I'll need to do is figure out a way to combine the results so if I have two smaller problems how do I combine them together into a solution to a bigger problem if I can do these things so any algorithm they can take a problem and make it smaller and then can solve a problem once it gets small enough and can combine the solutions from smaller problems together to solve a bigger problem can eventually solve the bigger problem right I'm gonna break down the problem you know in this rigorous sort of well designed way and eventually it gets so small that it's easy to solve and then I can combine those solutions to the simple problems together to make a solution into the slightly less simple problem slightly a bigger problem slightly more complicated problem and once I do that I can eventually solve the problem that I started all right so here's how we're gonna do this with counting okay so here's the big problem that we're trying to solve we're trying to count all the nodes in this tree keep in mind I don't even know where these nodes are all I do was have all I have is a reference to the all my tree has is a reference to the node with value five and that's a reference to the root okay so how are we gonna break this problem into smaller subproblems well I mean here's a proposal given a tree the size of that tree given any node in the tree the size of the tree that's rooted at that node is one I need to count that node plus the number of nodes that are in the left subtree of that node which could be zero plus the number of nodes that are in sorry the right subtree left subtree one left subtree right subtree okay so what have I done here I've actually both proposed a way to make the problem smaller because my left sub-tree and my right sub - you are gonna have fewer nodes in them then the entire tree so my left subtree is gonna have fewer nodes so that's a smaller problem my right subtree is gonna have fewer nose that's a smaller problem notice that I've already I'm also proposing a way to combine the results together here I combined them by adding I add the nodes in my right subtree sorry left subtree - the notes of my right subtree and i make sure that i count myself the node that's the current route okay so here here's the node that's the current route that's one we know how many nodes are in there and in that part of the tree just one I have no idea how many nodes are in fives left subtree and I have no idea how many nodes are in 5s right subtree but I knew if I knew how many nodes were in the left subtree and the right subtree then I could tell you how many nodes were the integra tree okay you may think I'm belaboring this but this is the essential step now we're just going to repeat this okay so I've got two smaller problems now I have to count the number of nodes in a tree that's smaller than the original tree two of them one tree here rooted at node three one tree here rooted in node 10 so if I can count the nodes in the tree routed to note 10 and the nodes in the tree root and node 3 I'm good I can solve the puzzle all right how do I do that well let's let's just let's just continue on okay so now let's examine one of these smaller subproblems how do I count the number of nodes in the tree rooted at node 3 okay well let me try applying the same strategy so I don't know how to count the total number of nodes in the tree but I know that if I could count the number of nodes in threes left subtree and the number of nodes in 3ds right subtree and add one I would have the answer now here the problem is actually getting even easier because node 3 doesn't have a right subtree okay so now you know now things are getting better now let me start again I'm just restarting the algorithm this is why it's called a recursive algorithm it keeps restarting itself pretending now that seven is the root of a tree well if seven is the root of a tree how many nodes are in that tree not a trick question I'll give you a node and it doesn't have a right subtree and a left subtree then the number of nodes is what yeah so now this is the smallest possible subproblem and I've solved it once I get to a node that has no children I'm done you know now it's like wait okay well you told me to count the number of notes in the left subtree in the right subtree there is no right subtree there is the left subtree zero zero one I know the answer all right the answer is one okay so good so now let's go down the other side I'm doing the same thing I'm just reapply the same algorithm if I'd want to count a tree and the tree has if the root node has children then I count the right subtree and the left subtree and I add one and here I go so I'm doing the same thing now again I've reached a leaf node so I've reached a problem that I can solve immediately this is the smallest possible subproblem that's what I have to solve at that point I can't keep making the problem smaller there's no smaller problem here to solve I've identified the smallest possible problem I'm gonna do this here too okay so now here's the second stage so sometimes when we write over only we win right a recursive algorithm we think about two stages particularly with trees sort of a natural way to think about it we think about it I'm kind of working its way down to find smaller subproblems because as I go down the tree right so the first thing I did was I separated the tree into a left half and the right half each one of those was smaller than the original tree so as I go down I'm identifying smaller and smaller and smaller to solve then what I do is I combine the results kind of as I go back up and that's where I start to solve more complicated problems so I take these simple solutions I merge them together and I get a solution to a more complicated problem okay so here we're here on the left side I'm gonna take the solution to how many nodes are in the tree rooted at node seven and combine it with the solution to how many trees are how many nodes are in the tree that doesn't exist with zero and now I do the same thing over here so I know how many nodes are in the tree where didn't know nine and I know how many nodes are in the tree rooted in node one now here's the so three so when we got to know three we essentially told ourselves if I could count the number of nodes in the right subtree and the left subtree I would know how many nodes are in this subtree so if I could count the number of nodes in the tree rooted at seven I would know how many nodes are in the tree rooted at three and indeed I do because seven got back mated said hey the number of nodes in the tree root into me is one and so three goes okay now I know how many nodes are in the tree rooted at three it's two same thing over here for no 10 no 10 had said hey if you could count the number of nodes in the tree rooted at no nine my left subtree and the number of nodes in the tree rooted node one my right subtree then I would know how many nodes are in the tree rooted at me no 10 and I do it's three number of nodes for the right subtree plus the number of nodes in the left subtree plus one and now so again now I'm solving more complicated problems I started off trying to count the number of nodes in a tree that we knew had six nodes and then I broke it into a problem of counting the number of nodes in a tree with two nodes and the number of nodes in the tree with three nodes and now I'm ready to finish the job so now my solutions have gone all the way up five when we started this we said hey if I can count the number of nodes in fives left subtree that's rooted no to three and I can count the number of nodes in fives right subtree which is rooted to no 10 then I know how many nodes are the entire tree so three got back to me and it said hey there's two nodes below me and the tree that's rooted at me ten said there's three nodes in the tree that's rooted at me and now five can finish the job fives the root node and it can come back and it could say there are six nodes in this tree oh okay questions about that I know it hurts my brain to explain so I'm sure that it hurts your brain too to look at okay so we can go back and forth between the algorithm in the code but let's implement this okay you guys are gonna be surprised I hope and how easy this is so let's look through this code together for a couple of minutes because this is a this is a tree structure that we're gonna use a lot for the next week okay so I've got and again this is sort of good object review I have a class called binary tree I had this new static field that's of type random and I'm gonna explain what that does in a minute okay then I have an inner class called node this is sort of like my list remember my list had an inner class called item this is a node in the tree this is a binary tree every node has zero one or two children and we refer to them as left and right so my node data structure it stores of value remember I do want to store data in this tree and we'll use that data later when we do some algorithms on trees for now we're just counting the number of notes so the data is sort of irrelevant but I have a way to store a reference to an object so I can sort any kind of data I want this tree and then I have a right child which is a reference to another node a left reference to another node and I have this constructor that I created it just sets the value here okay so now down on line 13 there's a lot of code here so we're gonna go through it together we're not gonna add much but but there's a certain amount that's needed just to kind of set up a tree and there's actually already a recursive algorithm in here I'm gonna show it to you all right so the one thing that my tree needs to know is what is the it needs a reference to the root node that's the top of the tree all the other references are stored within the tree so once I find the root I can find its right child and its left child and I can find their right and left children I can essentially explore the entire tree all right so I've got my root node and then down here here's what I want to look at together for a minute here I don't want to explain this in a great amount of detail but I just want you guys not to be a freaked out by it this is this is as simple as I could make this believe it or not okay so the question is for the purposes of running these examples we need a way to build a tree so how do we build a tree well what I want to be able to do is I essentially want to be able to add nodes to my tree I want you to give me a list of objects and I want a way to add them all to the tree and in order to make our examples sort of interesting I also want to be able to add them I want to carried a random tree so the trees that are created by this algorithm contain all the values that are in the array that's passed into the constructor but those those object values might be anywhere in the tree there's only a couple of rules about where things go that we'll look at in a minute okay so when I added and when I add an object to the tree I call this function called add so if you look here at the constructor it takes a list of object references and it adds them one by one to the tree so teeps keeps calling add add add and it calls add on the root node and adds a new value to the tree so here's how my add function works it takes a two arguments the first is a reference to the current node that's the current place where we're going to try add that note the second is the value to add that's sorry that's the current place where we're gonna try to add that value to the tree however it's possible that that note let's say I so let's imagine that I run this algorithm and I run it on the root note so the first time the root is null and so I can add a node right away the first note I add to the tree becomes the root note then I add another note so that could become the roots left child then I add a third node that could become the roots right child the problem is at that point what do I do because I'm out of know I'm out of spot right I can only reach the root node and so what I've done here is I've actually provided a recursive add algorithm so what this does and it's a little bit trickier than this so so let's look at what happens inside the add function so first of all if if the root node is null so the first time this cut gets called there's no root node if the root node is null then I set I create a root node by creating a new node but the value that was passed and studying the root reference to that note at this point the tree has one node in it otherwise here's what I do so this goes back to this random reference that we had above random is part of the Java standard library and it's a collection of methods that give me random values one of the things I can ask random for you can ask random for a random int for random double but one of the things I can get from it is a random boolean so this gives me a random yes or no value or random true or false so half the time random next boolean is going to return true and I'm going to enter the top part of this if statement the other half of the time it's going to return false and I'm going to enter the bottom half of the if statement in the top half of the up statement here's what I do if the current node doesn't have a right child so if current out right is equal to null I add the value to the current node as its right child I do the same thing down here so if random next boolean is false and the current node doesn't have a left then I add the node as the current nodes left child otherwise now here's where things get interesting I call add to restart my algorithm on either the right subtree of the current node or the left subtree so essentially the algorithm works as follows it says I'm gonna try to add the node if if half the time I'm going to try to add it to the right half the time I'm going to try to add it to the left if the node doesn't have a right child and that's what I've decided to do I'll add it as the right child otherwise I'll add it to the right subtree of that node if the node doesn't have a left child and that's what I've decided to do I'll add it to the left side of that node is this left child otherwise I'll restart the algorithm on the left subtree so this is a recursive Alvin right essentially it's making the problem of adding a value smaller every time by adding it to a smaller sub tree where there's more likely to be space okay that's this is a more sophisticated recursive algorithm than I would expect you to understand right now but I just wanted to talk through that quickly all right so here's what we're gonna do we're gonna write this and I also provided a recursive two string function you guys can look at that yourself alright so this code should work it creates trees properly I can add I'm creating in a tree with integers in it I can add as many interest as I want to this tree the two string function prints out all the values in the tree but let's figure out how to count the number of values in the tree so I want to implement this size function okay so a lot of times if you look look at the two string function so I have a public two string function that takes no arguments that calls a private two string function with the different signature and this is something that we're gonna see a lot when we work on trees when we write a recursive algorithm we're gonna we're gonna start the recursive algorithm on the root note right so let's let's use that same structure to do size we put that here so I'm gonna create a private method called sighs and that private method takes a takes a reference to the node to count them so essentially this is the root of the subtree that I want to count the number of nodes it okay and when I call size I'm essentially going to return the size started at the root right so this is now gonna still do the same thing because I haven't implemented my recursive algorithm okay well let's do this now what's the so when we when we went back here right what was the simplest subproblem that we were able to identify at what point do i have to solve the problem there's a certain tree that i should be able to count immediate how do i know that i've reached that point yeah yeah so say if current left is equal to null and current dot right is equal to null what do I do turn 0 what about me I'm at a node remember right this always gets run on a note so we're close if I'm counting and if I'm counting a tree that it only has one node has no children then the size of that tree is one yeah so here let's return one okay so this in a recursive algorithm is sometimes known as the base case this is the point where we cannot continue to make the problem smaller there's no smaller problems here I found a node there's no children I have to be able to count that tree there's no way to make there's no smaller problems there's no right subtree there's no left subtree okay otherwise so let's say let's do this so here's what I'm gonna do I'm gonna create this value and let me call it count set of size sizes the name of my function so I'm initializing count to 1 make sure I count me okay now what are the two smaller problems that I want to solve ok so again I can't count all the nodes in the tree from here but I know what are the two smaller problems that I want to solve so I met some node I know that this node has either a right subtree or a left subtree maybe both right what's one of the smaller subproblems that I want to solve this okay so the size of the left sub-tree all right so let's say count plus equals size of current dot left okay this is where for some of you your brain is going to start to explode a little bit I'm in a function and I'm calling the same function it's weird pod there's no reason that this doesn't work right now just just sort of like put your worries aside for a minute about whether or not this is actually okay I'm just the function that I called size is supposed to count the number of nodes and put a little comment above it count the number of nodes in the tree rooted at current so I can call it on my left sub child now I need to this this code isn't quite right yet can someone help me here if I run this this is probably going to cause a problem sometimes yeah I might not have a left sub-tree so let's just fix this here let's say if current out left is not equal to no then I'm gonna count my left sub-tree all right what else do I need to do yeah yeah I can't ignore my right sub-tree right so now I'm gonna do essentially the same thing I'm gonna say if I have a right subtree then the number of nodes in the tree routed at me has to be increased by how many nodes are my right subtree so this is essentially 1 plus the number of nodes in my left subtree plus oh wait sorry no that's right count plus equals so 1 plus the number of nodes in my left subtree plus the number of nodes in my right subtree okay I'm gonna change this down here to return count and let's see how how we went oh man check style it's what you guys signed up for there we go yeah seven is this right let's look at the let's look at the example I did here one two three four five six seven I'll look story let's take off a few nodes here five oh that's right okay first recursive algorithm this recursive algorithm has a book who can tell me what it is I can provide an input that will cause it to crash who can tell me what that is yeah Kern is no but how do I get current to be no normally I'm not gonna start the algorithm a current is null but there's one special case here yeah way in the back what's that okay so the length is zero but how would I get a link to be zero yeah oh only okay so let's try that so I only have a root that would be one node that works you're close we're heading in the right direction here what about this guy boom so what happened here my root is null so when I ran the algorithm here they go up here sorry let me move some things around here so that this is closer to the example code that we're messing with I'll just put the two strings stuff up here better okay so here's the problem in this example root was never set to anything it was no and so I called size root and then I started using root as if current is if it was a valid reference so let's say if I do this I'm going to put another so this will handle that case okay good all right okay so this is correct and this is the thing that most closely matches what we talked about when we went through the diagram does anyone have any questions about this I do want to go slowly here because this stuff stuff totally totally get that again like I mean I still remember I don't remember much from 20 years ago literally 20 years ago this semester when I took into a programming for the first time but I do remember recursion and struggling with recursion and being confused by it so it's not unusual to feel queasy weirded out a little bit by this type of approach okay so let me let's do something together here and this is going to be characteristic of our other tree algorithms it's gonna make this a lot nicer okay because I promised you this was going to be simple but what we have up there it works it's correct but it's kind of kind of not not as nice as we would like okay here's what I'm gonna propose what we're doing right now is we're stopping our recursive algorithm when it gets to the Leafs right so if I look at my code when I get to a leaf node this is known as my base case if the current node has no left or right child it's a leaf node and I return one but here's what I'm gonna propose let's let our algorithm not only get to the leaf nodes but get to an empty reference so let's imagine that we allow the algorithm to walk off the leaf nodes and a walk essentially into an empty tree so everywhere where I have a reference here that is to an empty tree so three has a reference to an empty trees it's right child seven has two references to empty trees nine has two references to empty trees one has to represent a tree so what's the size of an empty tree if I go to a tree if I get to a node that's null what's the size of a tree rooted at no no zero right if I so imagine if I ask how many nodes are in sevens left subtree the answer is zero right how many notes are in sevens right subtree the answer is zero so here's what we're gonna do we're gonna keep this little part in here from lines 56 to 59 what this means is that we've walked off the end of the tree we got here because we followed a left reference or the root or right reference that led us to a tree that didn't have any nodes in it at all so those trees are empty they have size zero if we do that let me show you why we're gonna do that if we do that then we can do the following okay we can say that the size of the tree is 1 plus size of current left plus size of current dot right it's gonna work let's try it put some nodes in here let's see how we go it's like it works okay so now this looks nice okay so why is this working let's just linger here for a minute think about so before that code that I deleted a lot of it had to do with avoiding know right what happens if current out left is null because I could because the problem is I couldn't call size on a no reference it wasn't safe but now the point is that my base case is if I get a no reference if you give me a reference to a null tree I know the answer I know how many nodes it are at zero so now I can write my I can write this algorithm recursive algorithm much much more pleasing way right this makes me much happier as a computer scientist it says how many nodes are in this tree one plus the number of nodes in my left subtree plus the number of nodes in my right subtree that's exactly what we had worked out together when we went through the diagram the only difference is if my left reference is know my left subtree has zero nodes in it if my right reference is null then my right subtree has zero nodes in it but my size algorithms my size is gonna handle that because if I walk into an empty tree it's just gonna say there's no nodes here all right questions about this because this is typically what we're going to do when we write our recursive algorithms the reason is there's so much nicer all right so look at what we may just go back up here you know look at what we started with all right we started with this okay so I have deleted 10 lines of code I gotta recreate this and replace them with one line of code and no again I am NOT I don't want to be here to sort of encourage you to to idolize code that's short that's actually not good I was actually reading the creator of Python whose first name is Guido and whose last name I'm not gonna try to pronounce but he apparently went to work at Dropbox for a while Dropbox is a company maybe you've heard of apparently Dropbox used this Python a lot internally I don't know why but so we know decided to go there and work because they did a lot of Python work and he is the person who created the Python language but apparently one of the things that he did that he spent a lot of a time encouraging there does their engineers to do was to stop writing such clever code he would find code that was overly clever and he would say you should make this more clear you know it probably gets longer right but stop being so cute with how you design things right you know a shorter algorithm is not always better a longer algorithm in lines of code that's more easy to understand is frequently superior however in this case this line really distills exactly what this algorithm does it counts the number of it counts me the number of nodes in my left subtree and the number of nodes in my right subtree so I I think this is a much clearer formulation so this is what we're gonna do in the future we're gonna handle null as our base case figure out what to do there and then we'll allow ourselves to essentially walk off the tree all right because we know that we can do that see any questions about this before we go on yeah yeah yeah so the question is why can I call sighs inside sighs the answer is you can you will figure out why you can later and I don't want to go into it it's complicated but essentially when I call size inside size it behaves like any other function so when I start on the root what let's let's do this it's hard to do with this one we'll come back to this later so the idea is when I call size on the root node let let let me let me make this example a little smaller one two five okay when I call size on the route here's what happens so my size function starts running it's running on the root node the root node here is value 1 then it gets to this line and it says oh I need to run the size function and it calls size on current dot left my first copy of size is now waiting for the second copy to finish so the second copy of size starts running it says um I called on no no therefore I have some work to do so it gets down here and it calls size again so now I've got three copies of size running now both and I'm about to have 4 because I'm gonna call size dot left in size dot right both of those functions are going to return right away because they're gonna get to a null reference and then the second copy of size is gonna finish my first copy of size is now going to call size again on the right and the same thing is going to happen so there's really no difference I mean if you want to think about what's happening internally fine but there's really no difference between calling a function inside a function and calling the same function inside a function it's something you can do I could call to string I could call whatever right I can call a function inside another function and the function that gets called does its work and the function that called that function waits for it to complete and then proceed so there's really no difference here the fact that I'm calling the same function is just sort of a anomaly that's due to how I structure this problem yeah why do I have to sighs methods right so the idea here is that I don't want it's a great question so see here my root nodes private my tree class is not going to expose its structure to the people that use it it's gonna say you know what you don't need to know how I implement a tree I am a tree I've got leaves I've got nodes it's all good if you want to use me I'll tell you how to do it so if you want to know how many nodes are inside this tree you call size see here I'm calling size with no arguments right so anyone outside of this class doesn't can't access the root node right internally what I do is I say ok if I want to know this number of nodes in the tree I called the size function that starts at the root yeah great question so that's why I have an overload here we're gonna do this every time all right when we do other recursive functions alright let me give you guys some advice about recursion because again this is a tricky concept it's something that can be hard when you get started it takes practice you're going to get practice you're gonna be okay so first thing here whenever you write a recursive algorithm is you eventually have to stop this process of making the problem smaller has to reach an end it can't continue indefinitely if you can't try to continue it indefinitely your program is never going to to end okay this is sometimes known as a base case that's the point where you are solving the puzzle so here our base case is when current is null that's the point where I don't call size again I'm done I've walked off the side of the tree and there's no nodes there to count okay make the problems smaller in each step if your each step of your algorithm simmer down isn't making the problem smaller then again you're never going to stop you have to make the problem smaller and smaller and smaller to eventually get to the point where you have a problem that's small enough that you can solve this is known as the recursive step so again back here I'm calling size on my left subtree that has fewer nodes in it than the whole tree that's a smaller problem I'm calling size on my right subtree that has fewer nodes in it than the entire tree that's a smaller okay and finally figuring out how to combine the results together so again I've got one line here that one line is doing two things first of all it's solving two smaller problems the number of nodes in the left subtree and the number of nodes in the right subtree and then it's combining the results together it says the number of nodes in the tree rooted at me is the number of nodes in my left subtree plus the number of nodes and my right subtree plus one to count me all right so here's so here's another example of a recursive algorithm I don't want you guys to think that these are all confined to trees so this is an implementation of factorial right factorial of a number is the number multiplied by the number one smaller than it until you get to one right so just like we talked about this has these these features so here's my base case the factorial of 1 is 1 that's the problem I know how to solve otherwise what I do is I say I know that the factorial of a number is that number times the factorial of the number that's one smaller so here I've got my recursive here's my recursive step I'm calling factorial n minus 1 and here's combining the results together all right so base case is when N equals 1 the recursive step is calling factorial of n minus 1 that's what makes the problem smaller because I'm going towards 1 I hope and combining results together is multiplying the current value times the factorial of the number that's one small all right here's the problem though I have to reach the base case remember I have to stop at some point so I'll give you guys you know last little problem before we break up today how can the code above fail so this code can fail to reach the base case yeah yeah or how about zero or negative number yeah so what's gonna happen here I'm gonna say okay I need to compute the factorial of negative four well how do I do that I do that by computing multiplying negative four times the factorial of negative five right okay how do i compute the factorial of negative five well I compute the factor over five I multiply negative five times negative six right how do i compute the factor of negus six by be the factorial maybe six by combining I would multiply negative six by negative the factorial negative seven right this is not going well right I am NOT going to get to one so if you try to run this code in the playground you're gonna get a runtime error and this essentially men means that you you never got to one you kept calling factorial over and over and over again trying to solve the problem but you weren't making the problem small you weren't getting towards the base case okay this is where we will pick up on Monday I don't really have much of anything to announce today I hope you guys have a great weekend stay warm just to the new climate good luck finishing up mp3 the third checkpoint and I will see you guys on Monday  
﻿ okay look at that only ten minutes late sorry about that alright so today it's not a good day for this to happen either we have some cool code to write so we're gonna keep talking about sorting last time remember we got through insertion sort which had this problem which is that had and Oh N squared run time and so today our goal was going to be to look at ways that we could do better than that there we go okay sweet all right so so the the main sorting algorithm we're talking about an implement completely today is merge sort and merge sort is a nice algorithm in the sense that it is very predictable performance and so here's the key insight that underlies merge sort which is that it may be difficult to sort things to sort of raise right that's what we're spending a couple of classes on but if you give me two arrays that are already sorted merging them is straightforward so here I've got two arrays that are already sorted the one at the top and the one at the bottom and my goal is to combine them together in a to a single sorted array okay so I've got two sorted arrays and my goal is to combine them together and you know this is not hard to do right in this case the two arrays are sorted in descending order so I know that the smallest values are at the front and essentially what I do over and over again is I look at the first two values in the array sorry I look at the first value in array one the first value in array two they say which one is smaller I take that one out and then I move on so now I do the same thing okay so now the second array has the smallest out right now the second array again has the smallest value that second array has the smallest value again so as long as it's smaller I'm gonna keep pulling values out okay now I'm back to the first array now I'm putting values out of the first array get the last value from the second array and the last value from the first term all right so this is a straightforward process to take two arrays that are already sorted and merge them together so let's implement this this will be our first challenge today and again this is a terrible day for this to happen because typing on this keyboard is gonna be an adventure okay so let's do this oh god I don't know what you ever go away all right so what like what is the first thing that we're going to do here I'm given two arrays and my job here is to merge them together you guys forgot the chance to do this on the homework this week what's the first step here what's the first thing I want to do just going back to our sanity checking yeah yeah let's handle null cases and actually we'll handle two corner cases here will handle null and we'll also handle cases where either of the arrays is empty all right so the first thing we want to do is we want to say if first is equal to null and second is equal to null in that case we're just going to return no you don't have any values to merge so we're just gonna return an empty array actually not an empty array we're gonna return a null right okay now let's say that one of the arrays you gave me is null or empty all right so let's say that first is null so if I get to this condition this means that first is none but seconds not no so you gave me one array but the other one was null or let's also handle the case here where first is empty if first that length is equal to zero what do I want to do here the if you gave me a null array first it's now but second is okay or first it's empty but second has you know might have some value said it what should I do here I don't really have any work to do I am an empty array so if I have an empty array and one that's full of values how do I merge them together this return the one that has some date in yeah so it's just return second good okay then finally my last condition down here what am I gonna do I'm gonna do something very similar to what I did up here so I'm basically gonna rewrite this I'm gonna say second is equal to null or second length is equal to zero return first good all right so I've handled my corner cases here give me two seconds here I've it's like okay you guys are gonna find out something about me today well one thing you're finding about me is that I'm terrible at using windows finally oh okay okay years ago when I was in college I started having some wrist problems so I switched it does anyone here use the Dvorak keyboard layout any way the keys are in different positions so I've been using this for like 15 years that's why I looked like a total idiot when I need to type on a keyboard for the normal layout but now I'm now I'm good alright what led to one of my key observations about helping students never touch their computer because I can't type on your computer anyway I'm gonna look like more all right so I've handled my corner cases here now what do I need to do so now let's actually create the array the combined their combined array so let's say and we're gonna say make this into a new array and it needs to be big enough to hold all the values from both arrays alright so I've got a combined array now my loop here is going to go through the combined array and kind of pull things one by one out of the two smaller array but I'm also gonna need to keep track of where I am in my small early remember I'm assuming my smaller arrays are sorted so the smallest value in the first array is currently index 0 and the smallest value in the second array is currently in index 0 and I'm gonna use these variables to keep track of where those are so now I've got my loop here I'm gonna go through my combined array using our good old loop syntax all right so now who can who can walk me through what to do here alright so I've now I've set up the problem I've got a loop that's gonna so essentially what I need to do is in each iteration of this loop I need to either pick a value from the first array or the second array and copy it into the combined array at position I so I'm going front to back from my combined array and essentially what I need to do is I need to look at the front of first array the front of the second array figure out which is smaller and then stick that one ok so so that actually there are actually four conditions here but but who give me one of them I'm not gonna put in here yeah yeah okay yeah exactly so let's say here if first first index is less than second second index what this means is that the first array has the smaller value right whatever the value is that I'm currently looking at in the first array it's smaller and so I'm gonna pull it in to my combined array say combined here is equal to first first index and then I'm going to advance my first index so I'm looking at the next value in the first row okay otherwise I'll take stuff out of my second array okay it's going to work let's try it all right I got to put a return statement in here that's kind of saying the one I have right now is he's not okay scroll down a little bit pull this down all right so now down here I'm gonna return combined let's run this code and we'll see what happens Oh okay so I've got a I've got an array index out of bounds exception and it's happening on line 15 so it's happening right here so what's happening here I'm trying to merge two arrays of size four in the array size out of bound exception thy God is of size four so can someone explain to me what happened why am I not done you could try to figure out a little bit more about what's going on yeah in the back yep yeah so essentially that at some point what I'm going through here okay and I don't know when that's gonna be because it depends on you know the values are than the true race but at some point the first array is gonna be out of values or the second array is gonna be out about you so think about it this way when I get to the last value that I put in my combined array one of the two arrays is empty okay and I don't know if it's the first one or the second and so the problem is at that point I've advanced my first index øresund a second index past the end of the array so it doesn't hold a valid value in it okay and so essentially the way I have to handle this is with another set of conditions that are gonna make this statement a little bit less satisfying so I say if first index is first dot length what does this mean so if first index is equal to first dot length what does that mean about first somebody who hasn't volunteered an answer yet today so I've gone through and I've been pulling things off one at a time yeah yeah first is empty right so at this point I'm advanced first index through all of its valid values and it's basically at the end so at this point first is empty and what I'm gonna do instead is I'm just gonna pull so I can essentially cut and paste the code I have down here for a second so at this point the values I need are in second nope stop it let me fullscreen this again I can figure out how to do that again all right so here I'm gonna put right can I successfully cut and paste on a Windows computer or not find out apparently not for real it's the terrible all right one more time the last option key here Wow look at that okay there should be a round of applause for that please all right so the first arrays empty then the values I need have to be in the second array remember the second array is all sorted so at this point I'm just pulling things out of the second round I could improve this I could just stop here take all the values of the second array but let's just keep the outer loop the same okay all right so there's one more thing I need to do right so I'm handling the case where the first array is out of values and then I'm handling both cases where both arrays still have values and I'm picking the one at the front properly but there's one last case I need to handle here which is when very similar to what I have already up here remember I don't know what your Ray's gonna run into values first yeah both arrays are empty I'm done close right so I'll never get to the point where both arrays around yeah so I have to essentially do this same piece of code except for the second array all right so I have to say if second index is equal to second dot Lane then this means that my second array is empty and I should pick something from the first array so again I can cut and paste stop that I can cut and paste this code up here okay so again this has gotten sort of gnarlier then then we would want but it's actually not that not that complicated there there are two conditions I need to handle if one of the arrays is empty so if one of the arrays is empty all the data I need is in the other array the first erase empty takes something from the second array the second array is empty take something from the first story okay if I get down to line 21 it means that both the race they'll have data in them that's really snowing out there cool and I need to pick the smaller bout right and there I'm just using a conditional based on the value of the item all right so let's try this now and see if this has solved our problem with the array index being out of bounds and it has okay and now what you can see is that I've also successfully merged both arrays so now let's try some corner cases here since we're defensive programmers let's try the case where all of the smallest values are in one array the other array only has larger values okay make sure this works that seems like it does we could turn those around and make sure it works too but I'm pretty confident with this right now okay any questions about this this is like the hard I mean to degree the merge sort is hard to implement this is the hard part we haven't actually implemented a sorting algorithm yet what we've done is we've implemented something that could take two arrays together two sorted arrays emerge them together but what you're going to see it was very cool about merge sort is we can use this to build up a recursive sorting algorithm and when we implement the recursive sorting algorithm we'll come back and grab this code but the actual additional code we need to write at that point it's really really quite small all right any questions about this before we move on good sort of recursive sorry imperative programming review you know this is one of those things that's conceptually not hard a little bit tricky to to translate into code okay so now the question becomes how do we actually use this - well let's talk about the runtime of time complexity of this first ok let's go back and look at our implementation ok how many steps is this going to take who can talk me through this here's my here's my just my algorithm here's the implementation of the algorithm sorry how sorry how many steps will this require yeah yeah so to merge arrays of size and an M it's gonna take n+ out okay and on some level if we think about n is representing the size of the combined array this is Oh a okay so if my combined array is going to contain n values I know that when I call the function right if one has five and the other has three the combined arrays gonna have eight all right so I know how many values are gonna be in the combined array it's Oh N and the size of the combined array my loop goes through that array one at a time it's not doing anything fancy there's no break or continue there's no nested loops all I'm doing is array axises and comparisons those are constant time operations okay so another cool thing about this right is that there's no data dependence here all right so if I go back and look at this there's nothing in here like this loop is gonna run combined array size times it doesn't matter what's in first or second all right so this is not like insertion sort where we had breaks and stuff like that that were in there this is never going to depend on the data okay so worst case is o N best cases Oh in average case is owing that's something that we like about merge sort it's predictable and this is really the why right because the merge itself is predictable hey give me two arrays of size combined size and it's gonna take Oh n Demers now again there are some there are some sort of you know cases where you can get a little bit better performance here but particularly if one arrays out of values right but in general away right and again the way that we've implemented this there is no dependence on the values and first and second for how long it's going to take the behavior the algorithm depends on the values of first and second but its runtime just not all right okay so I've now so now we've sort of worked through this observation which is that it's easy to merge two arrays together into one sorted order but how do we use this to actually build a sorting algorithm okay so the question is where did those sorted arrays come from right I gave you two stories of size four but I didn't tell you how to sort those arrays however think about your merge step took choose sorted arrays of size four and created a sorted array of size eight so I have one of the ingredients that I need for a recursive algorithm I have a way to combine the results together if you give me two sorted arrays I'll combine them together and what you get is a bigger sorted array so I'm merging the results from smaller problems together to get a solution to a bigger problem right the question is how do we make the problems smaller first so if I give you the big problem how do you make it small enough that you can start to build up those combined solutions and the answer is to go back to this property of arrays that we looked at when we talked about the fact that arrays are also recursive data structures every sub array of an array every contiguous section of an array isn't a right right so here I can think of this as one array with eight values so I could think of it as two arrays with four values and this one on the left I can think of is to erase of two values and that array on the left I could think of as one array with one value and so I can keep breaking my big problem down into these smaller problems now what's kind of cool about this you know so if I take an array and I break it down let's say I break it into two pieces so I'm always going to split it in half I take an array of size and I create two small arrays of size n over two I take the arrays and I break them down until I have two arrays of size and over four what's the smallest subproblem so now I know how to break the problem down into pieces I know how to put the pieces back together but what's the smallest sub problem here then I'm gonna have to stop and solve a media all right so I know how to build bigger arrays sorted arrays from smaller sorted arrays what's my you know and I know how to take a big array and break it into smaller arrays but how do I get to an array that's already sorted yeah yeah so in a ray that is empty or has one value in it is sorted okay so if I start with an array that's empty or has one value it's sorted and I can take two of those and use my merge function and make a bigger sorted array and then I can take that sorted right and another sort of rate and make a bigger sorted array and I can continue to do this until I've sorted the entire array all right do I have all the ingredients I need here for a recursive solution to sorting it's cool right I make the problem smaller by breaking the array into two parts and what I'm going to show when we talk about the runtime of merge sort and actually in particularly we talk about the runtime of quicksort which we'll get you on Wednesday one of the things that's important to note here is the size of these arrays matters so when I do merge sort I'm always gonna try to break I'm gonna break the arrays into equal pieces as much as I can sometimes if I own an array with size three I'm gonna end up with one of size two and one of size four one if I own array of size seven I get three and four but I can always have them be almost equal right this is important for the run time but here's how this is gonna work we're gonna break the problem make the problem smaller by breaking the arrays into smaller pieces they're roughly the same size the smallest sub problem is an array that's either empty or as one value in it when I get there I'm done an MD array is also already sorted an array with size one is sorted okay so now I have I've solved the problem I created this sorted array how do I merge them back together I use this merge function okay all right so so again to do merge sort which we're about to do our base case is we've reached an array with just one value or zero value all right sometimes that happens because of how the arrays divide up the recursive step is to split the array into two pieces and I combined result by using this really nice merge function that I just wrote all right I just wrote merge so I know how to combine results all right the last thing you need to know how to do that I'm going to use in this example is you need to figure out how to split the array so in order to finish the job here I need to know how to do this step okay now you can implement this function you guys at this point are far smart and enough to implement this function but let's not bother let's just use a helper function that already exists in the arrays library so there's a library of this is a Java library that contains a bunch of functions that run on a rate they don't now this is an important thing arrays as a Java object only contain that one length property they don't actually don't have any methods these are static methods that take an array as an argument and do interesting things too so for example there's one that we're about to use that's particularly useful in here that's called copy of range right copy of range takes a bunch of different types of arrays here we're gonna use an int and it copies the specific the specified range and returns you a reference to that new array all right you might also notice that down here at the bottom are a bunch of sorting functions right that will sort arrays for you right so that's a little bit that's what you would actually do if you were weren't trying to learn how to implement sorting are going to just use the ones that are already built into John alright so the first thing let's before we go on let's go back and get our merge code let's rescue our merge code from earlier where they go yeah here we go I do not want to write this again so and now I know how to cut and paste grab this and then OOP undo well find you here ah sweet cozy control-c and then let's go back to where we were all right this is going to be really cool all right so let's drop in merge here great so I had the merge code that we just wrote and my goal here is to use this to implement merge sort all right so merge sort is a recursive algorithm what's my base case one argument which is an input array what's the base case here smallest problem what do I know when do I know when to stop yeah yeah less than or equal to one yeah so if my input array size so I'm gonna say if input array dot length is less than or equal to one just return input array that array is already sorted otherwise okay and and again this is this is you know kind of kind of cool what I need to do is I need to do two things so I basically have to sort the right half half I need to sort the left half or right is actually let's start with the left one it's a little more you so think about so the left is the first half of the values in the array and I'm going to sort the right half and then I'm going to merge the results okay so I know how to do the merge right so essentially let's say int is equal to or sort here's where I'm gonna use this function from the arrays library so this is going to give me this is going to give me a copy of the first half of input array arrays dot copy of range from zero to input array dot length over to my second and I'm gonna and I'm gonna sort that part all right so these are my recursive steps my second well here let's call this left just because that's what I called it so the left half of my array is here the right half is the result of running sorry I got to fix that I'm throwing over two so this is now the other half of the array I think Chuck style is gonna get anywhere with me and let's like do this okay so now these are my recursive steps I'm writing this out a little bit longer than we will in the minute just so you kind of see what happens right so remember this is a recursive function unless I'm at the base case I don't know how to solve the problem what I do know is how to make the problem smaller so here what I've done is I've said well I don't know how to sort an array unless it only has one or zero elements in it it's got more than that I'm gonna break it into two pieces and rely on the fact that eventually I'll know how to sort it if I keep making the problem smaller and smaller I'm gonna get to do small sub problems now okay so at this point I have a sorted copy of the left half of the array and a sorted copy of the right half of the array what do I need to do to finish the job right so again I don't know how this merge sort function I just call it works all right all I know is that it will eventually sort the array but now I have two sorted arrays one containing the values that were in the first part of the array the one containing the values that were in the second part of the array what do I need to do to glue these back together come on you hacen tributed yeah yeah so I'm gonna merge them yeah that's what I wanted to hear I'm gonna call merge right my merge function takes the left and a right array so essentially what I'm doing here is I'm gonna do merge left right that's it my merge function takes a you know a first in a second array and returns a new array that has twice as many values in or sorry that the the number of the first out length times like no okay let's see if this actually works Oh Chuck Styles mad at me about something hey brackets a legal position weird oh sorry here we go yes declaring a reference to an array uh-huh look at that magic all right like I said the recursive code here is not a complicated any questions about this where we talk a little bit about runtime I can make this even more appealing in the following way so let's just do this let's do return I don't have to create these temporary erase what I can do is return merge of merge sort of that common here now I'm just combining these get rid of the temporary arrays and it works okay questions about this it's our first recursive sorting algorithm down again I've got my base case up at the top and then in one statement now I'm combining both my recursive steps which are to make the problem smaller by looking at the first half of this input array in the second half at the input array I'm calling merge sort to sort those two and then when I'm done I what those return is a sorted copy of the first half of the race or to copy the second half of the array and I use merge to glue those together all right so let's talk a little bit about how long this is going to take because this is a little tricky just getting some intuition for this right so let's walk through an example and let's walk through an example with a carefully chosen value of the number right which is the power to that's helpful I'm thinking about this okay so let's think about if I'm sorting an array that has eight values in the first merge so they think about I go all the way down okay the first merge step is essentially taking eight array so I brought the problem down until a small small small finally I found eight erases size one my first merge merges those eight arrays of size 1 into 4 arrays of size 2 so that's 4 oh and merges where n is 2 okay so this is o 8 right 4 times o n the second merge takes 4 arrays of size 2 and merges them into 2 arrays of size 4 so now I've done - Oh n merchants where n is 4 right remember the runtime of my merge step depends on how big the arrays are so now I did - Oh n merges 4 and is 4 that's also Oh 8 for this step and now I've got a final merge which takes two arrays of size or into one array that has the all the original value Center sort it okay so that's one Oh n merge where n is 8 so what's interesting here is that every level contributes om right it was Oh and to do the first set of merges where n is 8 the size of the original array okay as the merges gets smaller I have to do more of them as they get larger I'm doing fewer okay so I've got o it Oh N for 1o n for the second I went for the third so now what drives the runtime here every step every merge level is going to be a wet right but what drives how long this is going to take it's the number of levels right every level contributes oh and here I had three levels of o n so it and it turns out that some of you that are thinking about thinking this through might have realized that two to the third is 8 8 log 2 is 3 okay every time I make the problem half as small I bird when we talked about o log run times we've said that frequently those were associated with recursive function recursive algorithm this is and so what I end up with is an O n log n runtime that is the best that we can do for sorting in the win you know that is the best that the sorting algorithm can do in the worst case right so now we have implemented a sorting algorithm that does as well as any sorting algorithm that you can find out there in the worst case there are certainly islands would do a lot better in the best case but this one will do better do as this one achieves optimal performance every time all right so here's another visualization of that to sort of how things are coming through right so at the top I have 8 values now I've merged them into 4 sorted arrays at the second level I merge them into two sorted arrays at the third level I've got one sorted array with everything it number of levels is login in the size of the array each step is OS so to combine the two together I go ghetto and login okay I think we'll stop here pick up here on Wednesday sorry about the technical difficulties today please stay warm out there looks like a blizzard going on a snowball fight joy some beautiful snow and I will see you guys on Wednesday  
﻿ all right back you guys hear me I'm back yeah I know that hold on wait did someone say the slides were working all right yeah and like half of our cs1 25 cloud is down so if you go to the slides I think they will work it'll take a minute to load and then it looks blank but click the X and close that and then they will load I'm using the same thing you guys are using so I just tried to tweak something a minute ago to get this back on line we have like 12 machines set up configured into a essentially our own private cloud that we use to run a lot of the infrastructure for the course whether that's the slides the playground Auto gradient which is also down right now at some point last night about half of those machines look like they went offline the management interface that I usually use to kind of reboot them it's also offline so anyway the IT people know about this and I will go pre fire at them later but here we are and happily we don't have to use the playground today because we're gonna keep talking about the internet and keep talking about the web all right so this is a just a fun day last time we started to talk about what the internet is and we looked at that in a couple of different dimensions by the way there'll be attendance for today will probably not be counted I'm not gonna make any promises I'll look at what the data looks like all right so based on our conversation last time we observed the fact that most of the internet first of all the Internet is reliant on a huge amount of infrastructure this is probably like trillions of dollars that have been put into things that are eventually have eventually become the Internet a lot of its been built on top of older infrastructure whether that was you know fiber optic cables that follow the old train lines or the fact that for years a lot of the signals that made their way to your house traveled over lines that were built for previous communication systems like the phone lines and stuff like that most of this infrastructure provides wired connections but you guys have gotten increasingly used to having wireless to store last hop right so in here as you wander around campus a lot of times how many people actually have a have a computer that is plugged in to an actual Ethernet jack how many people have one of those okay so about half of you yeah that's becoming increasingly rare right and this is my main machine and it almost never gets actually plugged into something other than power all right you know the internet revolution is largely made possible by really high-quality glass that we've used to create these fiber optic cables it's one of the unheralded of the modern world it's all of this glass cable that we built to carry these signals around so that we can connect with each other all right and we also saw a little bit about the wireless infrastructure in this space or the short-range wireless all of these access points I have no idea how many there are this is also an example of this really kind of beautiful fascinating completely organic system right nobody manages all the Wi-Fi access points in this country they're just throwing up all over the place if you go to New York City you go to Chicago you go to an urban center if you take your phone out you know into the denser part one of the denser parts of town a lot of times you can see like hundreds of Wi-Fi access points right imagine a you know apartment building every single apartments got at least one if not several and then we also have all of this medium range wireless infrastructure that we built up to allow you to be connected even when you're outside the range of Wi-Fi so again all of this building all of this infrastructure all of this investment devoted to one thing moving information around allowing people to communicate with each other across time and space in a way that was never possible before you know computers are part of the technological revolution that you guys are living in but the Internet is a huge enabler right if we just had a bunch of computers there weren't connected to anything else I mean it might be fun to play games on I might use them to solve some problems with stuff like that but the cannot connectivity that we've achieved has really enabled some cool things and we're gonna get back to that later today when we talk about web api's web interfaces all right so at this point we have billions and billions of devices that are all connected to the shared medium and can send information to each other they can send signals you can think of these as signals for now all right I can send some type of signal and last time we also talked a little bit about the protocol that the internet establishes for exchanging information between two computers that are connected to it that IP protocol specifies two things right one is how do we address each other right I want to send a or establish a connection with a particular computer I need to know how to address the data that I send to it so that the data will get there how do I know where this signal is trying to go and also when it wants to send me some information back how does it know where to contact me okay so this is IP addressing and we've seen several generations of this now over time from the original IP address space which was only big enough in theory to address four billion machines but in reality out actually allowed us to address far fewer than that to this new ipv6 address space that's increasingly being used that allows us to address just an unfathomable number of computers this is all we need for sure these addresses are less readable because they're bigger they contain more information and then IP also specifies a format or a data structure for those messages so that structure contains the addresses that we talked about but it also contains data that's what we're trying to move around the content of your news feed the content of your text messages the content of your request you send to Amazon to purchase something the content of the little messages that your computer sends back to our server that let us know whether or not you're following along in class data ok all right so one of the fascinating stories from the early evolution of the Internet was this big and I'm not gonna talk about this hopefully not for very long although it really is really interesting this big struggle over two models of connectivity so I put this so so some of you may or may not seeing a photo like this so that this is an old telephone exchange how many people have ever dialed the operator before for any reason anybody people do that anymore I don't know like just for fun just like poke pull a prank so when that when telephone lines were first established every phone call started with the operator because literally oh man this is really we're struggling with this today your first call when you picked up the phone what would happen is that you would end up talking to some nice person because your phone connected to a switch board like this and the operator would need to know where do you want to place the call and you would say oh I want to call my friend Joe over it whatever and a lot of times if it was a call that was in town the operator knew you this is someone that you would see around might be even a friend of yours or a neighbor they knew where other people lived etc etc so they would say okay I'll connect you to to Joe and they would literally you see what this this person is doing they're actually like plugging wires in like one into these the spot so essentially Joe's phone is connected to one of these one of these pegs in the switchboard and the way you establish a connection between two phones with some literally like you would plug in a you know the the operator would plug in something to that jack and now there's a literal physical connection there's a wire that's connecting you and your friend there's phone starts to ring when they pick up the connection is established and you're talking to each other but the operator did all of this and for many of you I think you know when people are asked about how the internet works this is the model that we still have is that somehow like when you go to Facebook there's like a wire that leads directly from you to Facebook that's only used for your communication right not used for anybody else because as soon as you set up one of these circuits the only two people talking are you and your friend alright it's literally as if you had two headsets with the wire connecting you and the operators just here to kind of make this one switch that needs to happen so that that can actually take place what we actually do online on the internet is something that's called packet switching and when this was you know invented or theorized this caused a huge debate within the telecommute telecommunication community between people that thought that this was the future who turned out to be right and the phone companies that were incredibly determined to preserve this old model of phone circuits right so that's what they understood the phone companies this was sort of like the first time that you see a major you know technology company have to go through a completely paradigm shifting innovation you know Netflix did this right Netflix started out by sending CDs around in the mail they got really good at that and now they're actually making their own shows and doing streaming so that actually managed to perform a really impressive pivot within the space of streaming a lot of people said Netflix has done right you know what all network flicks got good at was sending DVDs around in the mail they're not going to know how to do anything else it turned out they were wrong but that's a pretty impressive thing to be able to do the telecom companies were really good at building these circuit switch networks and so at some point people came along and said hey I have a different idea for how to do this first of all we need data that we can break up so this is inherently involves digital information these old phone networks are not transmitting digital signals these are transmitting analog signals okay it's like a speaker wire there's gonna be a sine wave running through that that goes from your house to your friends house what we do online is that everything is digitized so everything is turned into numbers remember when we talked to very beginning in this semester we talked about the fact that in order for computers to process information we have to turn it into numbers okay so your phone call the contents of your speech have to be able to convert it to be converted into series of numbers right that's what we do is sound we take sound and we convert into a series of numbers that measure the strength of the pressure wave at a particular point in time and we can use those numbers to reconstruct the sound at the other end this is step one we digitize things once we do that now I have something that I actually can break nicely into little pieces and these pieces are called packets okay so a packet on the Internet contains a certain amount of information and normally in order to transmit anything that's even of reasonable size like if you want to download a photo or you want to even go to a website and just look at the content of a webpage or you want to stream audio or video what happens is that data reaches you in a series of chunks called packets each packet contains some small amount of the movie some little bit of the photo one or two of the characters in the tweet right actually tweets probably fit into one packet they're pretty small right but emails probably take multiple packets so one part of the email another part of email it's broken up a little pieces and each one of those pieces goes on a separate journey across the internet from the start point to the end point and along the way they may follow different paths so if you're on if you're talking to a server in California some of your data may go one way and some of your data may go another way we saw based on that map last time that there's a bunch of different paths the data could take from here to California so when you go to Facebook and check your newsfeed or Instagram and look at photos some of the photo might come you know through you know of some of it might come you know one direction some of it might come another direction okay so one of the things that's cool about the internet protocol as well is that there's a protocol to sign guarantee anything about reliable delivery so this is one of the really important and very powerful things about the internet protocol it doesn't try to do too much all it does is two things it says look I will give you a way to figure out how to identify hosts that connect to the internet that's the address name and then I'm gonna provide what's called best effort packet transmission so computers that are part of the internet backbone that are going to call routers let me do the following thing called a law and they take a packet that they receive over one of their connections so they're connected to at least they have at least three incoming connections sometimes more they receive a packet on one of their connections and they look at it and they make this split-second decision about which one of the other connections they're going to route it over so it's like you know your so you're standing there's something gives you a piece of information and you can either go right for even go left all does all day long it as fast as the highest speeds possible and so all that router is doing is trying to get the packet one stop closer so basically there's a router in the middle of the country and if you're on line with their computer in California it sees a packet coming from you it looks at the destination and it says I know how to get this packet one hop closer so I know that I can send it to another computer that I'm connected to if I'm located in a Colorado maybe that other computer is located in California okay so it's not to the destination yet because it hasn't arrived at Facebook server but that's that computer in California is closer to where it wants to go so this is all they do all day long now what happens if the router gets overloaded let's say that suddenly a lot of people want to send data back and forth the particular place and a router can't keep up with the amount of data that's coming across it what does it do drops packets yeah this is this is routers are allowed to drop packets the Internet Protocol doesn't guarantee anything about the packet making it there so you may send a request to California and halfway to California the request may end up at a router that's like you know what I've got way too much work to do I don't even have any space left to store these new requests I'm just gonna drop yours and poof it's gone now obviously in order for the internet to work properly you have to do something about that and that's gonna go into you know things that I'm not going to talk about here that but are that are very very interesting but the IP protocol does not guarantee anything about reliable delivery all it does is say we'll do our best to try to move your data from where it came from to wherever it's trying to go they do that one step at a time so pack this whole idea of breaking data into these little chunks and then moving it in this way was completely revolutionary when it was proposed and again the phone company executives hated this idea because it had was antithetical to everything they believed in they understood these circuits which networks there's actually a story about some of the earliest people that were proponents of packet switch networks we're interacting with the phone company and the phone company set up like a whole multi day symposium where they brought in a bunch of their engineers and a bunch of their you know people and there basically was all designed to convince these one or two people that packets which it was a bad idea that's all the whole goal was was to talk them out of this terrible idea yeah the two people went they were like now we were suppose we're still right right and it turns out that they were so today most of the time when you talk on a phone particularly a mobile phone the first thing that happens on your phone is your voice gets digitized and broken into little packets and so even these old voice connections that were the foundation of you know the telecommunications networks that preceded the internet even they have been replaced by packets and packet switch networks right we've just decided that this is the right way to do it and now even more most voice traffic moves that one alright so one of this so you know one of the cool things about IP is that it doesn't do much and by not doing much it gave birth to this really beautiful ecosystem of other protocols that are allowed to run on top of them so if you want to develop an internet protocol today you can do that you can write your own protocol with its own rules for doing a particular type of thing and you can run it on top of the Internet Protocol and so we've come up with all of these new protocols and this is the one we're going to talk a little bit about today that exists to serve specific applications so one of the reasons we're talking about this is I want to dissuade you from this idea that's very normal to hold that the Internet is the web the world wide web is one application that runs on top of the Internet Protocol it has its own protocol it has its own formats that we're going to talk about a little bit minute it has you know a certain use you guys use it all the time but it's not the only thing that we do with the Internet all right so there's something called the hypertext Transfer Protocol what service or application does this support does anybody know I suspect you know the answer to this where do you see HTTP or frequently HTTPS yeah and your browser bar yeah so this is the protocol that supports the world wide web we're going to talk a little bit about HTTP in a minute HTTP is a separate protocol with its own rules but it runs on top of IP so IP provides the transport layer for all of these higher-level protocols okay but HTTP is not alone what about this anyone know what SMTP is this supports something that you guys do all that well I don't know some of you are starting to see this as an irritation because you're using newer communication medium but still pretty important to read what SMTP supports something time to time you guys get important blank anybody know ya email ya SMTP supports email and that's actually SMTP is interesting SMTP is the protocol that mail servers use to talk to each other so when you send a message to your friend that goes to another school the first place that message goes is a server on campus then the server on campus at some point we'll send the or message over to the server at the other school using something called these Simple Mail Transfer Protocol or SMTP a DNS the ones that does not and with PE but it is itself a protocol again this is something another one you guys use all the time every time you go to a web site every time you send an email message every time you do anything online anybody know what this does yeah yeah so DNS is responsible for so so you know we looked at those IP addresses how many know how many people have ever typed an IP address into their browser part like you you probably you probably shouldn't do that by the way usually bad idea but most of us don't do that we don't type 172 to 2.8 5.11 into our browser bar we might type facebook.com or google.com or whatever right DNS is responsible for translating the human readable names that you guys use that are good for humans like CS 125 dot CFO Illinois dot edu to actual IP addresses that can then be used by the IP protocol so every time you guys load a web page the first thing that happens is your web browser has to figure out ok they typed in this this web address what IP address does it correspond to and you can invent new internet protocols this has not been as big of a deal recently people are I think there's been more activity in building new protocols on top that sort of operate within the existing ones but there have been some cases recently where big companies both so for example google google you should be a little bit afraid of Google operates a highly used website in fact it operates a bunch of highly used websites google.com Google Docs Gmail whatever it also provides a browser so a lot of times some of you are using a Google piece of software or your web browser to talk to another Google piece of software one of Google's websites and Google's actually started to experiment with a new transport protocol that's built on top of IP but it's designed to replace some of the other transport protocols that are out there because they said you know what those older protocols don't work very well so if you're Google and you control both sides of a lot of network connections you can get away with it all right so I just want to I just want before we talk about the web I just want to make sure we understand the internet itself represents a framework a backbone on which a bunch of different protocols are built ok and you know there is there's others whole bunches of other protocols I haven't talked about here so if you look at the track think that's going across the internet at any given point in time is a lot of it web traffic probably but there's a lot of other types of information and other protocols that are also using the Internet a lot of its email there's a specific protocols designed for chat and other types of information exchange all right so now let's talk about the web all right so now we have some vague idea of what the Internet is as physical infrastructure as protocol and is a building block for other protocols where we want to exchange information between computers so the world wide web is one specific protocol HTTP which we already talked about the HTTP protocol establishes a way for two computers to exchange information it gives me a way to request data from a server and also a way to send data to a certain there's two other parts of HT of the web that you might be familiar with actually three other parts one is something called a markup language so this is HTML we'll go through each one of these briefly in a minute HTML provides some of the content that is moved around by the world wide web although not all of it the HTML provides a way to give your browser a semantic description of what a website should look like that the browser then renders into what you see okay the web also has a styling language called CSS that's used to control how websites look and then there's also a programming language that's heavily associated with the web called JavaScript one thing I will get out of the way right now and help you with because it took me about 10 years to figure this out there is no relationship between JavaScript and Java okay I'm serious I thought this for a long time for real I was like oh it's the scripting version of Java whatever that means right javascript is it's a completely different language unfortunately they have the similar name they are completely different languages fun how they co-evolved it's a fun story but they have nothing to do with each other like Java and JavaScript have no form relationship other than the fact that they're both computer programming languages all right so let's look at each one of these in turn so when we talked about the IP protocol we said protocols establish structured communication between two parties this is what they do in a compete in a computer system protocol set rules that need to be followed that's something that they do both in a computer system and you know in diplomatic exchange for example so the HTTP protocol defines a bunch of different verbs or different types of ways that a client can interact with the server so when we talk about HTTP we're normally assuming that there's some clients somewhere that's a device that you operate okay your phone your web browser and then there's a server somewhere so somewhere in the server room somewhere on campus I don't know where it is it's a machine especially a virtual machine but that's not important whose job it is one of its jobs is to serve CS 125 dot CS Illinois ddu there's a machine that does that the web server that we set up somewhere that doesn't so your client so when you go to our home page your client sends a request to our server and says hey I want to see the content of this page okay so every time you load a page the request type that's used is something called a get request hey again does what it sounds like it sends hey I want some stuff I want some information okay what's why it's nothing it's often today we're with the campus IT infrastructure the only other request that's somewhat interesting to talk about HTTP like dozens of these right you can go and look up and they sent they have some of them are useful but the other one that you use all the time is something called a post so get requests are used to ask the server to send you some information a post request is used by your browser to send information to the web server and when you think about most of the browsing you do online it's it's most of it's a pretty one-way relationship the server's sending you lots and lots of information you're not contributing very much back but there are times in which you do you post on Facebook you buy something on Amazon you you know click back and forth on our slide decks or whatever every one of those actions represents a case where your browser has some information it needs to send to the server we need to tell Facebook hey I've got this new post for my feet you need to tell Amazon yes I want to put that item in my cart or yes I want to buy everything in my cart right so every time you submit a form of any kind pretty much anytime you press submit or enter and something changes about the world that you can observe what your browser is done is set a post request that's a way to for your browser to send data to the server ok so get in post have slightly different semantics I'm not gonna go through this in detail but part of the idea here is that git is not supposed to change anything about the world all get does is send you some data the request that's allowed to change something about the world is post so you should be able to get a page over and over and over again and nothing changes with post on the other hand something changes your Facebook feed has a new item on it your credit card gets charged and there's stuff that's being shipped to you from whatever vendor you used online right ok so so how many people we've we've usually we've sort of made this go away but how many people have gotten those warnings about like don't three submit the form again because whatever or something bad will happen this is why right because sometimes if you submit a form you might get like twice the number of items in your cart that you were expect all right so let's talk about these building blocks of the web for a minute all right so if HTTP defines how we ask a server for information there's also a the question of what do we get back when you go and browse and load a website what do you receive from the server so this is a little bit of chunk of HTML and not going to go through this in detail this is like enough content for in a whole another class but hTML describes how a page is structured okay now structure and how it looks are different okay and they're separated on the web so here's a here's an example of HTML content right so this tag does anyone know what an h1 is in HTML anymore so for ya this is a top-level header HTML defines a bunch of different header types an idea is sort of like an h1 is more important than an h2 which is more important than a h3 which is more important than H for which it's more important than age six right there's 600 types okay so this is like some important content on the page that's all I know about the website doesn't tell me here that this should be big or bold or whatever it just says this is important so this is semantic information then I have something called a P so each one of these this is the open tag and this is the close tag so the open tag is P and then the close tag is like a forward slash followed by the open tag so what's in here is a paragraph again this is semantic information this is a paragraph of text I don't know anything more about that except that it's a paragraph that you might see in a book right it might have some white space above then it might have some white space below it it's a single unit of in textual information right it's not a sentence it's not a word it's not a character it's a little bit higher level than that it's a paragraph okay I have something down here anyone know what an L is went down a little bit of of HTML hacking yeah this is a list and it's an ordered list so HTML has two types of Lists there's both ordered in an unordered list and then inside by a list each one of my list items starts with an a tag called Li and then so these are items in the list so first I say I'm gonna have a list and then I have the items that are inside of it now again a lot of times ordered lists are rendered using numbers all right unordered lists are rendered using bullet points or some other thing to indicate it to life okay and now down here I've got again here's a here's a tag called strong what does that mean no no strong it means the text inside here is strong right sort of deserves some emphasis the thing I want you to note about this is that again this is semantics there is no instructions here about how this should look nowhere does it say strong should be bold no where it doesn't say h1 should be bigger no one doesn't say no where does it say a paragraph should have a little bit of white space on top and bottom or whatever right no where does it say that an ordered list should start with numbers that's not part of the semantics right that's part of layout so if you loaded this into your web browser here's how it would look okay and you notice here that my web browser has made the text in the h1 big and it's also added numbers to my list and it's put this in bold and it's added some white space above and below the paragraph the browser by default comes with what's called a built-in stylesheet that'll do some of this by itself so if you don't give it any information the browser says you know what I think an h1 should be big and bold right and so that's what I'm gonna do I think an ordered list should have numbers attached to it so it'll kind of do some of this by default if you want to what happened to my CSS come back and do this in a minute all right so let's talk about CSS well go back and talk about the evolution itself so what CSS does is it defines how the website looks okay and again I'm going to just skim over this but a CSS file or CSS set of rules is sent along with the page and it allows you to tell the browser how you want the page to look so here I've set up some rules so for example my h1 is going to be 48 pixels font size okay and I want it to be bold I also want the font that's used for the body of the document that's pretty much the whole thing to be a sans serif font so that's a font that doesn't have those little you know sharp things on the corners okay so now here's what my page looks if I send that Paige with this piece of CSS what happens is I get that that's awesome I have you can see that my title is still large but my content has no that's no serifs and so I've given the browser some more information about how things should work okay all right so here's the fun part all right and here we'll talk about this and we'll go back and talk about the evolution in the web so the web has become when the web started out it was essentially a way to distribute mint documents hey you sent me a website and I looked at it and I was like that's a nice document so you can think of the early web is kind of being like a nicer version of PDF you know most PDF some PDFs are now try to do fancy unnecessary things right but most of them don't they're just like a document you look at right the webpage at this point what started to happen is that the web has become instead of just a framework for distributing documents the web is a tool to use to distribute hope every time you go to a web site almost every website you use unless you're using some like really dinosaurus old web site that it's like refused to add any of this along with the HTML along with the CSS you also get a piece of code written in a language called JavaScript hey JavaScript code runs in your browser your browser knows how to interpret JavaScript so that's actually a way if you want to open up a special tab in your browser where you can actually type code into it and it will run it for it okay so what happens is you know and and I shouldn't say what happens is this is entirely what powers interactive websites Google Docs you know all the music players you guys use all the photo apps you guys use pretty much everything you do online try disabling JavaScript you can still do this in most browsers you can turn it off and you will discover that nothing about the internet works anymore okay the reason is that every website you visit is actually now a small computer program sometimes a huge computer program like Google Docs is incredibly complicated right it's a full-blown editor it's like trying to be Microsoft Word but it's written in JavaScript and it runs in your browser okay so here's and again you know I could teach a whole course on JavaScript it's certainly not gonna get that across in two minutes that I have left but here's a little piece of JavaScript okay and I'm not gonna six plain what this does or whatever or what the semantics are this they're probably pieces of this will look a little bit familiar to you if you program Java but some of this is gonna look very unfamiliar javascript is a very different language so here's what this does this piece of JavaScript will bring us back in time back to the days of terrible web design and back to the days where you would end up on a page like this hey anybody remember blinking text yeah you're all too young right used to feel like this was like one of the primary ways that websites would get your attention you would like go to the website and like five different parts of it would be blinking you know blinking blinking blinking they would never be synchronized it'll be a little off right I'll like you know so again like do I have your attention this is a simple webpage and it's blinking alright that's done with this piece of code that's all I added to the previous example okay and again I'm not going to go over what this does but by providing JavaScript my page can now become a computer program and that's so cool right I mean again most of what you guys browse online are now not web pages they are web applications you send email online using a web application you might write a paper online using a web application I think fairly quickly I expect within five years ten years most of the programming that we do is going to be done online you guys already do that in Prairie learn but think of something like Android studio maybe a little bit less fully feature but that runs in your browser you have to do any setup you know you have to store anything locally you just go to a website it's kind of like the Google Docs or the Microsoft online whatever it is version of our current IDs that program is going away it's going to be implemented online and that'll be a lot more convenient okay so so this you know JavaScript really reflects you know the evolution of the web so at some point again what happened is that most of the sites you visit sent you a document okay then we entered it era where when you browse to the site it would think a little bit okay it would it would use some information about you so a great example of a site like this is any store that you go to right particularly really sophisticated ecommerce platforms like amazon.com so when you go to amazon.com you don't get the same page that somebody else in the room does or that somebody else in a different City does there was someone else in different country does Amazon uses all the information it knows about you to produce a home page that is designed with one goal in mind and what do you think that goal is they get you to buy something right you know so the idea was it was I was like well no there's no one page that's gonna work well to get everyone everywhere to buy something instead I'm gonna tailor the page to each users so again when you go to Amazon if the page it produces it's not sitting there on disk somewhere it's created on the fly and it's created based on everything that Amazon knows about you where the request is coming from who you are if you're logged into Amazon what you purchase recently all this information it uses to produce this one beautiful page with one goal okay and so but now we're into this era where it's much more common for a page to rather than do a lot of work on the server to basically send you a big chunk of JavaScript okay where the server essentially provides data but the JavaScript that runs in your browser is doing most of the work so for example our grade page works this way so when you go to our grade page when it's working it's probably down right now along with everything else when you go there what happens is that this framework sends you a huge amount of JavaScript that starts to run it requests data from our server about your grades in the class and then uses that to render a page that shows you you know the graphs and the scores that you see okay so let's go okay so now I've ten minutes and so now I can you know get to the place that we were trying to go this whole time which is what is a web api alright so we had the internet we had the web and and it's you know people start to realize hey this is a great way of moving data around and I have these two things I can do with the web server that are important I can request information and I can send it data all right so what else could I do inside this framework okay so the first thing we have to do we have to unpack is what an API okay so the API is an application programmer interface remember we talked about interfaces when we talked about Java and I said this was a general concept that applied you know much farther than just the Java concept of an interface an interface describes the set of things that an entity can do for you okay an application programmer interface is specifically designed for you to use you are the application programmer in that sentence the interface is provided by somebody else and what they're doing is they're saying hey if you want to build an app that integrates with our service like let's say you want to process photos online let's say you want to build something that uses data from github let's say that you want to use weather data whatever let's say you want to use data about the bus service around here which is publicly available I'll provide a way for you to get that information and maybe I'll provide a way for you to do various things over the web this is called an API it's an application programmer interface it's for you the application program so here's let's let's go through this with a simple example so here's an example weather API ok and you can imagine designing this is probably has a lot more functions than this right but here's an example of a weather API in Java ok so I have some weather info class that my these functions are returning and I have a way to get the weather at a particular location I have a way to get the weather at a particular location in a particular time these are overloads and then I have a way to figure out a location so these require this weather location object right how do I produce one of those well let's say the user gives me a string that says Champaign Illinois and I want to use that to produce a weather location I can do that as well okay so these three functions working together might be part of an actual interface I could create in Java and that idea here is to create something that allows me to query the weather okay I'm assuming I have data about the weather that I'm trying to provide right unlike for the national weather service system I got okay now you could you could probably find like a Java library that would allow you to do this you would just program it up in Java like you normally would and you'd have to figure out like how to use the library you know what are the fields on a weather info object you know blah blah blah right but consider that I can do the following I can send information to the server okay and I actually have a couple of ways I can do this there's also something called URL parameters and a get request which we'll talk about in a minute or on Wednesday and the server can run code and it can return a response and here's the thing that's key okay the data that a website sends back does not have to be HTML okay I can set up a website that sends back anything I can send back a text I can send back binary data to corresponds to a photo I can send back whatever I want and so a web api will typically not give you a website so I could give you a web page this will give you an HTML document why not because the information it sends back is to be used by a program not by a person it's not something you're gonna look at a website's design to be rendered so that you can see it and process it visual data we need to structure a different way so what we're gonna do is we're gonna utilize the fact to build a web api we're gonna leverage the fact that a web the web protocol allows us to move stuff around and web protocol does not dictate that the content returned from a get request be HTML I can send back anything I want this is a historical reason so one of the reasons people started doing this this was hard to build custom protocols because the computer security people on campus decided that it was unsafe to run these protocols and they block them variety everything but HTTP is typically something that you can use and so this is one of the reasons people started building essentially protocols and new interfaces on top of HTTP rather than building a new internet program all right how much time do I have left I think this is probably a good spot to stop and pick up on Wednesday I have a couple of announcements today they're important so the first one is the blue team finished the machine project last night congratulations to them the orange team has their due date tonight hopefully we can get the gradient server propped up again all right so the last thing you guys have ahead of you machine project esque is the final project the final project description is not up yet for anybody to view we will have it up tomorrow for you guys to review in lab and tomorrow's lab will be the first time that you get to start working on it which will start with finding a partner ok you're finding a team to work ok so this week's quiz I just want to so this is important you guys are gonna want to hear this this week's quiz the multiple choice questions are on sorting the programming questions are not on sorting ok the reason for that is if I give you code for a sorting algorithm in the multiple choice questions I'm not dumb enough to ask you to then implement that sorting algorithm in the multiple in the programming questions alright so we'll do that after break when hopefully you've forgotten everything you ever learned about sorting all right I'll see you guys on Wednesday good luck finishing up the machine project  
﻿ [Music] balcony can you hear me okay great welcome back to CS 125 so today's a really exciting day actually I hope you guys had a great long weekend have you been keeping up with the homework it's a beautiful day outside but what I'm excited about today is that we're going to talk about a new way of working with data in our computer programs and there's several points at this during this semester where we're going to expand the kind of data that we can work with and today is one of the most important moments because up until this point we've seen some of the things the computers know how to do and some of the things that computers are good at but that's not very interesting yet and that's mainly because of limitations with the type of data that we can actually work with an access so so far we've been talking about doing math and making decisions based on single data values but today we're gonna talk about ways to store multiple data values together and our initial exploration into richer use of data still comes with some important limitations but it's still way more interesting than what we've been talked about so far and it turns out you could do a lot with the new way of working with data that we're about to talk about so one of the changes I was looking at this lecture last night from last semester and I was like huh I think I made a classic in the past when I talked about this topic I think I made a classic computer scientist mistake so a lot of us love this stuff we're very interested in it but sometimes when we talk to people about it particularly people who are new we make this classic mistake which is we kind of talk about how to do things before we talk about what or why you'd want to and so I've essentially inverted the ordering of the topics today to try to give you a sense of why we have certain language constructs in Java that we're going to talk about later okay so we're going to talk about doing things over and over again very fast but we're gonna start out talking about why we would do this why I would want to repeat something and it's mainly because of this new way of storing data so like I said so far we've been talking primarily about ways to store single data values Jonathas primitive types allow us to store a single integer or a single number with a floating-point component or a single character or a single truth value but again this is really really limited there's not much a computer could do if all could do is work with single values we want to hello that's interesting okay someone has hacked into my chromecast don't do that okay this whole setup here is like about to fall apart at any moment right so hopefully that's not a precursor of bad things that are to come all right so we're talking about single data values and Java does primitive types allow us to work with those but let's try to you know in enrich our vocabulary here what if I want to work with multiple values so I create multiple variables but with two int so I could create two int variables and give them each names but again that's still really limiting it gets messy very quickly what I really want to do is I want to be able to work with an arbitrary number of values and for now let me put into place this stipulation this restriction which is they all have to be at the same type so what could we do we could take those Java primitive types and instead of working with one at a time we could work with a bunch of them at a time what new kinds of information like I said this is a huge you know explosion in our ability to work with data because what new kinds of data can we now represent and work with in our computer program somebody give me an example sure you can think about yeah and batter a string yeah text what is text text is a series of characters so we have the primitive type available we need to represent this really interesting data source this stuff you can do with text it's actually one of the things the computer science has come to sort of late because human speech is actually really messy and hard for computers to work with but now that being able to mine text we've also taken some time to get all this data into our computer systems right so all the work that you know various organizations have done oh wow it's like don't do that all the work the barriers organizations have done at digitizing textual information so once you take all of those books in the library and turn them into texts turn them into sequence of characters now computers could work with them and computers could actually do really fascinating things for that information we're just getting started seeing the kind of impact that that's gonna have so things like the Google Books project or not I don't know what that is but it is bothering me too well let's see if there's one of you making that noise let's see here right okay is that gonna drive you guys nuts I don't know what is making that high-pitched whine but not much I can do that okay so text back to text so once we you know start to be able to allow computers to work with text there's all sorts of really cool things that we can do with that so strings what else yeah okay yeah so a table is really just you know you know it's two-dimensional but on some level I can take that and flatten into one sequence of data and so now I can start to associate multiple values with each other like in a spreadsheet what else what about if we just think about single series of data right tax this one thing what else it's all sorts of stuff out there yeah DNA right what is the human genome yeah someone is good at reading the slides there we go thank you Wow right you're following along that's good you're gonna get participation points for today yeah so DNA right your cells our data we've turned them into data we've turned them into data by digitizing that information right once it's stored in a computer now no computers can use that information to do really cool stuff right okay what else time series data like anything that happens in time that you can measure like temperature right like humidity air pressure all this stuff about you know the world around us right what's a particularly interesting time series data that you could potentially do you guys probably see enjoy all the time it's up here on the slides music music as a form of time series data is just a bunch of measurements of air pressure that's what sound is my voice whether it's reaching you through the speakers or through the air is causing the air to vibrate right and the microphone is turning those vibrations into a series of measurements which are then being transmitted over there and somewhere in this process some thing is interfering with this whole system and causing this high-pitched scream okay so again a raise may seem really basic we're talking about them and it's week one but they're super powerful because they really dramatically expand the kind of data that we can work with the other thing I want you to recognize about arrays and this is not a class about learning about how the low-level details of your computer actually work but the most accurate representation of how your computer actually stores information internally is that everything is one giant huge array of integers so if your computer has 32 gigabytes of RAM that means while it's running it could remember 32 billion numbers and the way those are organized is as one long series and obviously you guys could go on and take multiple future courses about how that actually works in practice and how we make that okay all right so an array in Java represents a series of zero or more values of the same type so there is our limitation we will talk later in this semester and of course things get a lot more interesting once we start talking about the data that we can represent when we start mixing different types of information together it's a little bit of characters a few integers and now I can represent information about a person right they might have a name and an age and a weight and stuff like that but for now we're talking about a series of the same type now you can create an empty array in Java it's not particularly useful but you can do it but this is the limitation and job the arrays have to have the same type right so arrays are actually awesome I want to make this clear because this is really important it's important to understand somebody's concepts when we talk about the easy instances of them so that you have a mental model when we start talking about more complicated things so we have a whole course that you guys will take in a few semesters on data structures but arrays are a data structure data structures as their name implies add structure to data they take a dish they take data the raw data and they structure it in a way so that there's additional information added to it so arrays are an example of doing this so what what does an array do to data so imagine I have like a deck of cards sitting here that's all jumbled up and I put the cards into some order I've created an array of the consists of those cards the data is the cards the array has put them in order so now there's an additional piece of data sometimes with all this metadata data about data that I've added to the system I not only still have the cards but now each card has a place in my ordering okay that's a position so arrays put values in order and the order in order data is really important so for example if I took a human genome the human genome only has four symbols in it okay so if I took it and I just jumbled it all up it doesn't work anymore right it wouldn't create then the proteins required to create life it's just a mess right it would just there's nothing there there's no information same thing for example if I took music music at its fundamental level digital music is just a series of numbers that are in a very specific order but if I take those numbers and just jumble them up throw them all over the place I get noise that sounds actually probably a lot like white noise right it's not music anymore I've lost the structure so when you take away the structure that arrays bring to data a lot of times what you have locked is nothing and so the structure is an important part of what the array is doing all right so once I put values into an array I am an additional piece of information about them that I refer to is the index that's their position in the array so again any data structure adds structure to data and the structure itself is data the structure is information so once I put values into an array not only do I still have the values but I also have each has a position in the array so I've added information alright so let's look at some syntax for actually doing this in Java so on line two of my example I'm showing you how to declare a single integer this is review from last time and on line four I'm declaring an array of integers and you'll see what I've added here is this bracket syntax so when I put brackets after the type in Java I'm telling the computer this variable called multiple is not just going to store one int it's gonna store multiple integers it's gonna store an array of integers so I'm taking a some number of integers I don't know how many we're gonna come to that in a minute but this variable is not just gonna store one it's going to store more than one zero or more integers so I have to type and I have the bracket syntax to indicate that this is an array I can do this with all of the Java primitive types so down here I've created an array of characters on line seven my review I'm declaring a variable called one that serves a single character on line nine I'm declaring a variable called all that stores an array of characters okay so this bracket syntax is how I tell the computer this variable is not just storing a single value it's going to store more than one dot usually so when I declare an array it's empty but I also have to tell Java how many elements I'm gonna put in it and this is one of the limitations of this data structure in Java that if you've learned some Python or if you learn some JavaScript or even languages like go or whatever you may or rust you may not be familiar with this limitation but this limitation is actually goes back a long time to the earliest computer languages so when I create an array in Java I have to tell the computer how large it is before I start using it and then afterwards I can't change the size of that array now I can you know create a new array that's bigger and copy the data over and stuff like that but the original array is always going to be the same size so the array size is set when I initialize and to clear the array so on line two I'm creating an array of integer what's the name of the array multiple and then on the right side I have an initialization when I initialize the single value I typically had a literal over there but I could also have another variable here I have some new syntax literally new syntax so you see a keyword here new the same type that's over here on the left side and then inside the brackets I have a literal and that tells Java how many elements I want this array to store so this is an array that's gonna store eight integers okay so this says Java please create an array a new array to store eight integers and I'm gonna refer to that array using the variable name multiple arrays in Java had this nice feature which is they know how long they are they know how many elements they have so once I have an array again this is a new piece of syntax so the syntax is gonna make more sense to you later but this is one of the unfortunate things about Java is that we just kind of have to push it at you right now and you're just gonna have to wrap your head around it later when we talk about objects you'll see where this dot notation comes from but for now if I want to access the length of the array I can do so by thinking the variable name that I declared that stores the refer to the array dot length this special keyword length length always gets me the value of the array down here I can also split these into two parts so here I'm declaring that all is going to store an array of characters and then I initialize it to hold four characters down here alright questions about this again we're seeing new syntax here for those of you that are new to Java or new to program we will give you lots of practice with this okay awesome we're not initialize array I can also put initial values into it if I want to so I can both initialize the right and fill it with the data that I want it to contain at least when I get started so here's an example on the left side I'm telling Java that I'm declaring an integer array called multiple and on the right side I have these curly braces and inside I have a series of literal value separated by commas so this crates and how large is this array for why don't I have to tell Java that anywhere because it can count the computer can count it says okay well I'm looking inside here and I see four values so I'm gonna relies this to be of size four same thing down here right so I can create a character array initialized as well right so I don't have to specify the size here because Java can figure it out based on how I initialize the array so this array is gonna have size three because it looks inside the curly braces and it sees three values okay so now I've showed you how to declare arrays how to set their size how to initialize them with digital values but usually what we do with an array is we want to use it to store data and so we want a way to get at the data that's in your right and it's frequently important to be able to get at the data in an array at a specific spot remember the position of data in the array is really meaningful so for example when people look for patterns in the human genome they take the human genome as an array of values and they go through it one by one in order looking for different types of patterns in the data so I want to be able to figure out what values at a particular location in my data structure in my array in Java I do this using something called bracket notation so these are square brackets if I want to access we won't get to a playground in a minute I know this has been a lot of just you know new syntax but we'll do an example in a sec so here on line two on line one I've created an integer array called twos and I've initialized it with three values so this has size three what this piece of syntax here does is it retrieves the value at index zero in the array and again for those of you that are new to computer science this is a little bit weird okay index 0 is the first element in the array so what is that going to print the slides say it's gonna print 1 that's the first element so this is why we refer to this as week 1 of CS 125 because when was week 0 last week right computer scientists you will get used to this and you will start to do it and people around you will find you annoying because you do it but you will start numbering things at 0 okay 0 it's actually the first number all right so this is our first value in the array at index 0 I can also set values in a job array using similar syntax so here on line 3 I'm modifying the first value in the array I'm changing it originally it was 1 thank you Greg and now it's 2 I've set it to 2 I've assigned it to 2 so this says assign the value in the array choose at position 0 which is the first value to be 2 and just like I did variable assignment I can assign values into an array using a literal I can assign them and do it using a variable I can do any kind of a sign at the moment okay so let's so again that what's what's interesting and important about arraigns it's two things first of all it's our first chance to work with multiple values ok the second thing is that arrays associate this new piece of data metadata structure with the data inside the array so once I create an array I've added data to the system I know not only the values inside but every value has a position and the positions to be meaningful right so again the data is the contents with the actual values that stored inside the array the metadata is the position the order that I've added that's the structure that this data structure the simple data structure right alright questions about arrays I promise we get to a playground but actually I think that's gonna come later yeah yeah so this is so the question is can you have different types of data in the same array and the answer is no in Java an array every value in the right has to be the same type and again you probably are starting to what like see the limitations of that there's certain types of data that I can't work with because it requires mixing different types of information we will get there that will be the next big expansion of the kind of data that we can work with in this class when we get to objects and we start talking about how to represent more complex pieces of data so other the other thing to point out is other programming languages allow you to do this so in Python I can have a list that has some integers and then a few strings and then a couple of floating-point values and we don't do that in Java and that may seem like limitation but it turns out that it also makes our code a lot easier to reason about and safely in Python if you have a list of elements you have no idea what's in there in Java you know you know they're all integers great question another question right yeah ah okay so the question is what are the initial values that are stored if I create an empty array come ask me that question in a minute I'll show you yeah so the question is if I create let's say let's say I go back here and I create that array down there all what's inside of it right now what would happen if I printed the first value at index zero we'll talk about this in a sec great question it's easiest to just do this using the playground yeah yes so the question is if I want to append a value to an array like I want the array to get bigger yes I essentially have to create a new array copy all the data over and then add the value of yet all right we will talk about this later later in the class once we start to implement some more interesting data structures we will implement a more flexible version of an array that's called a list that allows me to add and remove elements from it and you will see how we have to copy everything over in order to do that very question okay so now we have this way of storing multiple data values all right but we don't really have a useful idioms for working with these data values right so for example now I could give you you could store all of you know the text in the US Constitution or the live records in the Library of Congress but what if I wanted you to do something like go through and count the number of times that the letter W appears for example so it's all text so this is a huge array of characters but I don't want to like I can't and I've seen how to get one value out so I can get the value at location 38 to the value at location 297 but that's not what I want to do what I want to do is I want to write code it actually goes through the array value by value one at a time and figures out what to do and so this brings us to the second half of today's class where we go back and we talk about one of the other things that computers are extremely good at which is doing things over and over quickly okay and a lot of times the repeated operations that were performing when a computer is running are working with some type in array like data structure or data that's stored in an array it's not always but this is common so again when I play music right like when I'm you know so right now my computer is sending the screen over to that device over there and what it's doing is frequently it's taking all the data from the screen and it's sending that data over there okay so it's doing this over and over and over extremely quickly which is why when I change the slide you see it up there so the construct that we use the new piece of language syntax that we use in Java or the the way that we describe this process is a loop right it makes sense when you're in a loop you're going in a circle doing the same thing over and over again loops are also one of the basic building blocks for working with data in arrays so again the data is what's exciting here right data science this is hot new term which to me I find really amusing because computer scientists have always worked with data that's only it's the only thing your program ever does right so the idea that somehow there's this new thing called data size is a little funny I'm happy that people are excited about it right but this is not new to computer scientists we have always worked with data that is what you will do for the rest of your life but if we want to process a lot of data we need to be able to do things over and over so we need to use this construct called a loop so this requires introducing a couple of new pieces of Java syntax the first one the simplest possible loop and one that we'll start with is called a while loop so here's the simplest possible loop in Java I'm showing you here so again I've got some new pieces of syntax let's slow down and let's examine this together last time we talked about if statements that was one of our first examples of new syntax this is a special way of instructing the computer to do something while is another one okay so while is another one of these special words that has special meaning to Java you can't call a variable while okay because it's a what's were known as a reserved word it's reserved because it means something else so here's the syntax of a while loop I have the word while then in parenthesis I have a condition this is a conditional expression it's something that needs to evaluate to a boolean now here I'm using a boolean literal but that's not very common usually what I do is I have some type of tests that I'm doing in there is a number smaller than another number or something like that then I'm using to determine whether or not I should continue to run this piece of code and then I have a block so we saw these before when we talked about if and else tape the code inside the block is what I'm going to repeat and just like with if and else I can put anything I want in there I can write a whole big program inside that while loop if I want what goes inside that block can be anything that I want it's indented to the right so that it's more readable so I can tell what's inside the block well I have an open curly brace close curly brace code inside the block as long as the condition is true Java will continue to execute that code so it'll start here on line two it'll run any code inside the block and then it will return to the top every time it gets back to the top of the loop it reevaluate the condition so when will this loop stop executing so Java it's going to get there and is going to say ok while is the condition true yeah so what do I do run the code inside the block ok I'm back at the top now it's the condition true what do I do next I could just be stuck you're all semester right yeah I'm just going to repeat this over and over but that's that's what this will do this will literally repeat the code until something stops it you or some other sort of a problem right so again while loop has two parts there's a block of code to repeat that's inside the braces and there's a condition that has to be true every time I start the loop so if the condition is it true the loop doesn't run okay as soon as that condition evaluates to false Java will stop executing the code it will not rerun the block instead it will continue below the while loop so it'll jump down below the block of code that I declared to be my loop and will keep running okay so let's experiment with this okay so let's think about what we expect to happen with this piece of code so I've got an index that's an int variable and my while loop is checking whether or not that index is less than four if it's less than four what happens what code gets run what's the first line of code that gets run yeah yeah so if index is less than four I entered this block that starts on line three and I run the code inside okay so I print the index and then what do i do on line four it's good review of our variable updates it's very common what do I do yeah I increase index by one so this is equivalent to index is equal to index plus one or index plus equals one this is a shortcut for incrementing index by one then what do I do I go back to the condition so I test the condition again so the first time I went through the loop index was zero because I had initialized it here the second time I go through the loop what's the value of index one is it less than 4 so I execute the code again on anger increment index now I get to the top what's index now - is it less than four so you can kind of see where this is going let's run the code it's been too long since we've had a little bit of fun okay so let's think about what just happened the first time I came through the loop index was zero I added one I went back to the top and X was less than four so I continued and added one two and three so let's think about what happens after I print index is equal to three so when I get to line three and index is three I add one to it so what's the value of index now is four less than four no and so that loop stops executing so Java goes to the top it says this NS Lesson four no and it jumps to the bottom and prints done okay so we now have this fantastic power at our fingertips we can make computers do things over and over and over again this is the efficiency the Clive Thompson talks about encoders the ability to repeat stuff over and over again the ability to you know do drudge work or you a computer you know this is boring to a human right imagine that the thing inside this loop is like the worst the most boring thing that you have to do right like mow the lawn maybe you like mowing the lawn right wash a dish or something like that right and you can now tell the computer to do it right it doesn't care nothing get tired I have had computers do some incredibly gnarly things for me and not once has one ever complained ok they don't complain they don't get tired they don't take time off they always show up on time they're incredibly good at doing this type of really really boring Drudge work all right but we typically want them to stop at some point an unterminated loop will stop at some point now what causes it to stop can be a variety of different things right so if you run in our tests what will happen is at some point we'll be like wait this code is run for way too long I asked you to print hello world ten times that shouldn't take ten seconds right something has gone awry and will will terminate the code but normally this is a problem right so soon and this can occur you know you don't have to be malicious right so there's an anecdote and I actually remember this there's an anecdote in the next chapter of the book talking about basic programming anyone anyone program in basic ok that's good actually basic was a language that had a lot of issues but it was kind of fun it was simple and so you know I remember you know with the old computers at my school like writing a little piece of code they would just print like a bad word over and over again right on the screen because the teacher couldn't turn it off that was the best thing about it you know and then the teachers figured out okay well there's this special two keys that if I hit together it'll stop it and then we came up with like nastier versions of it right that you actually literally had to turn the computer off right to get stopped right so anyway didn't like that I spent a lot of time in middle school sweeping the parking lot all this point point that out that wasn't always why but there were other reasons so here's an example of us doing this in a non malicious way we just made a mistake okay so what's gonna happen when I run this piece of code all right so this looks a lot like the example I just did I start with an index it's zero I enter the loop I'm checking if it's less than four I print it and then I oh here's the problem right I subtract one okay so let's see what happens okay so now it's negative one is negative one less than four yes I continue this is not going well right the thing that stopped my loop before was that index was getting bigger and so eventually was going to reach 4 and that condition was not going to be true anymore here index is getting smaller so let's see what happens if I run the code okay so if I run the code our helpful playground will actually print like a lot of values right and then down here at the very bottom it will tell you that the program timed out what does that mean it means that I killed the program my code killed your program that's really actually what happened my code in this case killed my throat because my program was bad and wasn't stopping it also points out that they were like 200,000 lines that aren't shown here right so this actually made a lot of progress before I got around to turning it off okay this is an example of an unterminated loop you can also just do this but at this point you're writing code that's malicious right like here you're just trying to mess with me right again you know you can run this and you know eventually it'll print a lot of stuff and then time okay so one of the things that that language designers will do is when they identify a pattern that people are using in their code they'll try to make it easier okay and so a lot of times we write a while loop we're performing something a certain number of times we might be going through every value in an array or we might be doing a particular operation a certain number of times that we know beforehand and so this type of pattern is very common if all I had was a while loop in the entire world I would write a lot of code to look like this I created an index I set that index to zero I repeat the while loop while the index is less than some value and every time I go through I add one the result of this pattern is that whatever is inside the loop gets executed however many times according to the condition that is set inside the loop so if I use four is my literal here how many times will this code get executed what if I change it to ten I think it's actually 10 times whatever you had you do a hundred yeah so I'm basically doing something a certain number of times and I'm controlling the number of times that this is done by changing this one value okay and so rather than forcing you to write this over and over again we have a special piece of loop syntax we have a new kind of loop then I'm gonna show you that's designed to help handle this this is called a for loop so we've looked at a while loop a while loop is simpler than a for loop before loop starts to get a little bit more interesting so this while loop up top is equivalent to this for loop okay so let's go through this careful step-by-step so again four is a reserved word in Java you can't have a variable called for it a special meeting to job it means that you're creating a loop for loops work differently than while loops so you'll see on some level they look similar I've got four and then I've got some parentheses but in a while loop I had one thing inside those parentheses a condition that I checked every time I entered in a for-loop I've got three things for loops have three parts okay so if I go from left to right the first part is an initialization step this happens once the first time the for loop is entered the second is a condition this is checked every time I enter the for loop including the first time the final part is an update sometimes referred to as an update statement so that runs every time the loop repeats it does not run the first time so the way Java executes is this it says ok I'm gonna create a variable called I can declare variables inside this that's actually quite useful so I'm gonna declare a variable called index of type int and initialize it to zero then I'm going to run I'm going to check whether or not it's less than four it is less than four I'm gonna execute the body of the loop when I get to the top I'm going to run my update statement so index is now one and then I'm going to check the condition again and if it's still true I'll run the loop again okay so the parts of this are sometimes confusing to think about right but one of the ways that you can help yourself understand how for loops work is by rewriting them as while loops and vice versa so I can take a while loop and rewrite it as a for loop okay so let's do that so let's take our while loop here and I'm gonna run it to see what it does so this is the behavior that I expect and now let's rewrite this as a for loop so the first thing I need to do is I need to change the while to a four okay I'm gonna move this bit of initialization that I did up here on line two into the that's the first thing I do in the for loop that's my initialization stuff I have the condition already there the last thing I need to do is move this update statement out of the loop in into out of the loop body and into the pour loop declaration so this is the same loop okay should be let's run it and make sure it does the same thing it does okay good and again you can also take a for loop like this and rewrite it as a while loop if I wanted to use a while loop here I need to declare my variable out before the loop because I can't do that in a while loop I have to remove everything except the conditional and I need to stick the update statement inside the loop so there there's going back the other drug all right I'll leave this for you guys to practice later so for loops are more complicated than while loops while loops are simples just a condition if it's true execute the body of the loop not stop you will get used to for loop this is one of those things that you know by the time you're done with this class one of the reasons why we do the daily homework one of the reasons why we do the weekly quizzes is to get you to practice this stuff because by the end of the day by the end of your life is a computer program however many decades that last however many problems you've solved all the cool ways you guys are gonna change the world right and I'm relying on that right because I'm getting old I'm getting gonna get older in a couple weeks right and you guys you know I you know and at some point I'm not there yet but at some point I'm gonna like stop learning the new languages and stuff like that and I'm you know I'm gonna be using the stuff that no one's to use anymore right and then you guys have to go on and actually make the world a better place so at some point later you will think about how many four loops have I've written in my life I don't know I I don't know hundreds of thousands for me right you just you just start to do them right you don't think about they just flow off your fingertips it's like learning to write okay here's what to keep in mind when you're getting started and those the initialization step the first part of that for the body only happens once the first time the for loop is executed the conditional is actually evaluated every time so if the conditional is true I enter the loop if it's false I don't this isn't true even on the first time that I get to the loop so if the condition starts out false the loop is never executed the loop body is just skipped and I keep going and then the update is only performed after the block executes so the first time I don't do the update I only do it after the block execute and it's also performed before I checked the condition so when I get to the bottom I go back to the top before my update statement check the condition if the condition is still true I keep going otherwise I stop alright so this is basically the algorithm the Java is executing we'll talk more about algorithms on Friday this is this series of steps the Java executes when it runs a for loop check the condition the condition is false continue execution if the condition is true rerun the block and then after the block finishes update run the update statement and repeat this until it's not true okay so I'm not going to go through these in detail but I'll let you guys this is a good thing to do so you're not gonna see very many loops like this okay most of the loops that you see are gonna start a variable at 0 it's gonna be less than some value and you're gonna increment by one I suspect that 98% of the four loops I've written in my life are that kind okay this is not very common but let's think about it because we're learning this stuff right so here what's what am i initializing what so what's the variable that I mention elijan is part of my loop what's a call by for loop it's actually called loop here right so this says initialize declare a variable called loop initialize it to four what am i checking against I'm checking that it's less than or equal to eight and how am i updating it actually adding two rather than one okay so let's see what happens when I run this how many times this is going to execute three when it starts it's for is for less than equal to eight yes I acute the loop next time I come through loop is six when I check the condition right is 6 less than or equal to 8 yes that's the second time through when I the third time through what's the value of loop 8 is 8 less than or equal to 8 it is go through the loop update add to loop is now 10 is 10 less than or equal to 8 oh so I stop okay I again I will leave these up for you guys to review we you know unfortunately these type of statements are great fodder for quiz questions so you will see a couple of things like this on next week's quiz so please go over these and ask if you need help on the forum so just a little bit of esoterica before we go on to a couple more important things so all three parts of a for loop are not required the 3 parts are the parts that are separated by semicolons inside those parentheses so I had my initialization semicolon check semicolon update I don't have to do those and again these are so rare okay you know I mean I'm only putting them up there because just in case you see them in the future you have some sense at the fact that this is okay we will probably not show you code that looks like this because it's just not very common right but again I can leave out the the variable declaration so here I'm not declaring any variables as part of my for loop I'm just using the one that already exists here I'm not updating the variable in the for loop I'm just checking the condition this is essentially equivalent to a while loop and then down here I'm not checking the condition or updating the variable and this is essentially equivalent to a while true loop will never stop okay and again a good thing to do to practice is if you get confused by this rewrite the for loop as a while loop and that'll help while loops are simpler to the freezer okay last two things I want to talk about are two important statements two important things I can do inside a loop that will affect the loop execution and we'll talk more about these on Friday as we start to develop some simple algorithms using the programming tools that we have in our tool bag now okay so break again these are special keywords in Java they're special to the computer okay break means immediately execute the enclosing loop why would I use a break statement maybe I was going through a big array of data and I found a value that I was looking for so I want to stop I don't need to look at the rest of the date okay break will terminate the loop once I hit break I jump out of the loop and keep going I don't really finish and I update the variable I just stop I just jump out of the loop immediately and execute any code that's below that would continue is a little bit more interesting so what continue does is it jumps back to the top of the loop immediately and then everything that would normally happen happen so if it's a while loop I check the condition if it's a for loop I update the variable and check the condition so continue essentially says go back to the top and keep going maybe this piece of data in the array that I'm looking at or is it interesting maybe I don't want to do anything with it I'm just gonna keep going okay so what's going to happen here let me put a little bit of extra logging in here all right you guys thinks gonna happen here so again I've got now I've got some new stuff going on this is exciting I'm sorry to combine things together I've got a loop with a conditional inside of it okay and again we'll talk more about this on Friday when we start to talk about what an algorithm is and how we would build one using these tools that we have but here I've got a for loop so I'm going through a series of integers inside of it I have an if statement if the if statement is true I'm gonna print something and then I have this break keyword what does that break keyword do stops the loop immediately okay so let's run this and see what happens okay if I go through not found not found not found and then at the very end I find the value I'm looking okay so this is where I'm gonna stop for today we'll talk about continue next time just a few announcements as you guys pack up homework continues today homework continues every day the homework problems are now due on the day they are assigned this is the way things will work until December okay we have office hours today starting at noon if you didn't finish setting up Android studio and you probably did it in lab please plan on coming to office hours this week to take care of that we haven't the machine project will be out on Friday I don't have office hours today I will see you guys on Friday  
﻿ okay people hear me and back top row all the way in the back all right thank you it's good to be back okay so today we're gonna talk about a new type of data that we can work with in Java and this is going to ease us into a topic that is going to later consume us for a good part of the second third of the semester which is talking about Java objects this is Java objects will represent not only a dramatically new programming style for you all to learn but a real enriching of our ability to work with data so that's really what objects are for we're gonna see the first example of a Java object 'day although this is a very special Java object that has a couple of kinks to it there's a couple things about working with text because text is so important to us humans that are a little bit different in Java but that's what we're gonna do today so the first thing I want to do is give a big thank you to Ben who is here on Monday filling in for me so oh we're doing that again okay let's see how long that lasts okay any questions about the material that we covered on Monday no was it here I listened to the class and I feel like Ben did a fantastic job but make questions as we get started today functions will be our topic on the Homer problems this week leading up to you guys having a chance to work with them on next week's quiz so one of the things I want to point out about our homework problems is that you know one of the challenges with Java as an introductory language is we have to attach some training wheels early on in the process so for the first week or two you guys wrote snippets of code where you know sometimes we had declared some variables for you and you were just supposed to use them now we are having you write complete functions okay so that's our next step is having you write entire functions eventually you're actually going to be working with the entire object which is really how Java thinks about your code but for now we've taken off one set of training wheels and this is usually a little confusing to people as we get started but within a couple weeks we'll be working with entire you'll be designing entire java objects and we won't have to worry about this anymore well taken off all the training wheels but for now going forward but you should expect to see in class more often on the homework problems definitely it's us asking you to write a function a function that does some specific thing that's going to contain a snippet of code similar to what you were writing before okay so so let's talk now about this again this dramatic expansion of the kind of data we've been able to work with so so far we've talked about processing story and manipulating data using java tubs eight Jabez eight primitive data types right integers floating point numbers and characters we've talked about using arrays of these as well so we talked about that last week so now we can use one of these you know one integer one floating-point number that's not very interesting there's not much in the world that you can really accurately describe with a single number so we expanded ourselves to being able to work with entire sequences lists arrays of these types of data and up until now we've been working mainly with numbers but text is a really important component of the world around us right so one of the big missing pieces and again this is such an important type of data to work with that Java makes some exceptions for it when you work in the java programming language and this is not unique to job other languages also sometimes treat tax specially because it's so important right because without text we can't represent great works of fiction this is a famous book by an author who grew up around here actually you can't represent all of the human communication that's going on in the world right so you know a fair amount if you think about the data that you as a human being generate every day a fair amount of that is text your communications with other people right written communication you know I think one more interesting things looking back on sort of my several decades in technology is sort of the explosion of text messaging and textual basis different ways to communicate through text there was a period of time and again it was before a lot of you were conscious there's a period of time where a lot of people thought well you know voice is gonna take over you know pretty soon we'll all be you know video chatting and you know calling each other all the time and stuff like that but actually I suspect that within your lifetimes when you were very young the amount of text communication between people has actually skyrocketed right I mean it's about as easy to make a phone call as it was 20 years ago but it's gotten way easier to send small pieces of text around whether that's through who you know through a texting application or a chat application on slack whatever right so this is actually kind of an interesting you know a surprise right that technology brought us sorry people actually really like to communicate via text right I think there's some some deep reasons for this and then there's also lots of places in the world where text is a stand-in for some other type of identifier right so license plate numbers are a great example here's an example where you know what I really need is some kind of ID I just need a unique way to identify this plate which is then supposed to identify that vehicle okay it doesn't have to be text it could have been like a picture or a barcode or something like that but because humans work with text so much this is something that we'll remember right you know if you saw you know an accident or something like that and the car sped off and what was on the back was a barcode it would be difficult to tell the police person what you saw but if you see text you're more likely to remember right and that's also why we're still stuck with with passwords right or passphrases or however you guys do it today same thing humans are good at remembering text not as good at remembering sequences of numbers okay so a lot of the interesting data in our world is in this form this textual form now as a computer scientist you call this a string that's just the term you use I can't remember I mean at some point before I became a computer scientist and it totally changed my brain I think I probably referred to Dax in some other way words whatever but now you call them strings all right that's the word for a piece of computer data that consists of a series of characters okay this is you know again and I can't remember not knowing this right I mean I've always been referring to these things as strings so in Java there is a way to work with strings now there's a couple of things on this slide that are it should be disturbing to you okay because there's some new new things here right there's a type in Java for working with series of characters actually there's already a type in Java for working with a series of characters what is that type we've already talked about this that's the first thing that should be disturbing to you I already know how to work with a series of characters if I want to store a series of characters in my program and do something with it what do I do you guys already know this like this is something that we don't even need this new type right how would I do this before right now yeah yeah why don't you seize an array of characters right I already I already have this right I don't know so so that should be the first thing that should worry you about this is why right there's no special type in Java for a series of integers okay so that's curious right it seems like there's some redundancy here all right I already have a way to work with text right I told you before I could store the entire you know you know record of congressional sunning it's just one big long array of characters and then I could do whatever I want with it okay so but Java actually has a special type what else is worrying about this what's different about this type from the ones that we've seen already something that's evident from this slide yeah oh I like there's two answers here okay so it uses double quotes yeah okay so that actually that was really good I even forgot this right so I have literal values here that I'm using as part of an assignment to a variable before when I worked with text I was working with single characters and in Java if I want a single character a little I use single quotes if I use double quotes I get a string so that's that's interesting it means that somehow Java has sort of built-in support for this type of data somebody else also had an answer that I liked can the person who is vaguely off in that direction repeat their answer what else is different about this type you can see from the slide so there's a new way to declare literals what else yeah yeah yeah so the data types we've seen before right let me back up a few slides and show you this list that we had before byte short int long float double care car someone was I okay so let's take a vote how many people would like me to say that as car I really do want your opinion here car care sorry guys I think the care is habit that the people that approach me work are partisans but I think that care is that win the day alright and and then boolean right these types all were denoted by single case letters and now I've got this thing called a string it's capital and that turns out to be important okay but but on some level if we squint at this it looks like one of the other types of data that we be able to work with so far okay so what am i doing on line one I'm declaring a new variable called maybe it's a type strength it's just like I declared a variable to store an int or a boolean lines two and three show me a sign in and then reassigning the value of maytee so in the first line I sign it to challenge now I see here a string literal so on the right side is a literal value it's not a variable it's a specific string that appears in my code and I've enclosed it in double quotes and assigning it to maybe so after lying to execute maybe now has the value of Challen which I don't like so we're gonna change that to Jeff on line three that's just reassignment again this is identical to what we've seen already and then on line four I'm calling a function right I don't know what that function does but that's a that looks like a function call to me the function is called call me and the variable is called maybe variables inside this is a function that takes a single argument okay so strings look familiar but strings start to behave differently strings have some new features all right so let me show you one right so I've got a you know I've got a stream variable here on line one let's just comment out this last one for now okay so this looks similar similar to something that I saw before what was that I can remind me there was something else I've worked with in Java that had a length a way to get its length yeah an array right but it's a little different okay and this difference is gonna I guarantee this difference is gonna it's gonna catch you up so let's try this array is equal to o let's declare an int array with length 9 a care array sorry and then let's print its length okay sorry Kerry there we go what's different about this again the some of those places where Java is gonna mess with you and everyone someone asks every semester why is this the case and the answer is I have no idea right some programmer made this decision and if you go find that person you can complain to them we're just stuck with it for now what's different about these two yeah way in the back yeah I have if I wanted to get the length of an array the magic that we used was dot and then the name of this special property called length right right here that works if I want to get the length of a string I do something very similar except I have to tack on these this pair of parentheses so what does that make the length look like for a string should be review for Monday it looks a little bit like I'm doing what yeah it sort of looks like I'm calling a function yeah like I could put stuff in here you know I could pass it an argument now it doesn't take any argument so if I do that I'm gonna get a compiler error but this starting this looks like function okay and then it turns out that not only can I get so with arrays all I can do is access their link that's the only special feature that they have with a strength it turns out that there's a bunch of things that strings can do once I have a string variable there's a number of different things that variable knows how to do it comes with these special features so for example you guys something you don't know anything about this yet that's totally fine but let's just use our powers of intuition to try to figure out what's going on here so on line three I print the length of the string okay that looks a lot like what I did for an array who wants to give me a hypothesis about what's happening on line four let's walk me through that what do you think yeah yeah I'm I'm testing this is a way of examining I'm basically asking Java to tell me whether or not this variable stored in whatever string is stored in the variable password is equal to in this case a string literal right so I and this is something that looks now even more like a function call cuz I'm passing an argument so somehow I'm use I'm starting with a variable I mean I have a dot then I'm following that with something that looks like a function call and I'm passing it some data so what could I put in here that would cause that to be true right now it's false right and that's consistent with our suspicion that this is a way of comparing two strings to see if they're the same so what would I do here to examine the hypothesis further yeah ziz but yes yeah pronounced ziz perfect exactly so now it's true okay so now I have another piece of data here right so that looks like it's doing what I think it should do let's make a tiny little change here two Z's cat and see now it's false okay so apparently this also examines the case of each letter whether its upper or lower case okay so one of the reasons we tell I mean there's a bunch of reasons we talked about strings one is that they're fascinated in text aid is super interesting but they're also our first example of a Java object and strings are kind of an interesting Java object they sort of sneak up on you Java in general as a language I would argue is highly consistent almost to a fault there are places where Java would be easier to use if it was less consistent but it strives for this high level of consistency and that sometimes forces you to do things that are pretty dumb this is like the one place as far as I can tell sure there are a few others but this is one of the first places where you see Java display a little bit of flexibility you can almost imagine the people that design this language having arguments about this right well strings are objects but we should allow them to be assigned with literals I'll explain what this means you know this is a place where we're blending the world of primitive types and objects okay we are going to talk a lot more about objects but in general an object is a programming technique that it allows us to combine both state and behavior so this brings together two of the things we've already talked about in this class we've been working with variables so we've been taking a variable and we've been to sign it into value at that point that variable has state it knows what the value that I last assigned to it is last time we talked about functions functions give me a way to take a single piece of logic about how to perform some computation in many cases an algorithm for solving a problem and wrap it up in a nice tidy package that I can then use and reuse throughout my code objects bring those two things together so if we go back and look at our example again the variable password right password clearly knows two things in order to complete this function call this method call password has to know two things the first thing nice to know is what's my value what are the series of characters that you stored that you last stored as my contents right so straight so password has to remember that I assign this variable to this literal to its is cat so it has to know that sequence of characters but then it also has to know something else it has to know how to compare itself to another strength there's an algorithm we could go through that algorithm if you won maybe well maybe I'll write a new homework problem and post a tree you guys it's not hard there's an algorithm for or determining whether or not two strings are equal and the password also knows how to do that so we're bringing together again once I declare a string variable not only do I get to use it to save some information but I get all of these cool features that come along with it and I'll show you a bunch of them in a minute okay so again just to reiterate we will talk about this more in a couple weeks every string has state that's the sequence of characters that were stored last stored in that variable it's an array of characters it also has behavior these are functions that we can call that operate on its state or use its state so when I call it equals that function uses the data that I've stored inside the variable and whatever string I pass to compare it against to decide if the two strings are you alright so when we think about objects we're always going to come back to these two questions what data does it store and then what are the things that it then allows me to do what are the algorithms that I can then use it to help me with what is it what are the things that knows how to accomplish okay let me just you know kind of go through this so and reiterate a little bit so you help understand the distinction right so primitives in Java store one value right so these primitive types one value or if I create an array of them a sequence of values a series of values of the same type in Java primitive types have names that start with the lowercase letter there's only eight of them so you can actually memorize all of them if you want if you think that will impress somebody maybe a recruiter or something objects on the other hand can be made up of mixtures of both primitive types and other objects so once we start talking about objects and we're not going to do that fully today but once we get there which we will soon this will allow us essentially to represent any type of data that we can represent as a mixture of primitive types so pretty much once we open up objects we can now represent any kind data that you would ever want to work with if you can represent it in numerical form if you can digitize it what you have to do in order for the computer to be able to work with it you can create an object in Java that represents objects have names that start with a capital letter this is a convention in Java but it's important because it allows you to identify so when you see a type that starts with an uppercase letter you know you're dealing with a Java object I suppose to a primitive type so again we're gonna give you lots and lots and lots of practice we spend like a whole month going over this together but for now we're gonna use strings as our entry point to the world of objects okay however I told you that strings have some weird there's some weird accommodations that Java has made for Strings ok strings are special right they get a bit of special treatment in the language so here's one normally to create a Java object we always use the new keyword you guys will get familiar with this where have you seen the new keyword before yeah yeah we'd initialize in an array right so we saw the new keyword when I set up an array arrays in Java turns out are also objects they don't have very many interesting properties just that length property but they're also internally objects but this would be normally how we would talk about initializing strings and when we initialize other Java objects this is how we're going to do it and we're going to talk more about what's happening here later but with strings essentially the way this and this works by the way you can do this in Java so for example I can say here's my variable declaration I'm saying hey Java I want to create a string variable called my string and then on the right I'm initializing that variable I'm saying create a new string and then inside those parentheses in something that looks again like a function call because it is a function call which we will talk about a little bit later I pass a string literal so I'm saying I want the contents of this string variable to be the letters ABC on the second line I'm creating another string a string variable whose contents are DF so I can do this you can create Java strings in this way but because strings get these special treatment in the language because we work with them so often Java allows you to create them using this shorthand so I can create a string literal by just enclosing the sequence of characters in double quotes again there's no other type of data in Java except for one really weird case that I'm not going to talk about that gets this type of treatment all right so these are equivalent there are no other Java objects that you can create without using the word new now it also turns out and I will be happy to help you guys investigate this on the forum if you want that there is a tiny difference between these two ways of creating strings a tiny but sometimes meaningful difference so if you again if you guys want to ask about this on the forum I'll be happy to talk about it with you it's actually kind of interesting if you're interested in sort of how Java works under the hood but us.we it's not gonna bother us these are we're gonna consider these two to be equivalent and normally we're just gonna you know this is how we're going to initialize our strings you know Java has this way of doing it why not use it so Java is also the only object type in Java that supports a literal so again I can assign a Java object the reason why this works is because I can actually use a string a sequence of characters inside double quotes as a literal in an assignment and again there are two types of object in Java that allow you to do this and the other one is something that never comes up in this class so this is the so here this is now a string literal it's an object value that appears in my code like I said before this distinction is gonna trip you up so be very careful here single quotes in Java always get you a character you cannot put more than one character inside single quotes double quotes get you a string you can put zero characters inside a string or 1 or 10 or 100 if you try to initialize most of the time the compiler will catch this for you but there are times when this can be confused all right so just be careful most of the time in Java you want to use double quotes single quotes are rare that you're gonna need those okay so just to point out again you know we've seen this new syntax before we did it when we used arrays and the reason that we needed new then is because arrays and Java are also objects I didn't want to talk about that then so we didn't bring it up but now we're starting to dip our toe into the world of objects and so we need to talk about okay another bit of special treatment that strings get in the language is that there's a special operator for combining them together okay so if I want to combine two strings in Java I can use a plus operator five to string variables and I want to concatenate them so this there's no meaningful combination of combined meaning to combine them right what I'm doing is I'm appending it so full is going to contain all the contents of first my first name plus a space that's the string literal in between the two variables plus all the contents of laughs so when we're done it's going to contain my full name again this is the only place in Java where the language bends over backwards to accommodate you using a particular kind of object all right so let's let's do some stuff with spring or with strings right so I promised that I could concatenate things together so let's see what the output of this is okay so it's clear that both of these methods work right I can change this to new string d EF and it's still going to work I can change this to just do an assignment through a literal I can change this to also do an assignment through a literal great all right so these both work fine and again this is the this is the style that will typically use and expect you to use on homework problems in a class I can you know put anything I want in between these guys I can use the same variable twice in my concatenation whatever right plus is the only operator that works here - doesn't really make sense right times you know plus is the only operator that really has a meaningful role when I'm working with strings okay so I told you that strings contained both state and you know basically combined aspects of both variables and functions you know state and you know data and capabilities so how do we get at those features how do I get at those methods that a string comes along with and to do that I use something called dot notation again this is just syntax something magical about it just happens to be how Java does this a lot of other languages have actually adopted dot notation so this is pretty common I think Python uses it JavaScript uses it and go uses it I know about rust or Haskell or whatever but this is not uncommon as a way to access a feature some property of an object right whether it's a property or method and so here's a couple examples of me using these built-in features of a string okay so we already talked about line two that's the way that I get the length of a string and that's useful a lot of times when I'm working with data and strings because just like an array a lot of times when I work with a string I want to go through a character by character and do something what do we think is happening on line three again you guys I don't expect you to know what these are I'm just expecting you to think write and read okay and think about this is text data right so who wants to give me a hypothesis about what line three will do yeah yeah so I have a hypothesis that that's going to take the string and it's gonna replace T lowercase T with the lowercase B okay I think that's reasonable we'll test that in a minute what about the fourth line anyone want to speculate about what this is going to do yeah yeah it's gonna change the string to uppercase now I just want to make one point here about software engineering why were you why were you both able to do this I'm assuming you knew nothing about the different features and methods that a string provides when we started looking at this variable why were you able to do this what helped you here yeah they chose good function names indeed right the person who created the string object in Java like a person somebody sat down and implemented this someone made a choice about what to call these functions they could have chosen to call this one foo and they could have chosen to call this one bar and that would have still worked the computer doesn't care but we would have never been able to do this exercise so when you choose good function names someone can look at your code and actually figure out a lot about what's happening without even having to understand it right all right so where do I find out about all these different goodies that the string class comes along with well there's documentation right if you look up just Google Java string one of the top hits hopefully the top hit is going to be Jabba's official documentation about the string class will look a lot a lot more of this Java doc later now okay look I I cannot apologize on behalf of Java doc okay I know that those of you that were born into the future may look at this and shudder a little bit because most of the webpages that you look at are happily that are designed for readability okay however there is actually a lot of useful information here and you will need to spend some time particularly to work on some of the homework problems that prepare for some of the quizzes looking through some of these you don't necessarily have to read all of it it's probably not you know there's not a huge amount of text here but down here there's a section called method summary and starting here as we go down what we're gonna see is that there's a description of a bunch of different methods that I can call on a string object one of them is the one that we just talked about okay so here it is replace and the documentation says it returns a string resulting from a place in all occurrences of old care in this string with new care so it did what we thought there is also a little bit farther down to upper case converts all the characters in this string to uppercase using the rules of the default locale so that's interesting who can explain that to me why is this here there's a little bit of latent I don't know like us us Western world centrism here why is this here yeah yeah there's like other I don't think there are capital letters in Chinese or you know some of a lot of and I would suspect a lot of languages in the world don't necessarily have the notion of case and so if you call to uppercase normally we will use the default rules that came with your version of Java but in some parts of the world this doesn't even make sense or worth working with certain types of string data all right so let's test out a hypothesis from before so we thought that replace was going to take all of the cheese and replace them with B's we confirm that by looking at the documentation and indeed what we get back what's printed when I start with test is B ESP I've replaced all the T's with B's okay great and then at the bottom what's printed is capital test now one thing I want you to notice about this so who can point out something interesting about about this code yeah yeah so that when I change things from T to B then I print off example again to uppercase and it's still test so the reason for this is whenever you modify a string in Java you don't it doesn't modify the string inside it doesn't modify the contents of example what it does is it returns a new string with the changes that you requested so let me try to let's let's make this more clear right so it'll say string second is equal to example dot replace and then I'm going to print example and second oh there it is okay good yeah so now you can see I've created a new variable called second that Murs that is the where the contents are the result of taking an example and replacing all the t's with B's and then I print example in second example it's not changed example is still what I initialized it to be so these functions and this is true of pretty much all of the methods on the string class they don't modify the string they they return a new string that has whatever modifications you requested okay so let's yeah you know what I'm gonna just leave this bit of playground and let's go on and do an example well first I'll take some questions we're gonna do a little algorithm an example in a minute the questions about strengths so this is I you know I understand that this is a for some of you particularly for the beginners in the class this is kind of an awkward moment right because we're kind of like we're stuck kind of halfway straddling the world of objects and the world of the variables that we've been talking about so far and unfortunately in Java that's kind of where strings are strings are in this awkward spot sort of you can sort of pretend they're just normal primitive types but you're confronted with the fact that there are objects in a couple of important ways questions about without strings before we go on and do an example someone is pointing over here is our question oh yeah yeah ah okay so the question is when I when I print example that length it prints for and aren't we indexing it zero so when we index it in an array we start at zero but we don't lie about the length of things all right so the length of string is four but we'll do an example in a minute where the first character in the string is at position zero the second one is a position one the third one is the physician to the fourth one is at position three so length will always return the actual number of characters or integers or whatever that's stored inside an array or in this case a string just as a you know hypothesis how do you think a string stores the data inside of it and you guess it yeah an array of characters and so maybe that has some maybe that's connected to the fact that a string will never change its contents right because I can't change the length of an array I could change the contents if I wanted to in certain cases but in general I can't do it so I just give you a new string with modified content okay let's do an example so we're gonna solve a little problem here we're going to use strings did then do this on Monday that's just one of our examples I can't remember I think we I think in the past we did a version of this with characters so now we're gonna use a string and here's what I want to do I want to write first we're going to write a snippet and then we're going to encapsulate in function but the thing the algorithm that I want to implement is I want to find all cases in a string where there are two characters that are the same side by side so two characters in the string two consecutive characters are the same all right so who can walk me through in English at a high level and algorithm for solving this problem so let's think about how we're going to solve it first not particularly hard let's come up with our approach and then we'll figure out how to get it down in code who can explain to me an algorithm for solving this problem don't worry about what a string can and can't do yet well figure out that minute yeah mm-hmm yeah so I'm gonna go through each so let's let's let's think this through so I'm gonna go through every character in this string okay so I need a way to do that right so sometimes when you're solving problems like this you know and and in fact let's do this right okay so I'm gonna I'm gonna examine every character in the string I'm gonna compare it with the next value I'll print out if they're the same all right so let's just put some notes here about what I need to do so I'm going to examine every character in the string what do I need to do here let's just figure out how to get this to work first and then we'll make things a little bit more complicated what programming construct that we've already talked about do I need to use here yeah I need some kind of loop yeah let's try a for loop so I'm going to start my index at I I'm going to increment it by 1 every time but here what do I need to put here remember this is not an array it's a string with an array what do I put here I want to go through every let's say this was an array of characters right what would I put here yeah yeah so if I had essentially I want to go through every character in the string so I want to go through every character and to do that I'm gonna walk I up until it's less than as long I'm gonna continue as long as I is less than the length of the string so if this was and I promise you you guys are gonna make this mistake that's okay so the first thing I'm just gonna do is make sure that my indices are working properly okay so who can tell me what's wrong with this let's run it and see what happens actually that's what I would do if I were you okay so it's it's saying something's wrong on line four that's the that's my for loop and saying it can't find this length symbol okay what am I doing wrong yeah yeah for a so for a string length is a method not a property this will make more sense when we talk about objects for now just remember that there's a difference here okay all right good so now it looks like I'm doing the right thing Mississippi has how many 1 2 3 4 5 6 7 8 9 10 11 letters and I see indices 0 through 10 okay so I'm on the right track now what do I need to be able to do if I want to compare every character what do I need to be able to do so now my indices are working properly yeah find the character I'm gonna modify your answer find the character at that index okay so now this is when I would I would die back into the documentation here okay and I would start scrolling around and sometimes you can just kind of look through I see equals here that I used before okay that's nice okay actually wait I think we already wouldn't buy it oh yeah look at that it's the first one care at so this is a method it takes a variable of type int I have a variable of type in what's my variable type int I and it returns the care value at the specified index so that sounds promising so how am I going to call this I'm going to call it by taking the name of my string variable input using my dot notation I put a dot there then I need the name of the method that I want to call okay so let's try this for now okay so now I have another error and now it's telling me again on line 5 care at cannot be applied to nothing it's saying it required an int so whenever I call this care at function I actually have to tell it what character in this stranger I want to look at in this case that character is I okay so I'm getting I'm getting warm here so now I know how to loop through the string and I know how to extract a character at a particular position in the string right okay so now I'm really close what do I need to do so I need I know how to get the character at the current position but my goal was to find places where that character and the character next to it were the same so if if I'm in a particular position in this string let's say I'm a position I where are my neighbors I plus one what's my other neighbor I minus one so for example index two has neighbors one and three now I could actually use either here I'm going to use I plus one so now let's just do this let's say I'm going to print off whether the character at position I is equal to the character position I plus one will make this prettier in a minute is this going to work let's try it and see what happens oh there's its oh yeah I forgot to use my dot notation there we go oh no it's mad at me there's something else there we go okay so now I've got another problem and this is a different kind of error you guys learned about these different kind of errors last week what's gone wrong now why I tried to get an index at 11 why is that because if I have a character if I have a string with 11 characters how many pairs of characters are there 10 so I need to modify this slightly okay so now it says for the first two characters it's false sucker two characters it's false third two characters is true this looks right but I actually would like to make this prettier so I can actually see the characters that it thinks are identical how do I do that so I think my conditional is working properly or I think the comparison I'm doing is working properly how do I I only want to print off if the two characters are actually the same so how do I do that yeah oh I could do that okay yeah so he's saying print the character plus the prison that would actually give me all the characters and whether or not they were equal here's what I'm gonna do instead that was that's actually a nice idea I'm only going to print out the character if my algorithm has decided that it's equal okay so this looks right s is a character that's repeated in Mississippi there's a second s that's repeated and there's a P let's repeat let's try some things here let's make sure so now we're gonna start thinking adversarially about our code we're almost done we're gonna find some cases where we think it might not work so one special case might be if the repeated character is right at the beginning okay it seems to work there another case that we might miss is that the character is right at the end seems to work there and if I was really writing this I'd probably write some other tests for example does it get an empty string it shouldn't do anything what about a string that only has one repeated character okay all right we will work on this next time I'm gonna so here's what I'm gonna do from now on I'm gonna run as long as I can until the people behind me start to get nervous and as you guys are packing up and it's going to put up this slide so read the announcements I don't need to yell them to you as you guys are leaving will also keep posted announce what's on the forum periodically I will see you all on Friday  
﻿ all right back everybody Wednesday so we are nearing the end of our first unit of the class so today we're gonna wrap up talking about imperative programming but it's also a chance for me to do something fun because I could talk a little bit about how Java actually works so up until this point we've been teaching you about how to communicate with the machine using the java language but we haven't talked much about what's actually going on when your java code runs we've hinted a little bit at it you guys looked at the different stages that your program goes through a little bit in lab because it's important to understand the kind of error messages that you might receive but today we're actually going to talk about that a little bit more detail and i'll show you a little bit more about exactly what is going on behind the scenes so we'll start to help us out next week once we start to talk about objects okay but before we do that I have a few little bits of syntax to clean up these are sort of you know they're here at the very end of this section of the course because there's sort of oddities but I think they're worth introducing and it's good review given that we have a midterm next week so remember the wild that was the first loop that we looked at it was the first way that we had to have the computer repeat a series of steps over and over again and the while loop had this form it had a keyword while followed by a conditional expression that's evaluated every time the loop starts if that condition is true I enter the body of the loop delineated by those curly braces I run whatever code is inside there and then I return to the top and evaluate the condition again okay so this is our while loop and again that these the constructs we're talking about today are here because they're not very common but if you want you to see them briefly so here is a different form of a loop this is another valid loop you can write in Java it's called a do-while loop so you'll see it looks a little bit different so it starts with this keyword do there's a body a block Delaney bad those curly braces and then while is it the end there's still a condition what do you think this does differently than a while yeah yeah so the syntax here is designed to help you remember what happens so the condition when I run a while loop the condition is at the top that should help you remember it gets checked before I enter the loop when I do a do-while loop the condition is at the bottom it gets checked after the loop executes so while it's possible for a while loop to never execute if the first time I reach it the condition is false a do-while loop will always execute at least once because it will go through and it'll get to the bottom I'll say should I keep going if I should keep going I run the loop a second time but I'm always gonna run it once there are times you know I'm I'm bringing these things to your attention because there are times when you're gonna write some code and you'd be like oh I'm having to write this really awkward while loop and oh right I remember from years ago there's this thing called a do-while loop and that would actually clean things up quite a bit so there are some places where this is helpful so again you know we can run this run this code here and we can see that the while loop so these are two loops that have the same condition I've initialized a variable called I and I'm continuing loop while I is less than zero but I it starts at zero and therefore that condition starts out false so I never entered the loop body for the while statement but I do enter the loop body for the do-while so that's the difference okay good now if statements so again these are both sort of expansions or variations little extra spice added to these things that we've already seen so you might remember our if statements we showed you that you can use these to implement conditional logic this is how computer programs can make decisions if one thing is true on one piece of code otherwise do something else and I can shade an arbitrary number of conditions together in an if statement so you'll see something like this if one thing is true do that or else if so I can check a bunch of things and Java has a variant of this as well now Java's I just have to point out that Jabba's version of this particular programming construct is not very good but other programming they just do this much better and so you'll see this used much more powerfully in languages like Haskell and other places okay the version of this is something called a switch statement so rather than an if rather than condition condition condition in Java what I do is I say I'm switching based on some variable and I write out cases for each value that that variable could possibly take and I think in Java the variable this is one of the reasons why this statement isn't very powerful than Java is that you can only put a variable into that condition and I think it has to be a primitive type I can't remember I don't use this very often to job because it's not that helpful but you'll see this in other languages where it's much more powerful okay switches again more limited in terms of what you can check right so you can only Cho case well here's my reminder you can only check primitive types and strings but you can you can do things so an if-else statement will only execute up to one arm of the statement potentially 0 if I've got Noel so if I have an else I'll always get one a switch statement can actually bump through multiple ones depending on how you set it up so essentially what a sweat how a switch statement is executed Java looks for a case we look at one of these in the playground a second java looks for a case that matches the expression and then it starts executing there if you don't give it a brace statement I'll actually fall through and execute a bunch of pasty okay so let's let's look at how this works all right so what's going to happen here I've got a switch statement I'm switching on the value of a variable called test I have so where am I going to start what's the value of test when the statement starts executing too so which is the first letter I'm gonna print C but there's no break statement so what's my program gonna do next it's gonna print D and then it's gonna print each there you go if I set this to be zero I'll start all the way at the top if I set it to be something like five I'm just gonna get an e if I put a break in here anyway and don't do this this is gross I would put it on a separate line but I can stop at a certain point so now if I start at zero I get through the A to B to C but then I had a break which takes on the out of this which okay to spend a huge amount of time so on Friday we're gonna do full throated review with some problems and we'll look at some of the code you guys have submitted and talked about things in preparation for the midterm next week do we have any questions now before we talk do a brief discussion of Java internals well I guess it won't be brief so to be the rest of class anything else yeah so I so the question is how does a switch statement get executed so I start I go from top to bottom I looked for a case that matches the variable that I'm testing so here I start here this is K 0 the value of the variable I'm switching on is 0 and then I continue downward until I find a break or I leave the switch statement the next time so here what happened is I started at 0 I printed a I kept going I print it be I kept going I printed C and then I had a break statement the break left the switch state so let's do let's do a few more of these these are a little tricky to understand not something that you're gonna see very often so this is just gonna print C but if I start below the break statement now I'll start - I'll start to print the bottom half of the expression good good question other questions about these two new idea is any of the imperative programming stuff that we have seen so far it's fair game before I launch into fun aggressively yeah oh sorry yep thank you for the reminder this is all okay is that better okay yeah please remind me about that in the future I'd like to keep it as low as possible I don't like to hear my voice when I'm talking but but I do I do want people to be able to hear me in the back so I'm sorry should I check for that all right okay so let's talk a little bit about what is actually happening when you run a Java program so the kind of environments that we've prepared for you to use in this class we've designed for learning purposes and to do that we've had to actually hide a lot of the details from you and that's intentional I don't want you to worry about this stuff for the first couple weeks while you're just getting comfortable figuring out how to communicate with the computer at all that's confusing enough but let's look a little bit we're gonna talk about you see some of the details about what is actually happening so when you submit your code to our playground when you submit it to prayer Euler when you hit the play button or the grade button in IntelliJ what is actually going on behind the scenes and this is something that I hope will interest you you know it's a computer scientist there's you know I've always liked this about our field is you know the fact that you can simultaneously be a user as I am of many things and then when you get curious about them you can actually find out a lot more about there's a lot of documentation out there about how things work so a lot of times the way you get drawn in so for example some of you may at some point decide to learn some machine learning you're actually going to get a chance to do a little bit of that later this semester when you start off with that you're a kind of a user of these tools you're like oh wow this is cool you know library from Google that I can use to do classification on this data set and then I can make predictions based on that that's really cool but then at some point you're gonna start to wonder like hey what's actually happened how is that actually work and that's a good thing and I encourage you to you know indulge yourself in some of that cure right you don't have to understand how everything that you use works I mean maybe someday you will and that would be actually a pretty awesome place to be but you know start with things one at a time and and and dig into them a little bit and again computer science is such an open field that you can find out a lot about anything you want to learn about okay and this particular explanation may help clear up some things that might have been confusing you up to this point about the tines of error messages are getting and why certain things work the way they do okay and again this is interesting there's a I was thinking about you know am i right here this morning there was a book you could write about that has to do with this a little bit of the story that we're gonna talk about this super super interesting how some of this is involved okay and again I'm gonna try to avoid going into a you know mind-numbing amount of detail but there are people who were involved in the class I'm one of them a band is another and we have some other course developers as well who are deeply knowledgeable about the java language so if you have questions please ask and they will answer them in great detail and you will learn a lot from learning a little bit about what they know okay so let's talk about what actually happened so you you know hit submit on / learn you hit return or ctrl return in our playground what actually happens okay so roughly there are two steps and we talked about this a little bit in lab and I think it's worth reiterating so the first thing that Java does is it takes the source code that you wrote okay so we talked we talked about this we refer to this as source code and it performs a transformation that we refer to as compilation okay it compiles there's a piece of software called the Java compiler we're gonna run it in just a minute you normally don't run it yourself it gets run for you when you use IntelliJ behind the scenes or when you use Priven or whatever but there is a piece of software called the java compiler and it performs this first step in the journey from you writing a piece of code to actually seeing what it causes the computer to do that first step is a train formation your code is not being executed it is being transformed it's transformed into a format that we refer to as bytecode Java bytecode okay now how many people have used like a language like C++ or C or something like that in the past okay it teaches that in high school now oh okay poor choices anyway the there are languages out there that actually where when you compile them what you get is something that actual computer processor can execute and one of the really interesting things about Java that we're going to come back to in a few minutes is that Java was one of the first widely adopted languages to produce where the compiler produces something that you actually need another program to run okay so what you get out of the compiler is something called bytecode but there is no computer processor out there that can run this bytecode instead what you have to do and and if you get errors at the stage they're called compilation errors right if I can't compile your code I can't run it okay I'm Rooney my flow here the next thing that happens is the code is actually executed and again there's actually another computer program here that's called the java virtual machine we'll talk about why this was done in a minute okay so so again the first thing I do is I run a program called the Java compiler we're gonna refer to it as Java C in a minute that takes your source code and produces a different representation of it called bytecode then this thing called the java virtual machine sometimes we run it as just Java takes that bytecode and actually executes again you might be wondering you know okay I don't know a lot about how computers work but I know they've got this processor it's supposed to actually be able to execute instructions so why would it why am I doing this two-step process why do I have this thing called a virtual machine involved and that's actually a really interesting part of the java story that will so any errors that occur when your program is actually executed are known as runtime errors right you guys have seen a mixture of these already so let's look at some you know different types of compiler Arabs okay so the compiler can can fail in a variety of different ways right so for example if you give it something like this right like this is a perfectly valid instruction right it's just not a perfectly valid instruction to the Java compiler right so if I try to run this you know essentially this is the Java compiler throwing up its hands and being like I have no idea what you want and anyone of any number of weird things can go on because you guys have been seen there's a very formalized you know agreement that we've made with the Java compiler about how we're going to communicate with it and this violates all of that I mean there may be some day there are people out there in the world working on this problem that are trying to get us to the point where ever you could actually have computer you know compilers in computer programming languages that will actually allow us to you know execute instructions like this that would be great right I wish there was a compiler where I could just say please grade all of the mp0 checkpoint submissions right now thank you very much and it would just be done but instead you know that takes us a couple weeks to do all right all right so and then you know there are other times so actually this is still the compiler error but it's a different kind of compiler so now what you wrote is valid Java syntax but the compiler identified a problem for you and this is one place where the compiler helps talk about how compilers can help in a minute so the compiler is not only going to transform your code but it can also find mistakes so here the mistake is that you told the compiler on the left side of this initialization that you were initializing a variable of type int and on the right side you use a string literal and so the Java compiler is saying I can't you know there's there's a bug here already I notice I can't do I don't know how to convert you know either I have to change the type of the variable or I have to figure out a way to convert this string to an int and I don't know how to do this so I'm not going okay now despite the fact that the compiler can catch certain types of errors what do you think is going to happen here okay so this looks like really brain-dead code right I have a variable called s that's a string I initialize it to null you talked about last time the fact that when if I have a null object I can't do anything with it including access its length property so what's gonna happen here when I run this other than a lot of coffee I get sick later to speak I'm blaming you collectively so what happened here so this is our first example today of a runtime error so the Java compiler actually compiled this code for us and it was like hey go ahead run it see what happens right so you might wonder why right so the compiler is a piece of computer software and it would it would seem to argue I would use this as a case to say the Java compiler could do better right why doesn't the Java compiler know that this is gonna cause a problem it saw me initialize a string like don't let your friends do this right I mean it saw me initializes string to null and then try to get its length method one line later so really the compiler can't help with this and you know that's this and this is an interesting commentary on the java language you can do this you can write a piece of code like this compile it into an app deploy it on the App Store and have a crash on your friend's phone right if you want to write there's nothing preventing you and Java from doing this which is weird okay now one of the things that's actually that we as a community programming community been trying to do pure scientist have been trying to work on for a long time is to figure out how to take these runtime errors and transform them into compiler errors we talked about this a little bit before but why is this who remembers so there's two points at which I can have an error I can Evanier when I compile my code it's generated by the compiler where the compiler identifies that there's something wrong I can have an error when the code is executed so why would I like to try to take so for example I would like to take this runtime error and I would like it if the compiler would be able to identify that for me I would like the compiler to say you know no no no you can't do this that variables no and you can't use it like this so why why is that beneficial yeah yeah so the question is when does the code so let's put it this way who compiles the code think about it that way who compiles the code like you guys have apps on your phone let's let's pick on lift if you have a lift out some lyft drivers around here who compiled that code so many compiles that code a human being who like who compiled it anyone want to guess I mean if you actually know the real person I'll be very impressed right $10 if you can give me a name human being I don't think so yeah what's on so the programmer compiled the cold-blood programmer way or do they like where would you assume they probably work lived right someone at lyft built the app at some point you know they worked on it they made a bunch of changes they were changing things they were compiling the code and then at some point they were like okay we need to release this we've got some new features that we want people to to experience and so they compiled it into an app and they posted they own the app so the people that compile the code are developers they're compiling the code all the time when you guys are working on the MP you're compiling the code multiple times as you work every time you run the test Suites you may not realize this because again Java is height you know IntelliJ hides this from you every time you run the test Suites the code gets recompile so if there's a problem that the compiler can identify it gets identified very quickly so imagine that I wrote this code and I just messed up you know if the compiler could tell me right away oh by the way this code is unsafe that would be great because I would fix it clearly I didn't mean to do this this is really dumb so the code is being compiled by developers and it gets compiled before it gets executed remember if I can't compile it I can't execute it and so any bugs that I can move from runtime to compile time our bugs that a user is never going to experience so that's awesome if I get code into the wild that has bugs it's gonna crash in front of a user so developers compile the code users run the code so developers are the ones that fix compiler errors users are the ones that experience these runtime errors that manifest themselves as crashes or freezes or all sorts of other bad stuff right so the more of those runtime errors you can identify when you're compiling and developing the code the fewer your users are gonna experience which is awesome so again I'll come back to this question why does Java let me do this okay this may seem like a small matter to you but I to me this is a big problem okay I am ashamed that in 2019 the Java compiler will allow me to do this right this is wrong should this should not be okay now let me let's let's introduce ourselves to the Java compiler so hold on a sec I'm gonna switch to my desktop all right awesome so I'm gonna open up so this is the sort of program or power tool that the that was introduced in coders in last yeah but this is the command line so I'm gonna use this environment to actually you know this is the sort of the lowest level at which one of the lowest levels at which you can interact with your computer so I'm gonna use this environment to show you what's actually happening behind the scenes when we compile and run Java code alright so the first thing I'm gonna do is I'm gonna actually run this program called the Java compiler so what I did is I typed Java C that's a program and if I run it without any arguments it's gonna give me all of this information about how to use it okay so now my screen is full of all sorts of information that would be useful to be if I was actually using this on a regular basis now again most of the time you will never run the Java compiler instead IntelliJ will run it for you prior learning run it for you something else will run it for you but it's there it exists it's a program all right so let's compile some code alright so I'm gonna edit a file called example dot Java I'm gonna put some Java code in here let's see what happens okay so now what I'm doing is I'm running the compiler and I'm telling it I want you to compile the code that's inside this file I want you to compile the contents of this file example Java I try this I'm gonna see that there's a problem okay and this is one of the things that we've been hiding from you up until this point we're gonna stop hiding that next week but for now we've been allowing you to write code that isn't actually valid Java code because in Java the compiler is required that we put the code that we want to run not only into a class but into a method inside that class okay so the thing that starts on line two should look familiar to you this is a method now there are some things about this method that will be unfamiliar you haven't seen static before we're gonna get there but void is what I write when a method doesn't return any arguments the name of this method is main it takes a single argument called unused which I named because I don't use it and that argument is an array of strings okay so let's see what happens now I mean I did things correctly I'm gonna run the compiler again okay so one of the fun things and this is maybe like one of those psychological things about being a computer scientist a lot of times when you run a program and it succeeds this is what happens nothing there's no like congratulations you compiled your code nope just like I got nothing to say I just did what you wanted don't bother me again but we will what I want to show you is that what happened is that it created this other file so remember we said the compiler takes my Java code so let me display the contents of example Java that's the Java source code that I started with and it transforms it into a different representation that different representation is called bytecode bytecode is what's in this other file now I don't want to display the contents of that file to you the way I did here because you wouldn't be able to read it it's only readable by a computer but Java comes with a special program for displaying the contents of what are called class files and this is it can we have one conversation here ladies thanks all right so here's here's the bytecode that was actually produced now this has been printed displayed in a way to help us make sense of it but I don't know I don't expect you to understand I just want to show you a little bit about what's going on behind the scene okay so this is what's this is the contents of the bytecode inside that class file format in a way to try to help us understand these remember wash I didn't tell you this so but byte code consists of is a series of simpler instructions that are then run by the Java Virtual Machine okay and here are the instructions over here I'm not gonna we don't have anywhere close to enough time to explain what these are but this is that second representation of your code so you started off with the source code there was Java source code and now this is the Java bytecode okay and now I have a program I could run so I'm now I'm gonna use this second program that I told you about so again just like Java see I have a second program called just Java so Java C is the java compiler just Java is the Java Virtual Machine and you'll see just like Java C if I run it on its own it gives me lots of arguments about how I can run it in different ways like I said before not a program you're gonna typically run on your own said it's gonna be run for you by and tell the trigger something like that but I can now actually run my code so here's the format for doing that oh it's mad at me about something go back and fix this oh I didn't it's not public alright I'm gonna add one more modifier to this Oh want to show you something okay so I just modified the source code to fix this problem that occurred when I ran it all right so now I'm gonna run it again but I'm still getting the same problem so I'm like I just fixed that why is this happening yeah yeah so I skipped that first step I've changed the source code but I haven't changed the byte code and so I need to rerun that step of compiling my code and again this is all done behind the scenes for you when you run the test Suites on IntelliJ roughly what's happening is the compiler IntelliJ runs the compiler that produces a bunch of byte code and then as a separate step it runs java and executes the code in the test Suites that then run some tests on your code and figure out what happened that's basically what's going on so now I can run my program so now I've run the Java compiler at first step Java C and I've also run this second piece of software called Jonathan now I just want to make sure that we're clear about one thing both Java and Java C are software these are computer programs written by human beings nothing magical about them I don't think they're written in Java I think they were written in like C++ or something like that but but this is how this works okay all right so we did the Java C and we did the job okay so as I mentioned before this bytecode was one of the innovative features of Java when the language was introduced was this idea that in the past the compiler would produce code that was directly executable by a computer processor Java was one of the first widely executed why the sort of deployed languages that that produce this other representation and this was unusual at the time okay so Java produces bytecode why so anyone no reason yeah so so the reason for this is the following and this was more true at the time the Java came out so it used to be does anyone see how old people are in here does anyone remember when Mac started using Intel processors in their laptops they remember that happening I can identify anyone here who's like older than 30 right or maybe you guys write about I mean it wasn't it was a long time ago but there was a period of time where the computer processor that ran inside Apple computers was different than the computer processor that ran inside Windows computers and other types of computers and so the problem was if you compile the program on a Windows PC and you tried to send it to your friend who had a Mac it would run it was like written in a different language you can think of the two processors as speaking two completely different languages one of them spoke Intel x86 the other one spoke PowerPC and so if you take something that I wrote in until x86 and try to read it to a PowerPC processor it's just like I have no idea what's going on and so bytecode was designed to solve that problem so I could actually take this compiled piece of code that I just created so if I go back here this example dot class file I could take that file and I could send it to you anyone in this room and you could run it on your computer you would do the same thing I just did you would say Java and then you would tell it where to find the byte code and so this was at the time the real selling point behind Java and it was the design decision that really created a lot of you know it was the design decision that motivated a lot of the other features of Java so this was their slogan write once run anywhere so idea was any developer could write a program compile it on their machine and then send it to anyone in the world who could run it as long as they had that program job the java virtual machines how many people have ever been prompted to like update Java you know you need to update your runtime that what it's doing you have that program installed does anyone else know where that program is installed probably the most common place that that Java program is installed Java is installed in a lot of computers but it's installed on one type of computer in particular of which there are billions out there in the world a lot of you have them maybe you didn't know it and we know what it is circular kind of device that runs Java that is probably responsible for sort of saving the Java programming language for the last decade or so what is it Android smartphones every single Android smartphone runs job the programs that you write in this class are written in Java because they're going to be compiled to Java when when I've seen commercials or I don't know maybe you see different ads than I do but you know son likes to brag about how many devices run Java there's like you know 10 billion devices in the world that run Java I think like 5 billion of those are Android phones and so that is one of the places where where people are running okay I just settle this awesome all right so one of the things that's happened so let's fast-forward to the future now so now we know a little bit about how Java works but the dama language and the Java compiler are quite old and one of the things that's been happening is compilers our computer software every single piece of computer software has been riding this incredible wave of increasing speed and power for the past couple of decades you know you guys have lived through this this is one of those things that I think it's almost impossible to appreciate it's like trying to think about the age of the universe it's like I know it's like billions of years but I have no way of understanding that time scale is a human being it's just too dissimilar from the time scales I'm used to the increase in computer performance in the sense in the time that you've been alive the time that I've been alive is just flabbergasted there's no way to wrap your mind around right I mean when people say the phone in your pocket is as powerful as data centers were supercomputers where 20 or 30 years ago that's actually true it's not an exaggeration right people say is about all sorts of things right but it's actually true about computers it's stunning so one of the things that's getting faster more powerful should be those compilers that's an important tool for you if you're a program the more the compiler can do the better it can help you out and Java finally lately has started to make some changes to the compiler that might interest you let me show you one of them okay so this is actually valid Java code how many people knew that okay APCs apparently has to realize that there's Java 10 oh okay what is going on here okay so this looks like a variable declaration and initialization based on the right side I feel like it's an integer but I don't see an integer here I see this thing called bear and maybe if I've written some JavaScript this is bringing back bad memories bad old days of JavaScript but this is valid Java code okay so what is happening here so this is one of the and this is just one example of one place where the java compiler is starting to do more for you it's starting to help you out why can I do this let me ask you this question so up until now we would have had to say int integer value is equal to 5 but why can I replace that int with this placeholder I can do the same thing with the double if I replace the right side with the double or a character or a string this works fine I don't have to change the bear why is that possible who can explain this to me so normally in job I have to tell when I'm initialization variable this have to tell the compiler what the type is but why don't I have to do that anymore and this is not just a feature in Java a lot of programming languages now have this feature thank you super easy why don't I have to tell so again normally I would have to say let's see here this works right so normally up here I would have to say int I is equal to 0 in sum is equal to 0 that works fine but I can also replace that with their works fine why don't I have to tell the compiler what the type is how what is it doing it's helping me out it's making my life easier could explain this yeah so yeah basically so let me let me go back to the first example that was sort of what I showed you when we started the class right if you look at this carefully you'll realize that I'm actually telling Java what the type of sum is twice I'm telling it on the left side as part of the declaration but I'm also telling it on the right side because I'm initializing it with an integer literal and so this very keyword in Java 10 allows the compiler to do what's called local type inference the compiler can infer what the type of sum is because I'm initializing it with an integer literal so the compiler says ok you're trying to stump me here use this very keyword not exactly sure I'm used to being told more about what to do but I'm gonna play along so I see that you have a variable called sum and I see that you want me to figure out I'm supposed to guess what there what the type is alright well I have a big clue here which is that you've initialized it to an int literal so I'm gonna assign it to be an int ya no Python just doesn't have types at all please yeah Python is like whatever you know actually that actually sorry that's not true Hite and Python a variable the type of variable could be changed at any point right so in Python I can do people that are Python programmers I can do this basically I could say in sum is equal to zero and then I could say hope changed my mind I want it to be a string now and I can do this is that a good idea I've been written a lot of code in both languages I kind of want the best of both worlds and we're actually getting closer to being able to have that but yeah so python does have types internally in Python the type of a variable can change at any point right so there's no guarantees that it's still going to be you know even if I initialize that with an int there's no air guarantees so gonna be an int light okay so let me point out one thing if I don't give the compiler enough information then this local type inference will fail so this is not going to work right and the reason is it says cannot infer variable type for this variable because I didn't give it a clue I didn't initially right so it says there's no initialization here so I'm stumped right and I think actually the Java 10 compiler is still dumb enough that yeah even if I like assign it in a minute it doesn't okay this isn't enough of a clue for it right so I literally have to have a literal value as part of the initialization for okay let me briefly talk about this main method we'll come back to this next week because we're gonna start seeing in our examples so when I wrote when I needed to write that valid piece of Java code you probably might even noticed quickly two things there were two things I had to do to get it to work one is that I had to wrap it in a class and we're gonna talk about objects next week but we've been hiding that from you on purpose the second thing was I had to use this very specific name for the function I had to call it public static void main and it had to take a string an array of string argument so why is this what is the main method so in a Java program you might think when I run a Java program where does it start running how does it know where to start I might have 10 different methods how does it know what the first line of code runs should be after it starts running somewhere then it's gonna run it's gonna run your loops and your FL statements and it's called their function so whatever but I have to start somewhere right and in Java this is the entry point for Java programs somewhere in your Java program you need to have a function called main has to have this signature and that's what's going to launch everything else if it's an app when that function starts that but that function needs to draw the display and start communicating with the network and wait for users to do things and so this is the this is the entry point okay so every Java program has to start in a main method so the the second question and I'll just leave this is a exercise for for the listener is why does it get passed an array of arguments and why are they strings okay any questions about this before we wrap up we might be done a few minutes earlier which is okay there's an exam in here at 11:00 what's that how do you fix the run time here so runtime error usually is there's something wrong with your code you need to modify the code right how do you I but here's here's a better question how do you identify how do you make sure that users what's one tool that we're using already in the NP to make sure that users don't see errors what are you guys doing all day long superg on the AP test Suites yeah so testing is a huge part of modern software development like you know when you write an app at a big company they're not just like oh you know you wrote like you know Trevor wrote some changes in let's just push it out tomorrow and see what happens right if you were Netscape that's what you did but most companies now have a really rigorous testing process before things actually go live all right so look I just want to you know close with some words of encouragement this is so this is a tough point in this semester I understand that in addition to all the coffee I guess you guys are all sick as well which is rough don't give up over the next week or so we have a midterm FMP 0 that's do we got some homework problems this is as hard as the imperative programming part of the class is gonna get so just hang in there you know keep putting one foot in front of the other you guys are gonna be fine you're gonna get to the midterm you're gonna do great prepare for it the way that you would finish up NP zero ok so on Monday we turn the page and we start talking about objects on Friday I will be here for one last discussion of imperative programming and midterm review so that's what we do on front we're back here I'm not gonna have much of an agenda and basically gonna be here to take questions we'll go through some practice problems together anything I can do to help you prepare for the midterm NP 0 is due on your deadline day this weekend office hours are open today and tomorrow great day to come in it's very quiet I will see you on Friday please try to leave quickly there is an exam in here at 12:00  
